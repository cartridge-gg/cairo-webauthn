// This file is script-generated.
// Don't modify it manually!
// See test_gen_scripts/verify_signature_test.py for details
use core::traits::Into;
use result::ResultTrait;
use core::option::OptionTrait;
use webauthn::ecdsa::{verify_ecdsa, verify_hashed_ecdsa, VerifyEcdsaError};
use webauthn::types::PublicKey;
use webauthn::webauthn::verify_signature;
use webauthn::errors::AuthnErrorIntoFelt252;
use starknet::secp256r1::Secp256r1Impl;
use starknet::secp256r1::Secp256r1Point;
use starknet::SyscallResultTrait;
use array::ArrayTrait;

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_0(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x36);
	hash.append(0x6c);
	hash.append(0xa9);
	hash.append(0xff);
	hash.append(0xcd);
	hash.append(0x5b);
	hash.append(0xfa);
	hash.append(0x97);
	hash.append(0x88);
	hash.append(0x2f);
	hash.append(0xd3);
	hash.append(0x81);
	hash.append(0x24);
	hash.append(0xbf);
	hash.append(0x94);
	hash.append(0x14);
	hash.append(0xc3);
	hash.append(0x60);
	hash.append(0xb3);
	hash.append(0x89);
	hash.append(0x99);
	hash.append(0x69);
	hash.append(0x0);
	hash.append(0x9e);
	hash.append(0x88);
	hash.append(0x70);
	hash.append(0x23);
	hash.append(0x98);
	hash.append(0xc6);
	hash.append(0xbd);
	hash.append(0x4b);
	hash.append(0x28);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xf8);
	auth_data.append(0xa0);
	auth_data.append(0x2d);
	auth_data.append(0x69);
	auth_data.append(0xb3);
	auth_data.append(0x2b);
	auth_data.append(0xf4);
	auth_data.append(0xc9);
	auth_data.append(0x1f);
	auth_data.append(0xd);
	auth_data.append(0x4);
	auth_data.append(0x89);
	auth_data.append(0x30);
	auth_data.append(0x82);
	auth_data.append(0x64);
	auth_data.append(0x49);
	auth_data.append(0x94);
	auth_data.append(0x90);
	auth_data.append(0x91);
	auth_data.append(0xb1);
	auth_data.append(0xd3);
	auth_data.append(0xdc);
	auth_data.append(0x9e);
	auth_data.append(0x33);
	auth_data.append(0xef);
	auth_data.append(0x4d);
	auth_data.append(0xe4);
	auth_data.append(0xf5);
	auth_data.append(0x63);
	auth_data.append(0x4);
	auth_data.append(0x65);
	auth_data.append(0x30);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xac);
	sig.append(0xbd);
	sig.append(0xfb);
	sig.append(0xca);
	sig.append(0x6b);
	sig.append(0xa0);
	sig.append(0xce);
	sig.append(0x4);
	sig.append(0xfc);
	sig.append(0x95);
	sig.append(0xcf);
	sig.append(0x64);
	sig.append(0xa7);
	sig.append(0x91);
	sig.append(0x68);
	sig.append(0xb7);
	sig.append(0x4a);
	sig.append(0x20);
	sig.append(0x81);
	sig.append(0xf);
	sig.append(0xc3);
	sig.append(0x4);
	sig.append(0x38);
	sig.append(0xe9);
	sig.append(0xd0);
	sig.append(0xbe);
	sig.append(0xc4);
	sig.append(0xb9);
	sig.append(0xe3);
	sig.append(0x81);
	sig.append(0x74);
	sig.append(0xf9);
	sig.append(0x6a);
	sig.append(0xa2);
	sig.append(0x64);
	sig.append(0x53);
	sig.append(0x74);
	sig.append(0xc0);
	sig.append(0xdb);
	sig.append(0x4a);
	sig.append(0xf0);
	sig.append(0xa3);
	sig.append(0x7d);
	sig.append(0xdf);
	sig.append(0xd);
	sig.append(0xa9);
	sig.append(0x1);
	sig.append(0xe2);
	sig.append(0x43);
	sig.append(0x51);
	sig.append(0x21);
	sig.append(0xb1);
	sig.append(0x7c);
	sig.append(0xd3);
	sig.append(0x7f);
	sig.append(0x87);
	sig.append(0x7f);
	sig.append(0xbf);
	sig.append(0xfe);
	sig.append(0x0);
	sig.append(0xa0);
	sig.append(0x32);
	sig.append(0x79);
	sig.append(0x86);
	let pk = PublicKey {
		 x: 93255417727977223850832583572614263222501762608963679263988989300399958489333, 
		 y: 21090840959016259412197673029829985228556696956057696668902143803732331759030
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_1(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x9b);
	hash.append(0x1d);
	hash.append(0x7);
	hash.append(0x22);
	hash.append(0x7);
	hash.append(0x58);
	hash.append(0x18);
	hash.append(0xfa);
	hash.append(0xae);
	hash.append(0x9d);
	hash.append(0xf7);
	hash.append(0xbf);
	hash.append(0x36);
	hash.append(0xb9);
	hash.append(0x7d);
	hash.append(0x1f);
	hash.append(0xa0);
	hash.append(0x6d);
	hash.append(0xb7);
	hash.append(0x30);
	hash.append(0xf4);
	hash.append(0x23);
	hash.append(0x66);
	hash.append(0x41);
	hash.append(0x4e);
	hash.append(0x77);
	hash.append(0x1a);
	hash.append(0x81);
	hash.append(0x26);
	hash.append(0x2d);
	hash.append(0x7b);
	hash.append(0xf9);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x45);
	auth_data.append(0x95);
	auth_data.append(0x3);
	auth_data.append(0xe);
	auth_data.append(0x21);
	auth_data.append(0x44);
	auth_data.append(0xfc);
	auth_data.append(0xce);
	auth_data.append(0xf4);
	auth_data.append(0xb0);
	auth_data.append(0x8e);
	auth_data.append(0xe2);
	auth_data.append(0x4);
	auth_data.append(0xef);
	auth_data.append(0x7b);
	auth_data.append(0xd9);
	auth_data.append(0x5d);
	auth_data.append(0x7b);
	auth_data.append(0x5d);
	auth_data.append(0xfe);
	auth_data.append(0x92);
	auth_data.append(0x2f);
	auth_data.append(0x35);
	auth_data.append(0x7c);
	auth_data.append(0x1e);
	auth_data.append(0x49);
	auth_data.append(0x89);
	auth_data.append(0xf6);
	auth_data.append(0x89);
	auth_data.append(0x31);
	auth_data.append(0x3e);
	auth_data.append(0xee);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x9b);
	sig.append(0xd8);
	sig.append(0x4e);
	sig.append(0x3);
	sig.append(0xf6);
	sig.append(0xf);
	sig.append(0xbe);
	sig.append(0x6a);
	sig.append(0x1a);
	sig.append(0x55);
	sig.append(0xd1);
	sig.append(0xcc);
	sig.append(0x4c);
	sig.append(0xa9);
	sig.append(0x52);
	sig.append(0xcc);
	sig.append(0xcf);
	sig.append(0xad);
	sig.append(0xe2);
	sig.append(0x73);
	sig.append(0x58);
	sig.append(0x98);
	sig.append(0x61);
	sig.append(0x11);
	sig.append(0x94);
	sig.append(0x2f);
	sig.append(0xd);
	sig.append(0xed);
	sig.append(0x5f);
	sig.append(0x8b);
	sig.append(0x73);
	sig.append(0xd4);
	sig.append(0xc0);
	sig.append(0xfe);
	sig.append(0x32);
	sig.append(0xc4);
	sig.append(0x3c);
	sig.append(0x1c);
	sig.append(0xca);
	sig.append(0xe5);
	sig.append(0x46);
	sig.append(0x6d);
	sig.append(0xeb);
	sig.append(0xac);
	sig.append(0x71);
	sig.append(0x7);
	sig.append(0x2f);
	sig.append(0x56);
	sig.append(0x9);
	sig.append(0xda);
	sig.append(0xf9);
	sig.append(0xe7);
	sig.append(0x9);
	sig.append(0x9);
	sig.append(0xed);
	sig.append(0xd9);
	sig.append(0x9d);
	sig.append(0xa6);
	sig.append(0xb1);
	sig.append(0xa);
	sig.append(0xb9);
	sig.append(0x85);
	sig.append(0x70);
	sig.append(0x24);
	let pk = PublicKey {
		 x: 26081803693808138395739732592230497636145915694162172201829359036080900402871, 
		 y: 104903074170604115741240546168402404748194441573778525441174345446984381886320
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_2(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x1e);
	hash.append(0xaa);
	hash.append(0x31);
	hash.append(0x4f);
	hash.append(0xc);
	hash.append(0x25);
	hash.append(0xc7);
	hash.append(0xa3);
	hash.append(0x66);
	hash.append(0x31);
	hash.append(0xb2);
	hash.append(0xa9);
	hash.append(0xcd);
	hash.append(0x4c);
	hash.append(0x70);
	hash.append(0x7d);
	hash.append(0x72);
	hash.append(0xa9);
	hash.append(0x5b);
	hash.append(0x78);
	hash.append(0x7);
	hash.append(0x63);
	hash.append(0xf6);
	hash.append(0xa9);
	hash.append(0xdc);
	hash.append(0x23);
	hash.append(0x71);
	hash.append(0x49);
	hash.append(0xfe);
	hash.append(0xca);
	hash.append(0xd9);
	hash.append(0x31);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x47);
	auth_data.append(0x36);
	auth_data.append(0xdc);
	auth_data.append(0xca);
	auth_data.append(0x5b);
	auth_data.append(0x42);
	auth_data.append(0xa4);
	auth_data.append(0x7c);
	auth_data.append(0x28);
	auth_data.append(0xc9);
	auth_data.append(0xc4);
	auth_data.append(0xba);
	auth_data.append(0xcc);
	auth_data.append(0x8e);
	auth_data.append(0xef);
	auth_data.append(0x71);
	auth_data.append(0x22);
	auth_data.append(0x5c);
	auth_data.append(0xeb);
	auth_data.append(0x67);
	auth_data.append(0xd4);
	auth_data.append(0x36);
	auth_data.append(0x26);
	auth_data.append(0xf4);
	auth_data.append(0xc3);
	auth_data.append(0x16);
	auth_data.append(0x3b);
	auth_data.append(0x6);
	auth_data.append(0x86);
	auth_data.append(0x36);
	auth_data.append(0x19);
	auth_data.append(0x20);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x3f);
	sig.append(0x21);
	sig.append(0x61);
	sig.append(0xfa);
	sig.append(0xc7);
	sig.append(0xb9);
	sig.append(0xd2);
	sig.append(0xac);
	sig.append(0xad);
	sig.append(0x81);
	sig.append(0x25);
	sig.append(0xac);
	sig.append(0x4);
	sig.append(0xef);
	sig.append(0x2e);
	sig.append(0x2e);
	sig.append(0x13);
	sig.append(0x1a);
	sig.append(0x97);
	sig.append(0x6f);
	sig.append(0x2f);
	sig.append(0xb6);
	sig.append(0x71);
	sig.append(0xa8);
	sig.append(0x14);
	sig.append(0xf6);
	sig.append(0x55);
	sig.append(0xbc);
	sig.append(0x1f);
	sig.append(0xc2);
	sig.append(0x7f);
	sig.append(0x34);
	sig.append(0x48);
	sig.append(0xf8);
	sig.append(0x0);
	sig.append(0xfc);
	sig.append(0x4f);
	sig.append(0x38);
	sig.append(0xae);
	sig.append(0x97);
	sig.append(0x6d);
	sig.append(0x5a);
	sig.append(0xd5);
	sig.append(0xe4);
	sig.append(0x3d);
	sig.append(0x47);
	sig.append(0xa9);
	sig.append(0xd1);
	sig.append(0xa0);
	sig.append(0xf7);
	sig.append(0x54);
	sig.append(0xf0);
	sig.append(0x66);
	sig.append(0x65);
	sig.append(0xbe);
	sig.append(0x1c);
	sig.append(0xd6);
	sig.append(0xa6);
	sig.append(0x7e);
	sig.append(0x6a);
	sig.append(0x91);
	sig.append(0xb2);
	sig.append(0xe3);
	sig.append(0x55);
	let pk = PublicKey {
		 x: 98860797922417032746771358839160929887525668096702912610859064337986011625972, 
		 y: 40728913464364213852515850996770679232808183593761753172877423208109710907872
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_3(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xef);
	hash.append(0xa0);
	hash.append(0x6c);
	hash.append(0x87);
	hash.append(0x7d);
	hash.append(0xbf);
	hash.append(0x20);
	hash.append(0x9f);
	hash.append(0xd0);
	hash.append(0x3e);
	hash.append(0x8e);
	hash.append(0x38);
	hash.append(0xe2);
	hash.append(0xc9);
	hash.append(0x7e);
	hash.append(0xb9);
	hash.append(0xb8);
	hash.append(0xfa);
	hash.append(0x4);
	hash.append(0x6);
	hash.append(0xbb);
	hash.append(0x33);
	hash.append(0xc0);
	hash.append(0x6);
	hash.append(0xfd);
	hash.append(0xa0);
	hash.append(0x53);
	hash.append(0x20);
	hash.append(0x56);
	hash.append(0xe9);
	hash.append(0x18);
	hash.append(0x3b);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x2e);
	auth_data.append(0x40);
	auth_data.append(0xcb);
	auth_data.append(0x76);
	auth_data.append(0x14);
	auth_data.append(0xcc);
	auth_data.append(0x2b);
	auth_data.append(0xc9);
	auth_data.append(0xad);
	auth_data.append(0x39);
	auth_data.append(0x2f);
	auth_data.append(0xba);
	auth_data.append(0x6b);
	auth_data.append(0xdd);
	auth_data.append(0xc8);
	auth_data.append(0xbb);
	auth_data.append(0xda);
	auth_data.append(0x4e);
	auth_data.append(0xe4);
	auth_data.append(0xa);
	auth_data.append(0x18);
	auth_data.append(0x2a);
	auth_data.append(0x6c);
	auth_data.append(0xe0);
	auth_data.append(0xa2);
	auth_data.append(0x5a);
	auth_data.append(0xf7);
	auth_data.append(0x94);
	auth_data.append(0xee);
	auth_data.append(0x6a);
	auth_data.append(0x8c);
	auth_data.append(0xd3);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x51);
	sig.append(0x5b);
	sig.append(0xf0);
	sig.append(0x9e);
	sig.append(0x98);
	sig.append(0xcc);
	sig.append(0x7f);
	sig.append(0xea);
	sig.append(0xb7);
	sig.append(0xfc);
	sig.append(0x7);
	sig.append(0xdb);
	sig.append(0x2f);
	sig.append(0xfd);
	sig.append(0xff);
	sig.append(0x41);
	sig.append(0xc7);
	sig.append(0xde);
	sig.append(0x49);
	sig.append(0xd7);
	sig.append(0x4b);
	sig.append(0x53);
	sig.append(0xcf);
	sig.append(0x2b);
	sig.append(0x7d);
	sig.append(0x6d);
	sig.append(0xa9);
	sig.append(0x6a);
	sig.append(0x59);
	sig.append(0x12);
	sig.append(0x8e);
	sig.append(0x5a);
	sig.append(0x24);
	sig.append(0x5b);
	sig.append(0xdb);
	sig.append(0x5b);
	sig.append(0xaa);
	sig.append(0x88);
	sig.append(0x60);
	sig.append(0x5b);
	sig.append(0x29);
	sig.append(0xe0);
	sig.append(0x7c);
	sig.append(0xf5);
	sig.append(0x5);
	sig.append(0x25);
	sig.append(0xc6);
	sig.append(0x1);
	sig.append(0xde);
	sig.append(0x76);
	sig.append(0xc1);
	sig.append(0xb7);
	sig.append(0x71);
	sig.append(0xe2);
	sig.append(0x44);
	sig.append(0x36);
	sig.append(0xc1);
	sig.append(0xa4);
	sig.append(0xcb);
	sig.append(0xd4);
	sig.append(0x9f);
	sig.append(0x89);
	sig.append(0xf3);
	sig.append(0xd0);
	let pk = PublicKey {
		 x: 22911603358753337344384530329311337727488477505998446583687605495528180603328, 
		 y: 36852946850177741658393305608442332772300923716171793109928351899925113973151
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_4(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x75);
	hash.append(0x60);
	hash.append(0x1b);
	hash.append(0x55);
	hash.append(0x19);
	hash.append(0x38);
	hash.append(0x65);
	hash.append(0x1a);
	hash.append(0x77);
	hash.append(0x9a);
	hash.append(0xe9);
	hash.append(0xd6);
	hash.append(0x2);
	hash.append(0x55);
	hash.append(0xac);
	hash.append(0x3d);
	hash.append(0x95);
	hash.append(0xa3);
	hash.append(0xb7);
	hash.append(0x15);
	hash.append(0x29);
	hash.append(0xaf);
	hash.append(0x97);
	hash.append(0x16);
	hash.append(0xc0);
	hash.append(0xb9);
	hash.append(0x7e);
	hash.append(0x88);
	hash.append(0x6a);
	hash.append(0x42);
	hash.append(0xe5);
	hash.append(0x41);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x20);
	auth_data.append(0xf3);
	auth_data.append(0x75);
	auth_data.append(0x3);
	auth_data.append(0x50);
	auth_data.append(0x9d);
	auth_data.append(0xbc);
	auth_data.append(0x42);
	auth_data.append(0x41);
	auth_data.append(0x53);
	auth_data.append(0x6);
	auth_data.append(0x5e);
	auth_data.append(0x21);
	auth_data.append(0x82);
	auth_data.append(0xbd);
	auth_data.append(0x5d);
	auth_data.append(0x6f);
	auth_data.append(0x4a);
	auth_data.append(0x4);
	auth_data.append(0x5);
	auth_data.append(0x81);
	auth_data.append(0xad);
	auth_data.append(0x5);
	auth_data.append(0x58);
	auth_data.append(0x0);
	auth_data.append(0xea);
	auth_data.append(0xd1);
	auth_data.append(0xe5);
	auth_data.append(0x5);
	auth_data.append(0x7);
	auth_data.append(0x90);
	auth_data.append(0x33);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x4);
	sig.append(0x9d);
	sig.append(0x99);
	sig.append(0xa2);
	sig.append(0xb2);
	sig.append(0xbc);
	sig.append(0xd6);
	sig.append(0x48);
	sig.append(0x73);
	sig.append(0xba);
	sig.append(0xe2);
	sig.append(0x2a);
	sig.append(0x52);
	sig.append(0xa4);
	sig.append(0xaf);
	sig.append(0x54);
	sig.append(0xa);
	sig.append(0x9e);
	sig.append(0x87);
	sig.append(0x71);
	sig.append(0xd6);
	sig.append(0xe4);
	sig.append(0xa8);
	sig.append(0xea);
	sig.append(0x20);
	sig.append(0xda);
	sig.append(0x3a);
	sig.append(0x44);
	sig.append(0x87);
	sig.append(0x88);
	sig.append(0x8a);
	sig.append(0xd);
	sig.append(0x87);
	sig.append(0x3);
	sig.append(0xe5);
	sig.append(0x80);
	sig.append(0xd2);
	sig.append(0x63);
	sig.append(0x61);
	sig.append(0x52);
	sig.append(0xf7);
	sig.append(0x2a);
	sig.append(0x2a);
	sig.append(0x7d);
	sig.append(0x1e);
	sig.append(0x3d);
	sig.append(0x42);
	sig.append(0xdb);
	sig.append(0xcd);
	sig.append(0x85);
	sig.append(0x18);
	sig.append(0x81);
	sig.append(0x24);
	sig.append(0x70);
	sig.append(0x46);
	sig.append(0x25);
	sig.append(0x75);
	sig.append(0x71);
	sig.append(0x34);
	sig.append(0x9b);
	sig.append(0x10);
	sig.append(0x6);
	sig.append(0xbc);
	sig.append(0x95);
	let pk = PublicKey {
		 x: 15979469102818287630299617915979165479439024438107907120665872123108361313654, 
		 y: 106908272309033990092078955444979514859862217880714083764554555866365167973532
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_5(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x44);
	hash.append(0x1);
	hash.append(0xc0);
	hash.append(0xe7);
	hash.append(0xc7);
	hash.append(0xdf);
	hash.append(0x97);
	hash.append(0x3e);
	hash.append(0x9b);
	hash.append(0x8a);
	hash.append(0x35);
	hash.append(0xef);
	hash.append(0x5d);
	hash.append(0xb1);
	hash.append(0xb4);
	hash.append(0x4b);
	hash.append(0x94);
	hash.append(0x72);
	hash.append(0x76);
	hash.append(0x23);
	hash.append(0x26);
	hash.append(0xfe);
	hash.append(0x28);
	hash.append(0x83);
	hash.append(0x87);
	hash.append(0x79);
	hash.append(0x3d);
	hash.append(0xca);
	hash.append(0x13);
	hash.append(0x45);
	hash.append(0xdb);
	hash.append(0x18);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xe2);
	auth_data.append(0x3a);
	auth_data.append(0x69);
	auth_data.append(0x28);
	auth_data.append(0x4e);
	auth_data.append(0x88);
	auth_data.append(0xf1);
	auth_data.append(0x47);
	auth_data.append(0x70);
	auth_data.append(0x59);
	auth_data.append(0x8c);
	auth_data.append(0xfb);
	auth_data.append(0x8);
	auth_data.append(0xac);
	auth_data.append(0x20);
	auth_data.append(0xcb);
	auth_data.append(0x63);
	auth_data.append(0x7b);
	auth_data.append(0x49);
	auth_data.append(0xf);
	auth_data.append(0x2b);
	auth_data.append(0xd9);
	auth_data.append(0x65);
	auth_data.append(0xfd);
	auth_data.append(0x95);
	auth_data.append(0x79);
	auth_data.append(0xdd);
	auth_data.append(0xb5);
	auth_data.append(0xed);
	auth_data.append(0x32);
	auth_data.append(0xde);
	auth_data.append(0xe2);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x40);
	sig.append(0xa1);
	sig.append(0x38);
	sig.append(0x84);
	sig.append(0x38);
	sig.append(0x63);
	sig.append(0x53);
	sig.append(0x9f);
	sig.append(0xea);
	sig.append(0xa2);
	sig.append(0x42);
	sig.append(0xdd);
	sig.append(0x24);
	sig.append(0x9e);
	sig.append(0xf1);
	sig.append(0xbd);
	sig.append(0x9f);
	sig.append(0x9b);
	sig.append(0x45);
	sig.append(0x33);
	sig.append(0xa4);
	sig.append(0x3e);
	sig.append(0x5b);
	sig.append(0x52);
	sig.append(0x49);
	sig.append(0xef);
	sig.append(0x4a);
	sig.append(0xed);
	sig.append(0x37);
	sig.append(0xe8);
	sig.append(0xe2);
	sig.append(0xb2);
	sig.append(0x9e);
	sig.append(0x95);
	sig.append(0xfc);
	sig.append(0xdc);
	sig.append(0x65);
	sig.append(0x7a);
	sig.append(0x10);
	sig.append(0x72);
	sig.append(0xea);
	sig.append(0x3c);
	sig.append(0x7d);
	sig.append(0xb8);
	sig.append(0xaa);
	sig.append(0xdf);
	sig.append(0xd7);
	sig.append(0x35);
	sig.append(0x6c);
	sig.append(0xdc);
	sig.append(0x3b);
	sig.append(0xf3);
	sig.append(0x5f);
	sig.append(0x7f);
	sig.append(0xea);
	sig.append(0xb4);
	sig.append(0x84);
	sig.append(0x8c);
	sig.append(0x74);
	sig.append(0x52);
	sig.append(0xc5);
	sig.append(0x99);
	sig.append(0xc2);
	sig.append(0xe6);
	let pk = PublicKey {
		 x: 74733344415122870368736893586356285723282293130561872258672870678796762356141, 
		 y: 79683036803157953829056414432763626092859778240037808691654976802040487089815
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_6(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x8);
	hash.append(0x2);
	hash.append(0xf6);
	hash.append(0x6b);
	hash.append(0x9a);
	hash.append(0x9a);
	hash.append(0xb3);
	hash.append(0x9d);
	hash.append(0xc2);
	hash.append(0xc4);
	hash.append(0xf2);
	hash.append(0xe0);
	hash.append(0x33);
	hash.append(0x99);
	hash.append(0xe5);
	hash.append(0x64);
	hash.append(0x8d);
	hash.append(0x50);
	hash.append(0x32);
	hash.append(0xb);
	hash.append(0x64);
	hash.append(0x8a);
	hash.append(0x3e);
	hash.append(0xca);
	hash.append(0x72);
	hash.append(0xca);
	hash.append(0x17);
	hash.append(0xf1);
	hash.append(0x1a);
	hash.append(0xbe);
	hash.append(0xf0);
	hash.append(0xf9);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xe0);
	auth_data.append(0x41);
	auth_data.append(0x63);
	auth_data.append(0x98);
	auth_data.append(0xf7);
	auth_data.append(0x3e);
	auth_data.append(0x71);
	auth_data.append(0x1a);
	auth_data.append(0x89);
	auth_data.append(0x3d);
	auth_data.append(0x3b);
	auth_data.append(0x52);
	auth_data.append(0x57);
	auth_data.append(0xc6);
	auth_data.append(0x6e);
	auth_data.append(0x3b);
	auth_data.append(0x95);
	auth_data.append(0xf5);
	auth_data.append(0x9);
	auth_data.append(0x9b);
	auth_data.append(0x26);
	auth_data.append(0x81);
	auth_data.append(0xf9);
	auth_data.append(0xe6);
	auth_data.append(0xe2);
	auth_data.append(0xb3);
	auth_data.append(0x48);
	auth_data.append(0x53);
	auth_data.append(0x42);
	auth_data.append(0x1e);
	auth_data.append(0xd0);
	auth_data.append(0x2);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x46);
	sig.append(0xb0);
	sig.append(0x6f);
	sig.append(0x2c);
	sig.append(0xe2);
	sig.append(0x63);
	sig.append(0x6f);
	sig.append(0xc3);
	sig.append(0x9b);
	sig.append(0x1e);
	sig.append(0xdd);
	sig.append(0x36);
	sig.append(0x97);
	sig.append(0x9a);
	sig.append(0x84);
	sig.append(0x99);
	sig.append(0xa1);
	sig.append(0xec);
	sig.append(0xbf);
	sig.append(0x9a);
	sig.append(0x9c);
	sig.append(0xab);
	sig.append(0x4e);
	sig.append(0x3c);
	sig.append(0xad);
	sig.append(0x2d);
	sig.append(0xe2);
	sig.append(0x0);
	sig.append(0x70);
	sig.append(0xda);
	sig.append(0x64);
	sig.append(0x28);
	sig.append(0xb1);
	sig.append(0xcd);
	sig.append(0xa);
	sig.append(0x5f);
	sig.append(0x3e);
	sig.append(0x76);
	sig.append(0x60);
	sig.append(0x50);
	sig.append(0x2a);
	sig.append(0xdb);
	sig.append(0x72);
	sig.append(0xb0);
	sig.append(0x24);
	sig.append(0x52);
	sig.append(0x4a);
	sig.append(0x2c);
	sig.append(0x13);
	sig.append(0xd);
	sig.append(0x3f);
	sig.append(0x2a);
	sig.append(0x3);
	sig.append(0xf8);
	sig.append(0x6e);
	sig.append(0xca);
	sig.append(0xe);
	sig.append(0x79);
	sig.append(0x9c);
	sig.append(0x80);
	sig.append(0xf3);
	sig.append(0x5b);
	sig.append(0x72);
	sig.append(0x2c);
	let pk = PublicKey {
		 x: 199068147965559846305836142007425563371356323418609662274528576872645959360, 
		 y: 62979614400062075266477880362242431627295768877160988347989064161808063754540
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_7(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xc3);
	hash.append(0xd);
	hash.append(0x76);
	hash.append(0x60);
	hash.append(0x6c);
	hash.append(0x23);
	hash.append(0xab);
	hash.append(0x8f);
	hash.append(0xef);
	hash.append(0x64);
	hash.append(0xae);
	hash.append(0x58);
	hash.append(0xf6);
	hash.append(0x1);
	hash.append(0x3a);
	hash.append(0x15);
	hash.append(0xe5);
	hash.append(0x3f);
	hash.append(0x45);
	hash.append(0xc5);
	hash.append(0xf0);
	hash.append(0xcb);
	hash.append(0x5c);
	hash.append(0xf8);
	hash.append(0xb5);
	hash.append(0xd4);
	hash.append(0x75);
	hash.append(0x55);
	hash.append(0xfa);
	hash.append(0xe8);
	hash.append(0xf3);
	hash.append(0x13);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x47);
	auth_data.append(0x9);
	auth_data.append(0x83);
	auth_data.append(0xe2);
	auth_data.append(0x9f);
	auth_data.append(0x6d);
	auth_data.append(0x85);
	auth_data.append(0x52);
	auth_data.append(0xcf);
	auth_data.append(0xb1);
	auth_data.append(0xbf);
	auth_data.append(0x73);
	auth_data.append(0x13);
	auth_data.append(0x5c);
	auth_data.append(0x78);
	auth_data.append(0x73);
	auth_data.append(0xa0);
	auth_data.append(0xce);
	auth_data.append(0x72);
	auth_data.append(0xbe);
	auth_data.append(0xdd);
	auth_data.append(0xde);
	auth_data.append(0x3a);
	auth_data.append(0xae);
	auth_data.append(0x4);
	auth_data.append(0x8c);
	auth_data.append(0xed);
	auth_data.append(0x95);
	auth_data.append(0xbb);
	auth_data.append(0xe);
	auth_data.append(0x6d);
	auth_data.append(0x7d);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xcd);
	sig.append(0x9e);
	sig.append(0x34);
	sig.append(0x33);
	sig.append(0x50);
	sig.append(0xe9);
	sig.append(0xb7);
	sig.append(0xc8);
	sig.append(0x4d);
	sig.append(0x61);
	sig.append(0x22);
	sig.append(0x74);
	sig.append(0x45);
	sig.append(0x9a);
	sig.append(0xd4);
	sig.append(0x7d);
	sig.append(0x7c);
	sig.append(0x17);
	sig.append(0x96);
	sig.append(0xb9);
	sig.append(0x4d);
	sig.append(0xe4);
	sig.append(0x31);
	sig.append(0xd0);
	sig.append(0x4b);
	sig.append(0x10);
	sig.append(0xcb);
	sig.append(0x9e);
	sig.append(0x6);
	sig.append(0xf2);
	sig.append(0x68);
	sig.append(0x54);
	sig.append(0xa);
	sig.append(0xd8);
	sig.append(0xe5);
	sig.append(0x0);
	sig.append(0x3);
	sig.append(0x5);
	sig.append(0x56);
	sig.append(0x60);
	sig.append(0x20);
	sig.append(0x4f);
	sig.append(0x9c);
	sig.append(0x22);
	sig.append(0x57);
	sig.append(0xe4);
	sig.append(0xf8);
	sig.append(0x7a);
	sig.append(0x32);
	sig.append(0xfe);
	sig.append(0x38);
	sig.append(0x12);
	sig.append(0x83);
	sig.append(0x5);
	sig.append(0xd3);
	sig.append(0xfe);
	sig.append(0x65);
	sig.append(0x8c);
	sig.append(0x61);
	sig.append(0x18);
	sig.append(0x98);
	sig.append(0x3c);
	sig.append(0x94);
	sig.append(0xf);
	let pk = PublicKey {
		 x: 17286292370741590447560354811965395196256513791145502855253516533144377589734, 
		 y: 101175934890256487267086162655854973690198845285377413408805052729003214389496
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_8(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x7a);
	hash.append(0xff);
	hash.append(0x45);
	hash.append(0xed);
	hash.append(0x95);
	hash.append(0x1a);
	hash.append(0x73);
	hash.append(0xba);
	hash.append(0x9b);
	hash.append(0x44);
	hash.append(0xed);
	hash.append(0x34);
	hash.append(0x90);
	hash.append(0x7c);
	hash.append(0xb7);
	hash.append(0xb3);
	hash.append(0x89);
	hash.append(0xc6);
	hash.append(0x6d);
	hash.append(0xd8);
	hash.append(0xb6);
	hash.append(0xdc);
	hash.append(0x9d);
	hash.append(0x27);
	hash.append(0x55);
	hash.append(0xda);
	hash.append(0x56);
	hash.append(0x65);
	hash.append(0x69);
	hash.append(0x6e);
	hash.append(0x46);
	hash.append(0xc);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xae);
	auth_data.append(0xe3);
	auth_data.append(0xce);
	auth_data.append(0x1e);
	auth_data.append(0x36);
	auth_data.append(0x2e);
	auth_data.append(0x2);
	auth_data.append(0xde);
	auth_data.append(0x89);
	auth_data.append(0x97);
	auth_data.append(0xc6);
	auth_data.append(0xd8);
	auth_data.append(0xca);
	auth_data.append(0xd8);
	auth_data.append(0x6f);
	auth_data.append(0x76);
	auth_data.append(0xa3);
	auth_data.append(0x45);
	auth_data.append(0xea);
	auth_data.append(0x8e);
	auth_data.append(0xbc);
	auth_data.append(0x7);
	auth_data.append(0xe7);
	auth_data.append(0x57);
	auth_data.append(0x53);
	auth_data.append(0x8f);
	auth_data.append(0x31);
	auth_data.append(0xd9);
	auth_data.append(0x45);
	auth_data.append(0x3e);
	auth_data.append(0x1c);
	auth_data.append(0xd5);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x4f);
	sig.append(0x6b);
	sig.append(0xda);
	sig.append(0x59);
	sig.append(0xb6);
	sig.append(0x6a);
	sig.append(0x5);
	sig.append(0x3a);
	sig.append(0xd0);
	sig.append(0xc1);
	sig.append(0x3b);
	sig.append(0xea);
	sig.append(0x29);
	sig.append(0x1e);
	sig.append(0xd);
	sig.append(0x59);
	sig.append(0xae);
	sig.append(0x16);
	sig.append(0x1a);
	sig.append(0xe6);
	sig.append(0xe6);
	sig.append(0x0);
	sig.append(0xde);
	sig.append(0xe5);
	sig.append(0x4c);
	sig.append(0x10);
	sig.append(0xe6);
	sig.append(0x56);
	sig.append(0xa4);
	sig.append(0xd2);
	sig.append(0x70);
	sig.append(0xb7);
	sig.append(0x2e);
	sig.append(0x80);
	sig.append(0xcc);
	sig.append(0x93);
	sig.append(0x3d);
	sig.append(0xd3);
	sig.append(0xf9);
	sig.append(0xb);
	sig.append(0x36);
	sig.append(0xdb);
	sig.append(0x48);
	sig.append(0xcf);
	sig.append(0x21);
	sig.append(0x9e);
	sig.append(0x2e);
	sig.append(0x9b);
	sig.append(0x69);
	sig.append(0xb0);
	sig.append(0x70);
	sig.append(0xf6);
	sig.append(0x7d);
	sig.append(0xe7);
	sig.append(0xbf);
	sig.append(0x5);
	sig.append(0x81);
	sig.append(0xd7);
	sig.append(0x1);
	sig.append(0x8a);
	sig.append(0xa2);
	sig.append(0x98);
	sig.append(0xc7);
	sig.append(0xf0);
	let pk = PublicKey {
		 x: 70323421626673127788751088544592302666104223049220883965006475441310806984599, 
		 y: 77549117176478353580310921673618108335477974885516868805532956494315349808934
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_9(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x2c);
	hash.append(0xd2);
	hash.append(0x8b);
	hash.append(0x6c);
	hash.append(0xce);
	hash.append(0xc7);
	hash.append(0xb1);
	hash.append(0x53);
	hash.append(0xf2);
	hash.append(0xee);
	hash.append(0x60);
	hash.append(0x9c);
	hash.append(0x3c);
	hash.append(0x90);
	hash.append(0x13);
	hash.append(0x85);
	hash.append(0xa3);
	hash.append(0x8b);
	hash.append(0x50);
	hash.append(0xc4);
	hash.append(0xa8);
	hash.append(0xeb);
	hash.append(0x56);
	hash.append(0x91);
	hash.append(0xb0);
	hash.append(0x87);
	hash.append(0x4b);
	hash.append(0x3d);
	hash.append(0x47);
	hash.append(0xf0);
	hash.append(0x3f);
	hash.append(0x6d);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x9b);
	auth_data.append(0x62);
	auth_data.append(0x63);
	auth_data.append(0x1);
	auth_data.append(0xad);
	auth_data.append(0x6d);
	auth_data.append(0xa2);
	auth_data.append(0xb9);
	auth_data.append(0x1f);
	auth_data.append(0x68);
	auth_data.append(0xa6);
	auth_data.append(0xc2);
	auth_data.append(0x9a);
	auth_data.append(0x17);
	auth_data.append(0xb3);
	auth_data.append(0x87);
	auth_data.append(0x98);
	auth_data.append(0x54);
	auth_data.append(0x68);
	auth_data.append(0x84);
	auth_data.append(0xb);
	auth_data.append(0x50);
	auth_data.append(0x49);
	auth_data.append(0x1b);
	auth_data.append(0xf7);
	auth_data.append(0x37);
	auth_data.append(0xcc);
	auth_data.append(0xef);
	auth_data.append(0x41);
	auth_data.append(0x19);
	auth_data.append(0x58);
	auth_data.append(0x91);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xff);
	sig.append(0x36);
	sig.append(0x5a);
	sig.append(0xcf);
	sig.append(0x85);
	sig.append(0xa1);
	sig.append(0x2e);
	sig.append(0xaf);
	sig.append(0xc6);
	sig.append(0x79);
	sig.append(0x25);
	sig.append(0x39);
	sig.append(0xc);
	sig.append(0xc9);
	sig.append(0x41);
	sig.append(0x3f);
	sig.append(0x2a);
	sig.append(0x27);
	sig.append(0x8a);
	sig.append(0xe5);
	sig.append(0xd9);
	sig.append(0x9c);
	sig.append(0x5e);
	sig.append(0xb8);
	sig.append(0xc6);
	sig.append(0x69);
	sig.append(0x60);
	sig.append(0x24);
	sig.append(0xeb);
	sig.append(0x3d);
	sig.append(0xf4);
	sig.append(0x7a);
	sig.append(0x15);
	sig.append(0x26);
	sig.append(0xa6);
	sig.append(0x8c);
	sig.append(0xe7);
	sig.append(0x1e);
	sig.append(0x39);
	sig.append(0x1b);
	sig.append(0x37);
	sig.append(0x5e);
	sig.append(0xc7);
	sig.append(0xb7);
	sig.append(0x4d);
	sig.append(0x99);
	sig.append(0xce);
	sig.append(0xab);
	sig.append(0x59);
	sig.append(0x4f);
	sig.append(0x6a);
	sig.append(0xfe);
	sig.append(0xb7);
	sig.append(0x9d);
	sig.append(0xbd);
	sig.append(0xbe);
	sig.append(0xe8);
	sig.append(0x77);
	sig.append(0x4d);
	sig.append(0xf8);
	sig.append(0xf3);
	sig.append(0xc2);
	sig.append(0x7f);
	sig.append(0x93);
	let pk = PublicKey {
		 x: 73350745963838205996045137424596598804149837164226046404355093764551902044714, 
		 y: 111924507716369902651758710178353067916870503112056802214907187584248390141636
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_10(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x6e);
	hash.append(0xa9);
	hash.append(0x63);
	hash.append(0x11);
	hash.append(0xc7);
	hash.append(0xc5);
	hash.append(0x48);
	hash.append(0x52);
	hash.append(0xc4);
	hash.append(0xa3);
	hash.append(0x76);
	hash.append(0x4d);
	hash.append(0x39);
	hash.append(0x69);
	hash.append(0x87);
	hash.append(0xf6);
	hash.append(0x94);
	hash.append(0x76);
	hash.append(0x60);
	hash.append(0x7f);
	hash.append(0xf3);
	hash.append(0xe3);
	hash.append(0x70);
	hash.append(0x61);
	hash.append(0x82);
	hash.append(0x12);
	hash.append(0x6a);
	hash.append(0x22);
	hash.append(0x14);
	hash.append(0x2);
	hash.append(0xf2);
	hash.append(0x5c);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x93);
	auth_data.append(0x91);
	auth_data.append(0xaf);
	auth_data.append(0x49);
	auth_data.append(0x24);
	auth_data.append(0x4c);
	auth_data.append(0x7e);
	auth_data.append(0x9b);
	auth_data.append(0xa7);
	auth_data.append(0x91);
	auth_data.append(0xf8);
	auth_data.append(0x98);
	auth_data.append(0xc0);
	auth_data.append(0xcc);
	auth_data.append(0xf);
	auth_data.append(0xa8);
	auth_data.append(0xdd);
	auth_data.append(0x6a);
	auth_data.append(0x76);
	auth_data.append(0xd0);
	auth_data.append(0x91);
	auth_data.append(0xc0);
	auth_data.append(0xef);
	auth_data.append(0xfe);
	auth_data.append(0x7c);
	auth_data.append(0xa8);
	auth_data.append(0xe7);
	auth_data.append(0x51);
	auth_data.append(0x8f);
	auth_data.append(0xf6);
	auth_data.append(0x19);
	auth_data.append(0x4d);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xc1);
	sig.append(0xac);
	sig.append(0x28);
	sig.append(0x8f);
	sig.append(0xea);
	sig.append(0xce);
	sig.append(0x64);
	sig.append(0x49);
	sig.append(0x7);
	sig.append(0xa3);
	sig.append(0x0);
	sig.append(0x46);
	sig.append(0xed);
	sig.append(0x3b);
	sig.append(0x97);
	sig.append(0x40);
	sig.append(0xf9);
	sig.append(0x6);
	sig.append(0x61);
	sig.append(0xe1);
	sig.append(0xd4);
	sig.append(0x8c);
	sig.append(0x73);
	sig.append(0xcc);
	sig.append(0x6b);
	sig.append(0x7d);
	sig.append(0x42);
	sig.append(0x4a);
	sig.append(0x29);
	sig.append(0x1a);
	sig.append(0x3c);
	sig.append(0xb7);
	sig.append(0xd);
	sig.append(0x71);
	sig.append(0x40);
	sig.append(0x66);
	sig.append(0x15);
	sig.append(0x72);
	sig.append(0x10);
	sig.append(0x6e);
	sig.append(0x5b);
	sig.append(0xc4);
	sig.append(0x7);
	sig.append(0x6e);
	sig.append(0xce);
	sig.append(0xb1);
	sig.append(0xed);
	sig.append(0x3c);
	sig.append(0x76);
	sig.append(0x78);
	sig.append(0x77);
	sig.append(0x6f);
	sig.append(0x64);
	sig.append(0x80);
	sig.append(0xac);
	sig.append(0xde);
	sig.append(0xe);
	sig.append(0x16);
	sig.append(0x6a);
	sig.append(0xda);
	sig.append(0xac);
	sig.append(0xa8);
	sig.append(0xba);
	sig.append(0x24);
	let pk = PublicKey {
		 x: 85321319512224831988689065210452302762170759472028184049597493087539533345286, 
		 y: 62545721484023314472649256850963991175556869548100556603433948435391002782340
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_11(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xda);
	hash.append(0x6c);
	hash.append(0x6a);
	hash.append(0xc5);
	hash.append(0xd4);
	hash.append(0xc5);
	hash.append(0x53);
	hash.append(0x54);
	hash.append(0x72);
	hash.append(0xbb);
	hash.append(0x8d);
	hash.append(0x23);
	hash.append(0x87);
	hash.append(0xf);
	hash.append(0xc6);
	hash.append(0xb1);
	hash.append(0x63);
	hash.append(0x8a);
	hash.append(0x3c);
	hash.append(0xaf);
	hash.append(0x4d);
	hash.append(0xa0);
	hash.append(0x42);
	hash.append(0x82);
	hash.append(0x40);
	hash.append(0x28);
	hash.append(0x9);
	hash.append(0xf3);
	hash.append(0xa8);
	hash.append(0xaf);
	hash.append(0xb7);
	hash.append(0x35);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xcb);
	auth_data.append(0xe9);
	auth_data.append(0xb);
	auth_data.append(0x40);
	auth_data.append(0xfb);
	auth_data.append(0x55);
	auth_data.append(0x5e);
	auth_data.append(0x81);
	auth_data.append(0x53);
	auth_data.append(0x71);
	auth_data.append(0x1b);
	auth_data.append(0x22);
	auth_data.append(0x96);
	auth_data.append(0xe8);
	auth_data.append(0xcf);
	auth_data.append(0x4f);
	auth_data.append(0x2a);
	auth_data.append(0x65);
	auth_data.append(0xd4);
	auth_data.append(0x1c);
	auth_data.append(0x96);
	auth_data.append(0x61);
	auth_data.append(0x61);
	auth_data.append(0xb7);
	auth_data.append(0x41);
	auth_data.append(0x7f);
	auth_data.append(0x61);
	auth_data.append(0x11);
	auth_data.append(0x83);
	auth_data.append(0xc7);
	auth_data.append(0x33);
	auth_data.append(0x8f);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x23);
	sig.append(0x93);
	sig.append(0xe9);
	sig.append(0x92);
	sig.append(0x37);
	sig.append(0xf2);
	sig.append(0xe1);
	sig.append(0x91);
	sig.append(0x5d);
	sig.append(0x79);
	sig.append(0xcf);
	sig.append(0xd0);
	sig.append(0x9f);
	sig.append(0x53);
	sig.append(0x63);
	sig.append(0xe9);
	sig.append(0x3b);
	sig.append(0xf5);
	sig.append(0x5b);
	sig.append(0x7c);
	sig.append(0x3e);
	sig.append(0x1e);
	sig.append(0x79);
	sig.append(0x93);
	sig.append(0x65);
	sig.append(0x64);
	sig.append(0x91);
	sig.append(0x3e);
	sig.append(0xbd);
	sig.append(0xa2);
	sig.append(0x60);
	sig.append(0x6b);
	sig.append(0xdf);
	sig.append(0xb0);
	sig.append(0xea);
	sig.append(0x76);
	sig.append(0x40);
	sig.append(0xbd);
	sig.append(0x96);
	sig.append(0xc);
	sig.append(0x57);
	sig.append(0xc4);
	sig.append(0x85);
	sig.append(0xf7);
	sig.append(0x87);
	sig.append(0x8b);
	sig.append(0x42);
	sig.append(0xeb);
	sig.append(0x17);
	sig.append(0x96);
	sig.append(0x0);
	sig.append(0x1e);
	sig.append(0xed);
	sig.append(0xb9);
	sig.append(0xba);
	sig.append(0xb4);
	sig.append(0x93);
	sig.append(0x92);
	sig.append(0xfe);
	sig.append(0xe);
	sig.append(0x14);
	sig.append(0x4e);
	sig.append(0xd9);
	sig.append(0x32);
	let pk = PublicKey {
		 x: 71716775703161062202035884394479844144055136001654080010315833830449336046566, 
		 y: 2706495473816049815450861031051281917695240042878025548036011403691616039930
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_12(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x62);
	hash.append(0x84);
	hash.append(0x3e);
	hash.append(0x81);
	hash.append(0x9e);
	hash.append(0x38);
	hash.append(0xdd);
	hash.append(0xf5);
	hash.append(0x69);
	hash.append(0xdf);
	hash.append(0xbe);
	hash.append(0x7);
	hash.append(0x36);
	hash.append(0xe5);
	hash.append(0xc8);
	hash.append(0x41);
	hash.append(0xe3);
	hash.append(0xe0);
	hash.append(0xba);
	hash.append(0x94);
	hash.append(0x12);
	hash.append(0xb8);
	hash.append(0xce);
	hash.append(0xe7);
	hash.append(0xfd);
	hash.append(0x7b);
	hash.append(0x67);
	hash.append(0x19);
	hash.append(0xba);
	hash.append(0x2a);
	hash.append(0xac);
	hash.append(0x71);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x60);
	auth_data.append(0xfa);
	auth_data.append(0x17);
	auth_data.append(0x69);
	auth_data.append(0xe7);
	auth_data.append(0xa4);
	auth_data.append(0x50);
	auth_data.append(0x95);
	auth_data.append(0xea);
	auth_data.append(0x89);
	auth_data.append(0xa0);
	auth_data.append(0xb8);
	auth_data.append(0x1c);
	auth_data.append(0x41);
	auth_data.append(0xa1);
	auth_data.append(0x66);
	auth_data.append(0xef);
	auth_data.append(0x16);
	auth_data.append(0x7e);
	auth_data.append(0x55);
	auth_data.append(0x7d);
	auth_data.append(0xe7);
	auth_data.append(0xd8);
	auth_data.append(0x1);
	auth_data.append(0x35);
	auth_data.append(0x13);
	auth_data.append(0x95);
	auth_data.append(0x1);
	auth_data.append(0x26);
	auth_data.append(0xad);
	auth_data.append(0x9b);
	auth_data.append(0xc9);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x94);
	sig.append(0x2d);
	sig.append(0xbd);
	sig.append(0x9b);
	sig.append(0x6b);
	sig.append(0x7e);
	sig.append(0xeb);
	sig.append(0x9);
	sig.append(0xfb);
	sig.append(0x28);
	sig.append(0x86);
	sig.append(0xb8);
	sig.append(0x1d);
	sig.append(0x43);
	sig.append(0x44);
	sig.append(0xcf);
	sig.append(0x50);
	sig.append(0x7b);
	sig.append(0xfb);
	sig.append(0x83);
	sig.append(0x3);
	sig.append(0xb0);
	sig.append(0x49);
	sig.append(0x2d);
	sig.append(0xcf);
	sig.append(0x5f);
	sig.append(0x56);
	sig.append(0x64);
	sig.append(0x8);
	sig.append(0x93);
	sig.append(0x3a);
	sig.append(0x71);
	sig.append(0x75);
	sig.append(0xa2);
	sig.append(0x22);
	sig.append(0x82);
	sig.append(0xd7);
	sig.append(0x5f);
	sig.append(0xc2);
	sig.append(0x1f);
	sig.append(0xae);
	sig.append(0x4a);
	sig.append(0x45);
	sig.append(0x7c);
	sig.append(0x65);
	sig.append(0xc4);
	sig.append(0xc8);
	sig.append(0x47);
	sig.append(0xb8);
	sig.append(0xf8);
	sig.append(0xf3);
	sig.append(0x85);
	sig.append(0x55);
	sig.append(0xa3);
	sig.append(0x5a);
	sig.append(0xf6);
	sig.append(0x9c);
	sig.append(0x3a);
	sig.append(0x9b);
	sig.append(0xdc);
	sig.append(0xc0);
	sig.append(0xec);
	sig.append(0xb6);
	sig.append(0xbb);
	let pk = PublicKey {
		 x: 11001002166878629759569926543269588003649214184161675995113883405451799310421, 
		 y: 13422465419859938291346391902571420128994282756577924462992912749516989237734
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_13(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x44);
	hash.append(0x71);
	hash.append(0xb8);
	hash.append(0x29);
	hash.append(0x50);
	hash.append(0xec);
	hash.append(0x7c);
	hash.append(0x5f);
	hash.append(0x43);
	hash.append(0x5);
	hash.append(0x47);
	hash.append(0x7a);
	hash.append(0x85);
	hash.append(0xae);
	hash.append(0x81);
	hash.append(0x7e);
	hash.append(0xa1);
	hash.append(0x8e);
	hash.append(0x78);
	hash.append(0x9f);
	hash.append(0x53);
	hash.append(0x1f);
	hash.append(0x1b);
	hash.append(0xb0);
	hash.append(0x3f);
	hash.append(0x21);
	hash.append(0x26);
	hash.append(0xa3);
	hash.append(0x55);
	hash.append(0x1b);
	hash.append(0xaa);
	hash.append(0x7e);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xbd);
	auth_data.append(0x3c);
	auth_data.append(0x6b);
	auth_data.append(0xe6);
	auth_data.append(0xe6);
	auth_data.append(0x53);
	auth_data.append(0xdd);
	auth_data.append(0xf2);
	auth_data.append(0xf5);
	auth_data.append(0x1c);
	auth_data.append(0x40);
	auth_data.append(0x56);
	auth_data.append(0x48);
	auth_data.append(0x7c);
	auth_data.append(0x9);
	auth_data.append(0xff);
	auth_data.append(0xe4);
	auth_data.append(0x65);
	auth_data.append(0x2d);
	auth_data.append(0x63);
	auth_data.append(0x46);
	auth_data.append(0x66);
	auth_data.append(0xeb);
	auth_data.append(0xb6);
	auth_data.append(0x2d);
	auth_data.append(0x5b);
	auth_data.append(0x79);
	auth_data.append(0x2c);
	auth_data.append(0xd6);
	auth_data.append(0x86);
	auth_data.append(0x2a);
	auth_data.append(0x16);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x53);
	sig.append(0xc9);
	sig.append(0xea);
	sig.append(0xec);
	sig.append(0x1);
	sig.append(0x39);
	sig.append(0x42);
	sig.append(0x38);
	sig.append(0x29);
	sig.append(0x1c);
	sig.append(0x43);
	sig.append(0xf6);
	sig.append(0xc);
	sig.append(0x48);
	sig.append(0x50);
	sig.append(0x9b);
	sig.append(0x5);
	sig.append(0xd0);
	sig.append(0xcd);
	sig.append(0x60);
	sig.append(0xcf);
	sig.append(0xc9);
	sig.append(0x44);
	sig.append(0x38);
	sig.append(0x42);
	sig.append(0x3d);
	sig.append(0x1e);
	sig.append(0xb2);
	sig.append(0xd8);
	sig.append(0x28);
	sig.append(0xe3);
	sig.append(0xdc);
	sig.append(0xcc);
	sig.append(0x22);
	sig.append(0xe9);
	sig.append(0xd7);
	sig.append(0x99);
	sig.append(0xf3);
	sig.append(0x50);
	sig.append(0x53);
	sig.append(0xd2);
	sig.append(0x18);
	sig.append(0xab);
	sig.append(0xe);
	sig.append(0x99);
	sig.append(0xcf);
	sig.append(0x93);
	sig.append(0xc9);
	sig.append(0xa2);
	sig.append(0x64);
	sig.append(0xb4);
	sig.append(0x6f);
	sig.append(0x38);
	sig.append(0x7a);
	sig.append(0x71);
	sig.append(0x59);
	sig.append(0xd3);
	sig.append(0x3c);
	sig.append(0x11);
	sig.append(0xf3);
	sig.append(0x1c);
	sig.append(0x56);
	sig.append(0x45);
	sig.append(0xbf);
	let pk = PublicKey {
		 x: 21843524652057017547780035084023734288799559122313097459682383641380311839212, 
		 y: 3474275014707650153566764848517283524704103079911024469893186011008178081965
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_14(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x3b);
	hash.append(0xbd);
	hash.append(0x17);
	hash.append(0x52);
	hash.append(0x24);
	hash.append(0xe2);
	hash.append(0xa8);
	hash.append(0x95);
	hash.append(0x33);
	hash.append(0x27);
	hash.append(0xf);
	hash.append(0x12);
	hash.append(0x72);
	hash.append(0x71);
	hash.append(0xf9);
	hash.append(0x42);
	hash.append(0x0);
	hash.append(0x75);
	hash.append(0x3);
	hash.append(0x67);
	hash.append(0xed);
	hash.append(0xb3);
	hash.append(0x44);
	hash.append(0x74);
	hash.append(0xa6);
	hash.append(0xca);
	hash.append(0xd6);
	hash.append(0xe0);
	hash.append(0x9f);
	hash.append(0xe4);
	hash.append(0x1a);
	hash.append(0x2c);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xaf);
	auth_data.append(0x6a);
	auth_data.append(0x6f);
	auth_data.append(0xdf);
	auth_data.append(0x65);
	auth_data.append(0x2b);
	auth_data.append(0x68);
	auth_data.append(0xd7);
	auth_data.append(0x82);
	auth_data.append(0xfb);
	auth_data.append(0x82);
	auth_data.append(0x8c);
	auth_data.append(0x74);
	auth_data.append(0xf1);
	auth_data.append(0xad);
	auth_data.append(0x3);
	auth_data.append(0x42);
	auth_data.append(0xc);
	auth_data.append(0x85);
	auth_data.append(0x5b);
	auth_data.append(0x22);
	auth_data.append(0x92);
	auth_data.append(0xe0);
	auth_data.append(0xc0);
	auth_data.append(0x89);
	auth_data.append(0xe2);
	auth_data.append(0x21);
	auth_data.append(0x87);
	auth_data.append(0xe2);
	auth_data.append(0x1d);
	auth_data.append(0x5f);
	auth_data.append(0xee);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xfc);
	sig.append(0xa4);
	sig.append(0x6f);
	sig.append(0x3f);
	sig.append(0x9c);
	sig.append(0xc7);
	sig.append(0x82);
	sig.append(0x8);
	sig.append(0xaa);
	sig.append(0xf4);
	sig.append(0x99);
	sig.append(0x46);
	sig.append(0x51);
	sig.append(0x2e);
	sig.append(0x30);
	sig.append(0xf5);
	sig.append(0xeb);
	sig.append(0x79);
	sig.append(0xfb);
	sig.append(0x1d);
	sig.append(0x93);
	sig.append(0x9b);
	sig.append(0xb);
	sig.append(0xda);
	sig.append(0x6a);
	sig.append(0xc5);
	sig.append(0x74);
	sig.append(0xd0);
	sig.append(0xef);
	sig.append(0x3a);
	sig.append(0xed);
	sig.append(0x8d);
	sig.append(0x9a);
	sig.append(0x9c);
	sig.append(0x4);
	sig.append(0x17);
	sig.append(0x73);
	sig.append(0xd4);
	sig.append(0x26);
	sig.append(0xba);
	sig.append(0xa5);
	sig.append(0x3b);
	sig.append(0x59);
	sig.append(0xe7);
	sig.append(0xfc);
	sig.append(0xb1);
	sig.append(0xee);
	sig.append(0xb1);
	sig.append(0x8a);
	sig.append(0x3a);
	sig.append(0xf);
	sig.append(0x48);
	sig.append(0x5e);
	sig.append(0x27);
	sig.append(0xce);
	sig.append(0xc2);
	sig.append(0xc1);
	sig.append(0x46);
	sig.append(0xce);
	sig.append(0x87);
	sig.append(0x7d);
	sig.append(0x1c);
	sig.append(0x7c);
	sig.append(0xf3);
	let pk = PublicKey {
		 x: 43398277219402396212197439701746836954176388584791401736463801778205318117743, 
		 y: 98704021156150781164667392728717754954014018354284618979115890980918533947077
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_15(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xa);
	hash.append(0x47);
	hash.append(0xac);
	hash.append(0x60);
	hash.append(0x93);
	hash.append(0x79);
	hash.append(0xc4);
	hash.append(0x4e);
	hash.append(0x8e);
	hash.append(0x42);
	hash.append(0xad);
	hash.append(0xc1);
	hash.append(0xc5);
	hash.append(0xb8);
	hash.append(0xa4);
	hash.append(0xe0);
	hash.append(0x61);
	hash.append(0x8);
	hash.append(0xdc);
	hash.append(0x23);
	hash.append(0x4a);
	hash.append(0x2f);
	hash.append(0x3f);
	hash.append(0x40);
	hash.append(0x2b);
	hash.append(0x27);
	hash.append(0x5f);
	hash.append(0xfa);
	hash.append(0x4f);
	hash.append(0x61);
	hash.append(0x5b);
	hash.append(0x38);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x36);
	auth_data.append(0xf2);
	auth_data.append(0xd5);
	auth_data.append(0xf1);
	auth_data.append(0x2e);
	auth_data.append(0x32);
	auth_data.append(0xbb);
	auth_data.append(0x8c);
	auth_data.append(0x13);
	auth_data.append(0x51);
	auth_data.append(0xef);
	auth_data.append(0xd5);
	auth_data.append(0xca);
	auth_data.append(0xc4);
	auth_data.append(0x2a);
	auth_data.append(0x52);
	auth_data.append(0x7b);
	auth_data.append(0xc6);
	auth_data.append(0xd);
	auth_data.append(0x41);
	auth_data.append(0x36);
	auth_data.append(0xb0);
	auth_data.append(0x5);
	auth_data.append(0x2a);
	auth_data.append(0x84);
	auth_data.append(0x95);
	auth_data.append(0x67);
	auth_data.append(0x98);
	auth_data.append(0xfc);
	auth_data.append(0xd4);
	auth_data.append(0x5d);
	auth_data.append(0xcd);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x4);
	sig.append(0x64);
	sig.append(0xa);
	sig.append(0xdf);
	sig.append(0xa0);
	sig.append(0x9c);
	sig.append(0x14);
	sig.append(0xc8);
	sig.append(0xc1);
	sig.append(0xa0);
	sig.append(0x31);
	sig.append(0xef);
	sig.append(0x25);
	sig.append(0xbf);
	sig.append(0x53);
	sig.append(0x10);
	sig.append(0xe1);
	sig.append(0x80);
	sig.append(0x3e);
	sig.append(0x86);
	sig.append(0x70);
	sig.append(0x91);
	sig.append(0x2);
	sig.append(0xef);
	sig.append(0xcd);
	sig.append(0x76);
	sig.append(0xab);
	sig.append(0xfe);
	sig.append(0xf8);
	sig.append(0x7e);
	sig.append(0x1b);
	sig.append(0xd9);
	sig.append(0x9e);
	sig.append(0xd2);
	sig.append(0xb);
	sig.append(0xe9);
	sig.append(0x6f);
	sig.append(0x8b);
	sig.append(0xbe);
	sig.append(0x33);
	sig.append(0x53);
	sig.append(0x67);
	sig.append(0xfd);
	sig.append(0x1d);
	sig.append(0xe2);
	sig.append(0xbe);
	sig.append(0x93);
	sig.append(0xc9);
	sig.append(0xa0);
	sig.append(0x15);
	sig.append(0x6);
	sig.append(0x6b);
	sig.append(0x85);
	sig.append(0x80);
	sig.append(0x3e);
	sig.append(0x54);
	sig.append(0xad);
	sig.append(0xfd);
	sig.append(0xec);
	sig.append(0xb0);
	sig.append(0x61);
	sig.append(0x8b);
	sig.append(0x29);
	sig.append(0x82);
	let pk = PublicKey {
		 x: 10731050290986855967828291036422029103022512914250184453155992805099242272542, 
		 y: 91286164482634371142539217093355994926940255334124169486759459574142076241950
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_16(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x39);
	hash.append(0xc3);
	hash.append(0xca);
	hash.append(0xef);
	hash.append(0x61);
	hash.append(0x2f);
	hash.append(0xe9);
	hash.append(0xc6);
	hash.append(0x1c);
	hash.append(0xeb);
	hash.append(0x39);
	hash.append(0xf2);
	hash.append(0xcc);
	hash.append(0x8a);
	hash.append(0xd5);
	hash.append(0x55);
	hash.append(0x3b);
	hash.append(0x9b);
	hash.append(0xd0);
	hash.append(0xb7);
	hash.append(0xb4);
	hash.append(0xba);
	hash.append(0xab);
	hash.append(0x41);
	hash.append(0x5b);
	hash.append(0x22);
	hash.append(0x37);
	hash.append(0x99);
	hash.append(0xfd);
	hash.append(0xe1);
	hash.append(0x4b);
	hash.append(0xad);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xed);
	auth_data.append(0xdc);
	auth_data.append(0x35);
	auth_data.append(0x63);
	auth_data.append(0x42);
	auth_data.append(0x44);
	auth_data.append(0x28);
	auth_data.append(0x8f);
	auth_data.append(0xa3);
	auth_data.append(0x7e);
	auth_data.append(0xd4);
	auth_data.append(0x23);
	auth_data.append(0xab);
	auth_data.append(0xb);
	auth_data.append(0xdb);
	auth_data.append(0x24);
	auth_data.append(0xe1);
	auth_data.append(0x6a);
	auth_data.append(0xa9);
	auth_data.append(0x7d);
	auth_data.append(0xe);
	auth_data.append(0xab);
	auth_data.append(0xb4);
	auth_data.append(0x37);
	auth_data.append(0x9f);
	auth_data.append(0x86);
	auth_data.append(0xe6);
	auth_data.append(0x5);
	auth_data.append(0x18);
	auth_data.append(0x11);
	auth_data.append(0x88);
	auth_data.append(0xe);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x3b);
	sig.append(0xf9);
	sig.append(0x58);
	sig.append(0x88);
	sig.append(0xa);
	sig.append(0xfd);
	sig.append(0xba);
	sig.append(0x4);
	sig.append(0xc7);
	sig.append(0x5e);
	sig.append(0x37);
	sig.append(0x8d);
	sig.append(0xcc);
	sig.append(0xe0);
	sig.append(0xfd);
	sig.append(0x8c);
	sig.append(0xc);
	sig.append(0x70);
	sig.append(0x91);
	sig.append(0x42);
	sig.append(0x2e);
	sig.append(0x87);
	sig.append(0x7b);
	sig.append(0x88);
	sig.append(0xab);
	sig.append(0x53);
	sig.append(0xe);
	sig.append(0x8d);
	sig.append(0xab);
	sig.append(0xf7);
	sig.append(0xeb);
	sig.append(0xa2);
	sig.append(0xb4);
	sig.append(0x6e);
	sig.append(0xe7);
	sig.append(0xf8);
	sig.append(0xf1);
	sig.append(0x2e);
	sig.append(0xb6);
	sig.append(0x70);
	sig.append(0x29);
	sig.append(0x59);
	sig.append(0xda);
	sig.append(0xa1);
	sig.append(0x25);
	sig.append(0x23);
	sig.append(0x34);
	sig.append(0xe0);
	sig.append(0xbf);
	sig.append(0x64);
	sig.append(0xb);
	sig.append(0x64);
	sig.append(0x49);
	sig.append(0x35);
	sig.append(0xf);
	sig.append(0x49);
	sig.append(0xa9);
	sig.append(0x1c);
	sig.append(0x6);
	sig.append(0x48);
	sig.append(0x9d);
	sig.append(0xb);
	sig.append(0x4b);
	sig.append(0x8d);
	let pk = PublicKey {
		 x: 40404557795922279531706388389658272763545824328479674712290967728722509300078, 
		 y: 102805967889332383970486045966915951367386106276142748097619693594245369374210
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_17(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x52);
	hash.append(0x8c);
	hash.append(0x24);
	hash.append(0x3f);
	hash.append(0xdc);
	hash.append(0x85);
	hash.append(0x51);
	hash.append(0x87);
	hash.append(0xdf);
	hash.append(0x76);
	hash.append(0xd9);
	hash.append(0x23);
	hash.append(0xd5);
	hash.append(0x84);
	hash.append(0xaf);
	hash.append(0x2a);
	hash.append(0x40);
	hash.append(0xf4);
	hash.append(0x51);
	hash.append(0xd3);
	hash.append(0xcd);
	hash.append(0x18);
	hash.append(0x4a);
	hash.append(0xe4);
	hash.append(0xcc);
	hash.append(0x60);
	hash.append(0xf0);
	hash.append(0x98);
	hash.append(0xe0);
	hash.append(0xe8);
	hash.append(0xe2);
	hash.append(0x42);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x99);
	auth_data.append(0x3a);
	auth_data.append(0x6d);
	auth_data.append(0x22);
	auth_data.append(0xf4);
	auth_data.append(0xe5);
	auth_data.append(0x68);
	auth_data.append(0x77);
	auth_data.append(0x24);
	auth_data.append(0x68);
	auth_data.append(0xb8);
	auth_data.append(0x46);
	auth_data.append(0xdb);
	auth_data.append(0x79);
	auth_data.append(0xad);
	auth_data.append(0xa1);
	auth_data.append(0xf9);
	auth_data.append(0xab);
	auth_data.append(0xa7);
	auth_data.append(0xa6);
	auth_data.append(0xbc);
	auth_data.append(0xff);
	auth_data.append(0xef);
	auth_data.append(0xd3);
	auth_data.append(0xd1);
	auth_data.append(0xcd);
	auth_data.append(0x53);
	auth_data.append(0xa2);
	auth_data.append(0x8e);
	auth_data.append(0xdb);
	auth_data.append(0xa0);
	auth_data.append(0x1f);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x93);
	sig.append(0xf1);
	sig.append(0xbd);
	sig.append(0x2a);
	sig.append(0x5f);
	sig.append(0x27);
	sig.append(0xa7);
	sig.append(0xe4);
	sig.append(0xdf);
	sig.append(0xe5);
	sig.append(0x1b);
	sig.append(0x5f);
	sig.append(0x43);
	sig.append(0x5c);
	sig.append(0x55);
	sig.append(0xf6);
	sig.append(0x62);
	sig.append(0x7c);
	sig.append(0x23);
	sig.append(0x5e);
	sig.append(0x91);
	sig.append(0x65);
	sig.append(0x8c);
	sig.append(0x91);
	sig.append(0x46);
	sig.append(0x3a);
	sig.append(0x4);
	sig.append(0x2a);
	sig.append(0xd2);
	sig.append(0xb4);
	sig.append(0x60);
	sig.append(0xf5);
	sig.append(0xa9);
	sig.append(0x65);
	sig.append(0xa2);
	sig.append(0x8d);
	sig.append(0xe7);
	sig.append(0x89);
	sig.append(0xd3);
	sig.append(0xcc);
	sig.append(0xea);
	sig.append(0xfc);
	sig.append(0x20);
	sig.append(0x7a);
	sig.append(0xd5);
	sig.append(0x9f);
	sig.append(0x1d);
	sig.append(0xa8);
	sig.append(0x8e);
	sig.append(0x48);
	sig.append(0xf4);
	sig.append(0x2d);
	sig.append(0xce);
	sig.append(0x17);
	sig.append(0xe8);
	sig.append(0x2e);
	sig.append(0x57);
	sig.append(0x28);
	sig.append(0x61);
	sig.append(0xfb);
	sig.append(0x1e);
	sig.append(0x58);
	sig.append(0x9c);
	sig.append(0xc2);
	let pk = PublicKey {
		 x: 87810951359616706888736887583918536459373897372289328885478509243561528750212, 
		 y: 31765955140031239395025644115845890216797600253304599182528252539414661354235
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_18(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x88);
	hash.append(0x21);
	hash.append(0x1f);
	hash.append(0x78);
	hash.append(0xdb);
	hash.append(0xb3);
	hash.append(0xc0);
	hash.append(0x4d);
	hash.append(0x87);
	hash.append(0x58);
	hash.append(0xb8);
	hash.append(0xf9);
	hash.append(0xf);
	hash.append(0x1a);
	hash.append(0xee);
	hash.append(0xcd);
	hash.append(0x85);
	hash.append(0x4e);
	hash.append(0x7f);
	hash.append(0x3f);
	hash.append(0x66);
	hash.append(0x48);
	hash.append(0xdb);
	hash.append(0x26);
	hash.append(0x78);
	hash.append(0xee);
	hash.append(0xee);
	hash.append(0xb4);
	hash.append(0x67);
	hash.append(0xf1);
	hash.append(0xf2);
	hash.append(0x15);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x58);
	auth_data.append(0xc7);
	auth_data.append(0xfb);
	auth_data.append(0xda);
	auth_data.append(0x3d);
	auth_data.append(0xb0);
	auth_data.append(0x78);
	auth_data.append(0xf7);
	auth_data.append(0x13);
	auth_data.append(0xb);
	auth_data.append(0xce);
	auth_data.append(0x4);
	auth_data.append(0xd3);
	auth_data.append(0xda);
	auth_data.append(0x51);
	auth_data.append(0x6e);
	auth_data.append(0x76);
	auth_data.append(0x5);
	auth_data.append(0x8c);
	auth_data.append(0x1c);
	auth_data.append(0x76);
	auth_data.append(0x5a);
	auth_data.append(0x21);
	auth_data.append(0xbe);
	auth_data.append(0x89);
	auth_data.append(0x3c);
	auth_data.append(0x3);
	auth_data.append(0x94);
	auth_data.append(0xdf);
	auth_data.append(0x37);
	auth_data.append(0xee);
	auth_data.append(0x59);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xc1);
	sig.append(0xe6);
	sig.append(0xa4);
	sig.append(0xe9);
	sig.append(0x33);
	sig.append(0x18);
	sig.append(0x32);
	sig.append(0x88);
	sig.append(0xc);
	sig.append(0x1f);
	sig.append(0xf2);
	sig.append(0xa1);
	sig.append(0xfd);
	sig.append(0x6d);
	sig.append(0x22);
	sig.append(0x56);
	sig.append(0x1f);
	sig.append(0x3f);
	sig.append(0x6b);
	sig.append(0x78);
	sig.append(0x1a);
	sig.append(0x33);
	sig.append(0x89);
	sig.append(0x7d);
	sig.append(0xaa);
	sig.append(0x27);
	sig.append(0xc5);
	sig.append(0x9d);
	sig.append(0xfa);
	sig.append(0x38);
	sig.append(0x9a);
	sig.append(0x25);
	sig.append(0x71);
	sig.append(0x88);
	sig.append(0xf9);
	sig.append(0x3d);
	sig.append(0x82);
	sig.append(0xad);
	sig.append(0x2c);
	sig.append(0x93);
	sig.append(0x55);
	sig.append(0xc0);
	sig.append(0x70);
	sig.append(0xc7);
	sig.append(0xbb);
	sig.append(0x1a);
	sig.append(0x4d);
	sig.append(0x2a);
	sig.append(0xd1);
	sig.append(0x74);
	sig.append(0xad);
	sig.append(0x80);
	sig.append(0x91);
	sig.append(0x9e);
	sig.append(0xe6);
	sig.append(0x42);
	sig.append(0xa0);
	sig.append(0x13);
	sig.append(0x8);
	sig.append(0x0);
	sig.append(0x41);
	sig.append(0xa0);
	sig.append(0xcd);
	sig.append(0x94);
	let pk = PublicKey {
		 x: 78110350417148870955291640332993334008966744826522934613468133137666487284305, 
		 y: 44180077954418071191092209711472436528266715412579234510179959962586695418236
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_19(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x42);
	hash.append(0x4a);
	hash.append(0xf5);
	hash.append(0x8a);
	hash.append(0xc);
	hash.append(0x71);
	hash.append(0xc9);
	hash.append(0x85);
	hash.append(0xb2);
	hash.append(0xab);
	hash.append(0xfe);
	hash.append(0x90);
	hash.append(0x2c);
	hash.append(0x2d);
	hash.append(0x51);
	hash.append(0x2b);
	hash.append(0x86);
	hash.append(0x3d);
	hash.append(0xf9);
	hash.append(0xa);
	hash.append(0x8d);
	hash.append(0xb8);
	hash.append(0x72);
	hash.append(0xa5);
	hash.append(0x40);
	hash.append(0x29);
	hash.append(0xf9);
	hash.append(0x7d);
	hash.append(0xe2);
	hash.append(0x9d);
	hash.append(0x70);
	hash.append(0x20);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xcf);
	auth_data.append(0xe5);
	auth_data.append(0x6b);
	auth_data.append(0xcf);
	auth_data.append(0xbc);
	auth_data.append(0x2d);
	auth_data.append(0x87);
	auth_data.append(0x8);
	auth_data.append(0x63);
	auth_data.append(0x8c);
	auth_data.append(0x69);
	auth_data.append(0x16);
	auth_data.append(0xe4);
	auth_data.append(0xdb);
	auth_data.append(0x2a);
	auth_data.append(0x75);
	auth_data.append(0x36);
	auth_data.append(0x67);
	auth_data.append(0xd7);
	auth_data.append(0xea);
	auth_data.append(0x21);
	auth_data.append(0x9d);
	auth_data.append(0x92);
	auth_data.append(0xb2);
	auth_data.append(0x53);
	auth_data.append(0x47);
	auth_data.append(0x7c);
	auth_data.append(0x1e);
	auth_data.append(0x68);
	auth_data.append(0x75);
	auth_data.append(0xf3);
	auth_data.append(0x70);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x2d);
	sig.append(0x90);
	sig.append(0xd1);
	sig.append(0x15);
	sig.append(0x31);
	sig.append(0x47);
	sig.append(0x40);
	sig.append(0x14);
	sig.append(0x8b);
	sig.append(0xc);
	sig.append(0x7);
	sig.append(0xf9);
	sig.append(0x26);
	sig.append(0xf9);
	sig.append(0x9f);
	sig.append(0xe2);
	sig.append(0x8c);
	sig.append(0xab);
	sig.append(0x38);
	sig.append(0x6e);
	sig.append(0x24);
	sig.append(0xd0);
	sig.append(0x1d);
	sig.append(0xf4);
	sig.append(0x9a);
	sig.append(0xce);
	sig.append(0xe0);
	sig.append(0x1);
	sig.append(0xcc);
	sig.append(0x18);
	sig.append(0x6e);
	sig.append(0x6f);
	sig.append(0x41);
	sig.append(0xf7);
	sig.append(0x5f);
	sig.append(0x55);
	sig.append(0xb2);
	sig.append(0x51);
	sig.append(0x25);
	sig.append(0x19);
	sig.append(0xcb);
	sig.append(0x9c);
	sig.append(0x75);
	sig.append(0x60);
	sig.append(0x20);
	sig.append(0x28);
	sig.append(0x83);
	sig.append(0x32);
	sig.append(0xd);
	sig.append(0xca);
	sig.append(0x9c);
	sig.append(0x54);
	sig.append(0xba);
	sig.append(0xc0);
	sig.append(0x42);
	sig.append(0x4d);
	sig.append(0xef);
	sig.append(0x42);
	sig.append(0x2b);
	sig.append(0x1b);
	sig.append(0xc4);
	sig.append(0x40);
	sig.append(0xb9);
	sig.append(0x31);
	let pk = PublicKey {
		 x: 100637656087647602018429890657770596265831358610391792568791096860230175515326, 
		 y: 62820996993359341212467627545545322752702267990109313653880170281309452909808
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_20(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x9f);
	hash.append(0x96);
	hash.append(0xce);
	hash.append(0xfa);
	hash.append(0xfa);
	hash.append(0x1c);
	hash.append(0xda);
	hash.append(0xcb);
	hash.append(0xcb);
	hash.append(0x65);
	hash.append(0x61);
	hash.append(0x15);
	hash.append(0x84);
	hash.append(0x3a);
	hash.append(0x10);
	hash.append(0xea);
	hash.append(0xa);
	hash.append(0xd);
	hash.append(0x3);
	hash.append(0x59);
	hash.append(0x36);
	hash.append(0x2f);
	hash.append(0x99);
	hash.append(0x54);
	hash.append(0x13);
	hash.append(0xf2);
	hash.append(0xe3);
	hash.append(0x22);
	hash.append(0x4f);
	hash.append(0x4d);
	hash.append(0xe2);
	hash.append(0xea);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xa);
	auth_data.append(0x34);
	auth_data.append(0xbb);
	auth_data.append(0x9a);
	auth_data.append(0x77);
	auth_data.append(0x10);
	auth_data.append(0xc5);
	auth_data.append(0xc5);
	auth_data.append(0x57);
	auth_data.append(0x46);
	auth_data.append(0x59);
	auth_data.append(0x42);
	auth_data.append(0xef);
	auth_data.append(0x54);
	auth_data.append(0xe7);
	auth_data.append(0xe4);
	auth_data.append(0x76);
	auth_data.append(0xe);
	auth_data.append(0xd1);
	auth_data.append(0x6c);
	auth_data.append(0x70);
	auth_data.append(0xa9);
	auth_data.append(0x34);
	auth_data.append(0x60);
	auth_data.append(0xb9);
	auth_data.append(0x8b);
	auth_data.append(0xfc);
	auth_data.append(0x46);
	auth_data.append(0x19);
	auth_data.append(0xcb);
	auth_data.append(0x3a);
	auth_data.append(0x50);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xaf);
	sig.append(0x78);
	sig.append(0x8b);
	sig.append(0x8a);
	sig.append(0x1d);
	sig.append(0x95);
	sig.append(0x60);
	sig.append(0x27);
	sig.append(0x15);
	sig.append(0xca);
	sig.append(0xdb);
	sig.append(0x32);
	sig.append(0x70);
	sig.append(0x84);
	sig.append(0x98);
	sig.append(0x85);
	sig.append(0x17);
	sig.append(0x8d);
	sig.append(0x60);
	sig.append(0x13);
	sig.append(0x30);
	sig.append(0x55);
	sig.append(0xc2);
	sig.append(0x6c);
	sig.append(0xac);
	sig.append(0xe9);
	sig.append(0x63);
	sig.append(0x67);
	sig.append(0x79);
	sig.append(0xf0);
	sig.append(0x8b);
	sig.append(0x73);
	sig.append(0x76);
	sig.append(0x30);
	sig.append(0xe5);
	sig.append(0xb1);
	sig.append(0x3b);
	sig.append(0xe4);
	sig.append(0x6);
	sig.append(0xab);
	sig.append(0xf5);
	sig.append(0x15);
	sig.append(0x49);
	sig.append(0x5f);
	sig.append(0xc6);
	sig.append(0xcf);
	sig.append(0xae);
	sig.append(0x55);
	sig.append(0xd);
	sig.append(0xf9);
	sig.append(0x5);
	sig.append(0x27);
	sig.append(0xd);
	sig.append(0xf7);
	sig.append(0x89);
	sig.append(0x6a);
	sig.append(0x6d);
	sig.append(0x54);
	sig.append(0x5b);
	sig.append(0x28);
	sig.append(0x1b);
	sig.append(0x7f);
	sig.append(0x7d);
	sig.append(0x70);
	let pk = PublicKey {
		 x: 51375765930441293524349976982902169943400440932820623010493854995326859078450, 
		 y: 104393760726191972215931415951999366963742096979063314762142109396235646532246
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_21(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xf5);
	hash.append(0xf0);
	hash.append(0x29);
	hash.append(0x9b);
	hash.append(0x58);
	hash.append(0x7e);
	hash.append(0xab);
	hash.append(0x57);
	hash.append(0xd1);
	hash.append(0xe4);
	hash.append(0x66);
	hash.append(0x2f);
	hash.append(0x13);
	hash.append(0x63);
	hash.append(0x85);
	hash.append(0x4b);
	hash.append(0xf1);
	hash.append(0x34);
	hash.append(0x1b);
	hash.append(0x5b);
	hash.append(0x70);
	hash.append(0x30);
	hash.append(0xe2);
	hash.append(0xcd);
	hash.append(0x1);
	hash.append(0xb0);
	hash.append(0x97);
	hash.append(0x40);
	hash.append(0x2c);
	hash.append(0xdd);
	hash.append(0xb);
	hash.append(0x2b);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xa1);
	auth_data.append(0xa2);
	auth_data.append(0xf5);
	auth_data.append(0xb2);
	auth_data.append(0xe6);
	auth_data.append(0x26);
	auth_data.append(0x78);
	auth_data.append(0x4f);
	auth_data.append(0xb8);
	auth_data.append(0xa8);
	auth_data.append(0x90);
	auth_data.append(0xf4);
	auth_data.append(0x64);
	auth_data.append(0xb6);
	auth_data.append(0x51);
	auth_data.append(0x4d);
	auth_data.append(0xf9);
	auth_data.append(0x1e);
	auth_data.append(0x78);
	auth_data.append(0xb9);
	auth_data.append(0xa0);
	auth_data.append(0xc);
	auth_data.append(0x7c);
	auth_data.append(0xd2);
	auth_data.append(0xfd);
	auth_data.append(0x62);
	auth_data.append(0xb4);
	auth_data.append(0x35);
	auth_data.append(0x9b);
	auth_data.append(0x1a);
	auth_data.append(0x5f);
	auth_data.append(0xb4);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x9b);
	sig.append(0x2e);
	sig.append(0x3f);
	sig.append(0xa2);
	sig.append(0xe8);
	sig.append(0xb3);
	sig.append(0xa3);
	sig.append(0x12);
	sig.append(0xd6);
	sig.append(0x44);
	sig.append(0x2c);
	sig.append(0x4f);
	sig.append(0xc5);
	sig.append(0x8);
	sig.append(0x10);
	sig.append(0xd4);
	sig.append(0x8e);
	sig.append(0x18);
	sig.append(0xab);
	sig.append(0x16);
	sig.append(0xe7);
	sig.append(0xf2);
	sig.append(0x55);
	sig.append(0xdb);
	sig.append(0x9e);
	sig.append(0xc7);
	sig.append(0x8c);
	sig.append(0x7);
	sig.append(0x16);
	sig.append(0x6e);
	sig.append(0x24);
	sig.append(0xd5);
	sig.append(0xa9);
	sig.append(0x28);
	sig.append(0x54);
	sig.append(0xaa);
	sig.append(0xf7);
	sig.append(0x64);
	sig.append(0xb6);
	sig.append(0xc7);
	sig.append(0x1d);
	sig.append(0xb6);
	sig.append(0x20);
	sig.append(0x65);
	sig.append(0x36);
	sig.append(0x79);
	sig.append(0xfd);
	sig.append(0x9b);
	sig.append(0x45);
	sig.append(0xbe);
	sig.append(0xb5);
	sig.append(0x91);
	sig.append(0x85);
	sig.append(0xe9);
	sig.append(0xd5);
	sig.append(0x1d);
	sig.append(0x3);
	sig.append(0xb);
	sig.append(0x1);
	sig.append(0xdd);
	sig.append(0x28);
	sig.append(0xc3);
	sig.append(0xc6);
	sig.append(0xa9);
	let pk = PublicKey {
		 x: 113168663807446987852490998530915941602007453839584731032333369429604345592542, 
		 y: 102329984678374252665941690500307425617574984644598251742890714750535523116717
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_22(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x56);
	hash.append(0x64);
	hash.append(0xaf);
	hash.append(0xdb);
	hash.append(0x9);
	hash.append(0x9b);
	hash.append(0x93);
	hash.append(0x7b);
	hash.append(0x87);
	hash.append(0xff);
	hash.append(0x8f);
	hash.append(0xec);
	hash.append(0xfe);
	hash.append(0x96);
	hash.append(0x5c);
	hash.append(0xa0);
	hash.append(0xd2);
	hash.append(0x11);
	hash.append(0xfc);
	hash.append(0x21);
	hash.append(0x60);
	hash.append(0x7d);
	hash.append(0xb0);
	hash.append(0xdd);
	hash.append(0xd5);
	hash.append(0xd6);
	hash.append(0x1);
	hash.append(0x89);
	hash.append(0xcc);
	hash.append(0x4c);
	hash.append(0x9b);
	hash.append(0x96);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x68);
	auth_data.append(0xea);
	auth_data.append(0x15);
	auth_data.append(0xbd);
	auth_data.append(0x6);
	auth_data.append(0x9);
	auth_data.append(0x55);
	auth_data.append(0x6b);
	auth_data.append(0x8a);
	auth_data.append(0x39);
	auth_data.append(0xdd);
	auth_data.append(0xcc);
	auth_data.append(0x7f);
	auth_data.append(0x65);
	auth_data.append(0x7c);
	auth_data.append(0x21);
	auth_data.append(0xd8);
	auth_data.append(0xd4);
	auth_data.append(0x15);
	auth_data.append(0x38);
	auth_data.append(0x75);
	auth_data.append(0x41);
	auth_data.append(0xf0);
	auth_data.append(0x54);
	auth_data.append(0x55);
	auth_data.append(0xe0);
	auth_data.append(0x6f);
	auth_data.append(0xa7);
	auth_data.append(0x7c);
	auth_data.append(0x41);
	auth_data.append(0xdf);
	auth_data.append(0x40);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x0);
	sig.append(0x8e);
	sig.append(0xb0);
	sig.append(0x5);
	sig.append(0xaf);
	sig.append(0x60);
	sig.append(0xe5);
	sig.append(0x83);
	sig.append(0xfa);
	sig.append(0xab);
	sig.append(0x8b);
	sig.append(0xc5);
	sig.append(0xc7);
	sig.append(0xc6);
	sig.append(0x56);
	sig.append(0x61);
	sig.append(0xaa);
	sig.append(0x46);
	sig.append(0x5c);
	sig.append(0xf3);
	sig.append(0x5);
	sig.append(0x6d);
	sig.append(0x8c);
	sig.append(0x13);
	sig.append(0x29);
	sig.append(0xf2);
	sig.append(0x1e);
	sig.append(0xf);
	sig.append(0x7c);
	sig.append(0x7f);
	sig.append(0x11);
	sig.append(0x25);
	sig.append(0x5f);
	sig.append(0x33);
	sig.append(0xf2);
	sig.append(0x1);
	sig.append(0x95);
	sig.append(0x6);
	sig.append(0x12);
	sig.append(0x97);
	sig.append(0x2d);
	sig.append(0x64);
	sig.append(0xa8);
	sig.append(0xea);
	sig.append(0xd8);
	sig.append(0xb1);
	sig.append(0x40);
	sig.append(0xa2);
	sig.append(0xac);
	sig.append(0x4f);
	sig.append(0xfd);
	sig.append(0x8a);
	sig.append(0x27);
	sig.append(0x6c);
	sig.append(0x60);
	sig.append(0x8);
	sig.append(0xd9);
	sig.append(0x9c);
	sig.append(0x5d);
	sig.append(0xd2);
	sig.append(0xcd);
	sig.append(0x29);
	sig.append(0xc4);
	sig.append(0xfd);
	let pk = PublicKey {
		 x: 15296883494872997537912550745632148894340968922884502433934134127328263852260, 
		 y: 8935849863995950788299364563333127046847952701921742402069234733681084240413
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_23(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xbb);
	hash.append(0xb7);
	hash.append(0x85);
	hash.append(0x1d);
	hash.append(0x8d);
	hash.append(0xa5);
	hash.append(0x65);
	hash.append(0xe2);
	hash.append(0xa2);
	hash.append(0xac);
	hash.append(0xb7);
	hash.append(0x7a);
	hash.append(0x76);
	hash.append(0x76);
	hash.append(0x53);
	hash.append(0xd);
	hash.append(0x6);
	hash.append(0x8c);
	hash.append(0x9e);
	hash.append(0x92);
	hash.append(0x69);
	hash.append(0x2f);
	hash.append(0xa);
	hash.append(0xb6);
	hash.append(0x82);
	hash.append(0xac);
	hash.append(0xb5);
	hash.append(0x2b);
	hash.append(0x59);
	hash.append(0x32);
	hash.append(0xdb);
	hash.append(0x13);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x87);
	auth_data.append(0xbe);
	auth_data.append(0x32);
	auth_data.append(0x81);
	auth_data.append(0xa0);
	auth_data.append(0xd);
	auth_data.append(0xd5);
	auth_data.append(0x22);
	auth_data.append(0x65);
	auth_data.append(0xcb);
	auth_data.append(0x15);
	auth_data.append(0x91);
	auth_data.append(0xfe);
	auth_data.append(0x48);
	auth_data.append(0x32);
	auth_data.append(0xee);
	auth_data.append(0x33);
	auth_data.append(0xe0);
	auth_data.append(0x99);
	auth_data.append(0xca);
	auth_data.append(0xc6);
	auth_data.append(0x82);
	auth_data.append(0x70);
	auth_data.append(0x11);
	auth_data.append(0xc7);
	auth_data.append(0x9);
	auth_data.append(0x76);
	auth_data.append(0x1b);
	auth_data.append(0x33);
	auth_data.append(0x62);
	auth_data.append(0x1);
	auth_data.append(0x11);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xf7);
	sig.append(0x4f);
	sig.append(0x14);
	sig.append(0x14);
	sig.append(0x11);
	sig.append(0x60);
	sig.append(0x42);
	sig.append(0xbf);
	sig.append(0xc0);
	sig.append(0xb1);
	sig.append(0xf0);
	sig.append(0xb9);
	sig.append(0x89);
	sig.append(0x3e);
	sig.append(0xca);
	sig.append(0x38);
	sig.append(0x3d);
	sig.append(0x65);
	sig.append(0x6e);
	sig.append(0xcc);
	sig.append(0x19);
	sig.append(0x27);
	sig.append(0x98);
	sig.append(0x4d);
	sig.append(0xb8);
	sig.append(0xaa);
	sig.append(0x1f);
	sig.append(0xfe);
	sig.append(0x4);
	sig.append(0xf0);
	sig.append(0x88);
	sig.append(0x10);
	sig.append(0x47);
	sig.append(0x8);
	sig.append(0x35);
	sig.append(0x3e);
	sig.append(0xe4);
	sig.append(0xbc);
	sig.append(0xcf);
	sig.append(0xb5);
	sig.append(0x90);
	sig.append(0x2a);
	sig.append(0xfe);
	sig.append(0x6a);
	sig.append(0xe);
	sig.append(0x5a);
	sig.append(0x25);
	sig.append(0x4a);
	sig.append(0xff);
	sig.append(0x8c);
	sig.append(0xf7);
	sig.append(0xa0);
	sig.append(0x28);
	sig.append(0x28);
	sig.append(0xbe);
	sig.append(0x79);
	sig.append(0x10);
	sig.append(0xcf);
	sig.append(0x44);
	sig.append(0x81);
	sig.append(0x27);
	sig.append(0x4);
	sig.append(0x94);
	sig.append(0xdd);
	let pk = PublicKey {
		 x: 17793852691865837586871210763624090384691323226761271046954309580779657495303, 
		 y: 67928102020959559710002839549854426912457593700232758107308787734176162842593
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_24(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xd1);
	hash.append(0x99);
	hash.append(0xe9);
	hash.append(0x6a);
	hash.append(0xa3);
	hash.append(0xf2);
	hash.append(0xf6);
	hash.append(0x4a);
	hash.append(0x2a);
	hash.append(0x85);
	hash.append(0x76);
	hash.append(0x4e);
	hash.append(0xb8);
	hash.append(0xf3);
	hash.append(0x3);
	hash.append(0x50);
	hash.append(0x89);
	hash.append(0x6d);
	hash.append(0x35);
	hash.append(0x20);
	hash.append(0x32);
	hash.append(0xdc);
	hash.append(0xba);
	hash.append(0xb4);
	hash.append(0xdc);
	hash.append(0x6f);
	hash.append(0x78);
	hash.append(0xc0);
	hash.append(0x3a);
	hash.append(0x94);
	hash.append(0xf1);
	hash.append(0x8d);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x88);
	auth_data.append(0xc0);
	auth_data.append(0x11);
	auth_data.append(0x31);
	auth_data.append(0xbd);
	auth_data.append(0xd8);
	auth_data.append(0x1e);
	auth_data.append(0x94);
	auth_data.append(0x10);
	auth_data.append(0x58);
	auth_data.append(0xc9);
	auth_data.append(0x8a);
	auth_data.append(0x64);
	auth_data.append(0x59);
	auth_data.append(0xb2);
	auth_data.append(0xb3);
	auth_data.append(0xc4);
	auth_data.append(0xe9);
	auth_data.append(0xed);
	auth_data.append(0x86);
	auth_data.append(0xa9);
	auth_data.append(0x39);
	auth_data.append(0xad);
	auth_data.append(0x80);
	auth_data.append(0xcf);
	auth_data.append(0xbd);
	auth_data.append(0x70);
	auth_data.append(0x4f);
	auth_data.append(0x6f);
	auth_data.append(0x8f);
	auth_data.append(0xa6);
	auth_data.append(0x2f);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x94);
	sig.append(0x97);
	sig.append(0x7f);
	sig.append(0xa3);
	sig.append(0x6d);
	sig.append(0x14);
	sig.append(0x79);
	sig.append(0xad);
	sig.append(0x16);
	sig.append(0x17);
	sig.append(0x59);
	sig.append(0x60);
	sig.append(0x37);
	sig.append(0xac);
	sig.append(0x15);
	sig.append(0x7f);
	sig.append(0x57);
	sig.append(0x76);
	sig.append(0x53);
	sig.append(0x34);
	sig.append(0x3e);
	sig.append(0xf5);
	sig.append(0xf5);
	sig.append(0x6c);
	sig.append(0x6a);
	sig.append(0x7b);
	sig.append(0x79);
	sig.append(0x79);
	sig.append(0x10);
	sig.append(0x98);
	sig.append(0xce);
	sig.append(0x8f);
	sig.append(0x7e);
	sig.append(0x5c);
	sig.append(0xfd);
	sig.append(0xd7);
	sig.append(0xde);
	sig.append(0x31);
	sig.append(0xf7);
	sig.append(0x29);
	sig.append(0xb1);
	sig.append(0x7);
	sig.append(0x3);
	sig.append(0x85);
	sig.append(0x40);
	sig.append(0x6);
	sig.append(0x26);
	sig.append(0xc5);
	sig.append(0x14);
	sig.append(0x45);
	sig.append(0xff);
	sig.append(0x20);
	sig.append(0xf5);
	sig.append(0x33);
	sig.append(0x2f);
	sig.append(0x72);
	sig.append(0x1c);
	sig.append(0x89);
	sig.append(0x99);
	sig.append(0xf2);
	sig.append(0x92);
	sig.append(0xf);
	sig.append(0x65);
	sig.append(0x8);
	let pk = PublicKey {
		 x: 8020363552490509439218706659490590711334767313020910609041228510344739373447, 
		 y: 22832298770255221650701801855698558835401450750784792608975400113262501169199
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_25(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x7b);
	hash.append(0x66);
	hash.append(0x31);
	hash.append(0x86);
	hash.append(0xbb);
	hash.append(0x86);
	hash.append(0x3c);
	hash.append(0x17);
	hash.append(0x4a);
	hash.append(0xed);
	hash.append(0x11);
	hash.append(0xa5);
	hash.append(0xf4);
	hash.append(0x3c);
	hash.append(0x5);
	hash.append(0xa2);
	hash.append(0xa8);
	hash.append(0x34);
	hash.append(0x89);
	hash.append(0x8f);
	hash.append(0x1d);
	hash.append(0xe6);
	hash.append(0x66);
	hash.append(0xe1);
	hash.append(0xdd);
	hash.append(0xfc);
	hash.append(0xb8);
	hash.append(0xc2);
	hash.append(0x49);
	hash.append(0x31);
	hash.append(0x5);
	hash.append(0x4);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x9e);
	auth_data.append(0xdf);
	auth_data.append(0xaa);
	auth_data.append(0xbb);
	auth_data.append(0xb0);
	auth_data.append(0x18);
	auth_data.append(0xfc);
	auth_data.append(0x92);
	auth_data.append(0x24);
	auth_data.append(0x8f);
	auth_data.append(0xd1);
	auth_data.append(0x27);
	auth_data.append(0x9);
	auth_data.append(0x4e);
	auth_data.append(0x47);
	auth_data.append(0x76);
	auth_data.append(0x27);
	auth_data.append(0xfd);
	auth_data.append(0x5c);
	auth_data.append(0x4b);
	auth_data.append(0x55);
	auth_data.append(0x6b);
	auth_data.append(0xd1);
	auth_data.append(0xa0);
	auth_data.append(0x44);
	auth_data.append(0xec);
	auth_data.append(0x2b);
	auth_data.append(0x5d);
	auth_data.append(0x1b);
	auth_data.append(0x28);
	auth_data.append(0xd0);
	auth_data.append(0xa3);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xa4);
	sig.append(0x32);
	sig.append(0xf2);
	sig.append(0xc1);
	sig.append(0xa1);
	sig.append(0xb1);
	sig.append(0xa5);
	sig.append(0x32);
	sig.append(0x1a);
	sig.append(0x2a);
	sig.append(0x50);
	sig.append(0xed);
	sig.append(0x20);
	sig.append(0xbe);
	sig.append(0x7);
	sig.append(0x98);
	sig.append(0xea);
	sig.append(0x9);
	sig.append(0xed);
	sig.append(0xe);
	sig.append(0x7e);
	sig.append(0x1);
	sig.append(0x18);
	sig.append(0xfc);
	sig.append(0xfa);
	sig.append(0xe3);
	sig.append(0xe3);
	sig.append(0x23);
	sig.append(0x5f);
	sig.append(0x4);
	sig.append(0x9f);
	sig.append(0xb4);
	sig.append(0x57);
	sig.append(0xd4);
	sig.append(0xe6);
	sig.append(0x8f);
	sig.append(0xf7);
	sig.append(0x7f);
	sig.append(0xe3);
	sig.append(0x26);
	sig.append(0x3f);
	sig.append(0x7c);
	sig.append(0xd7);
	sig.append(0xc5);
	sig.append(0x5);
	sig.append(0x10);
	sig.append(0xcf);
	sig.append(0x91);
	sig.append(0x76);
	sig.append(0xba);
	sig.append(0xac);
	sig.append(0x31);
	sig.append(0x5a);
	sig.append(0xcf);
	sig.append(0x63);
	sig.append(0x23);
	sig.append(0xaa);
	sig.append(0xf3);
	sig.append(0xc5);
	sig.append(0x6);
	sig.append(0xd7);
	sig.append(0x7f);
	sig.append(0x56);
	sig.append(0x4e);
	let pk = PublicKey {
		 x: 77255048392355577369282096863182025758095677765076164910669482708139485527645, 
		 y: 106608035321749398624542082745948405411101078158367798818558366899335865871934
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_26(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x88);
	hash.append(0x41);
	hash.append(0x80);
	hash.append(0x91);
	hash.append(0x87);
	hash.append(0x8a);
	hash.append(0x3d);
	hash.append(0xab);
	hash.append(0x75);
	hash.append(0x5a);
	hash.append(0x75);
	hash.append(0x31);
	hash.append(0xd2);
	hash.append(0x5b);
	hash.append(0xaa);
	hash.append(0xcc);
	hash.append(0xe8);
	hash.append(0x48);
	hash.append(0xb2);
	hash.append(0x7a);
	hash.append(0x29);
	hash.append(0x70);
	hash.append(0xe1);
	hash.append(0x33);
	hash.append(0xcf);
	hash.append(0xf3);
	hash.append(0xe2);
	hash.append(0x23);
	hash.append(0x61);
	hash.append(0x43);
	hash.append(0xa9);
	hash.append(0x9c);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x60);
	auth_data.append(0x9);
	auth_data.append(0x94);
	auth_data.append(0x34);
	auth_data.append(0xf9);
	auth_data.append(0xcc);
	auth_data.append(0x9d);
	auth_data.append(0xff);
	auth_data.append(0x60);
	auth_data.append(0xb);
	auth_data.append(0x6e);
	auth_data.append(0xa9);
	auth_data.append(0x38);
	auth_data.append(0x40);
	auth_data.append(0xbb);
	auth_data.append(0xe);
	auth_data.append(0x4e);
	auth_data.append(0x77);
	auth_data.append(0xdd);
	auth_data.append(0x84);
	auth_data.append(0x6e);
	auth_data.append(0xc2);
	auth_data.append(0x10);
	auth_data.append(0x1d);
	auth_data.append(0x63);
	auth_data.append(0x6c);
	auth_data.append(0xba);
	auth_data.append(0xe1);
	auth_data.append(0xa5);
	auth_data.append(0x9f);
	auth_data.append(0xc);
	auth_data.append(0x37);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x8a);
	sig.append(0xba);
	sig.append(0x49);
	sig.append(0xd7);
	sig.append(0xf);
	sig.append(0xc6);
	sig.append(0x73);
	sig.append(0x16);
	sig.append(0x42);
	sig.append(0xa4);
	sig.append(0x40);
	sig.append(0x34);
	sig.append(0x57);
	sig.append(0x2d);
	sig.append(0xe2);
	sig.append(0xdd);
	sig.append(0xf2);
	sig.append(0x9d);
	sig.append(0xa5);
	sig.append(0x54);
	sig.append(0x63);
	sig.append(0xaf);
	sig.append(0x49);
	sig.append(0x23);
	sig.append(0x27);
	sig.append(0x81);
	sig.append(0x5a);
	sig.append(0xe2);
	sig.append(0xd6);
	sig.append(0xe9);
	sig.append(0x47);
	sig.append(0x3d);
	sig.append(0xae);
	sig.append(0xd7);
	sig.append(0x7b);
	sig.append(0x51);
	sig.append(0xd);
	sig.append(0xed);
	sig.append(0x21);
	sig.append(0x99);
	sig.append(0xce);
	sig.append(0xe0);
	sig.append(0xc);
	sig.append(0xa0);
	sig.append(0xbd);
	sig.append(0x5b);
	sig.append(0xd6);
	sig.append(0x9b);
	sig.append(0x42);
	sig.append(0xbb);
	sig.append(0xf7);
	sig.append(0x0);
	sig.append(0xb2);
	sig.append(0x18);
	sig.append(0xde);
	sig.append(0x94);
	sig.append(0xde);
	sig.append(0x8d);
	sig.append(0x6e);
	sig.append(0x5f);
	sig.append(0x72);
	sig.append(0xc);
	sig.append(0x8);
	sig.append(0x58);
	let pk = PublicKey {
		 x: 54590150438916936866376920902094738624519605264189825025368320666691287039641, 
		 y: 76431553680436388886382927969052425859293227610160200787983215954015486521478
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_27(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x19);
	hash.append(0x69);
	hash.append(0xda);
	hash.append(0xe);
	hash.append(0xaf);
	hash.append(0xd9);
	hash.append(0x68);
	hash.append(0xa5);
	hash.append(0x75);
	hash.append(0x18);
	hash.append(0x50);
	hash.append(0xa5);
	hash.append(0x4d);
	hash.append(0xe8);
	hash.append(0xf7);
	hash.append(0x8f);
	hash.append(0x3f);
	hash.append(0xcc);
	hash.append(0xdb);
	hash.append(0xfe);
	hash.append(0x3a);
	hash.append(0x3a);
	hash.append(0x7);
	hash.append(0xa6);
	hash.append(0xfc);
	hash.append(0xed);
	hash.append(0x1f);
	hash.append(0x40);
	hash.append(0x31);
	hash.append(0x3f);
	hash.append(0x52);
	hash.append(0xc1);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x90);
	auth_data.append(0xc9);
	auth_data.append(0xac);
	auth_data.append(0xd6);
	auth_data.append(0x17);
	auth_data.append(0xdd);
	auth_data.append(0xe3);
	auth_data.append(0x20);
	auth_data.append(0xba);
	auth_data.append(0x59);
	auth_data.append(0x7a);
	auth_data.append(0x45);
	auth_data.append(0xc9);
	auth_data.append(0xf1);
	auth_data.append(0x39);
	auth_data.append(0x37);
	auth_data.append(0x8e);
	auth_data.append(0x1e);
	auth_data.append(0xcf);
	auth_data.append(0x24);
	auth_data.append(0xdf);
	auth_data.append(0xa6);
	auth_data.append(0x27);
	auth_data.append(0x83);
	auth_data.append(0x77);
	auth_data.append(0x50);
	auth_data.append(0xde);
	auth_data.append(0xe0);
	auth_data.append(0xdb);
	auth_data.append(0x81);
	auth_data.append(0x7a);
	auth_data.append(0x48);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x9e);
	sig.append(0xb8);
	sig.append(0xa3);
	sig.append(0x35);
	sig.append(0x7e);
	sig.append(0x31);
	sig.append(0xdc);
	sig.append(0x2e);
	sig.append(0xc6);
	sig.append(0x92);
	sig.append(0x58);
	sig.append(0x77);
	sig.append(0x8c);
	sig.append(0x5e);
	sig.append(0x7);
	sig.append(0xf9);
	sig.append(0x6a);
	sig.append(0x92);
	sig.append(0xcd);
	sig.append(0x3e);
	sig.append(0xfb);
	sig.append(0x53);
	sig.append(0x52);
	sig.append(0x8f);
	sig.append(0x77);
	sig.append(0x57);
	sig.append(0xe0);
	sig.append(0xa5);
	sig.append(0xdd);
	sig.append(0x33);
	sig.append(0xba);
	sig.append(0x5c);
	sig.append(0x8);
	sig.append(0x50);
	sig.append(0xc1);
	sig.append(0x7f);
	sig.append(0x3b);
	sig.append(0xb2);
	sig.append(0x20);
	sig.append(0x7);
	sig.append(0x49);
	sig.append(0x2);
	sig.append(0xea);
	sig.append(0x67);
	sig.append(0x0);
	sig.append(0x9c);
	sig.append(0x11);
	sig.append(0x1);
	sig.append(0xb5);
	sig.append(0xd2);
	sig.append(0x55);
	sig.append(0x31);
	sig.append(0xcd);
	sig.append(0xd8);
	sig.append(0xd4);
	sig.append(0x1e);
	sig.append(0xc3);
	sig.append(0xa6);
	sig.append(0xaa);
	sig.append(0x6a);
	sig.append(0xe8);
	sig.append(0xeb);
	sig.append(0x40);
	sig.append(0xc0);
	let pk = PublicKey {
		 x: 6675465514385030089465382616806466309120045998524661929012759556606534327854, 
		 y: 10237437591198587168721273797604710068436239732419303028143710276360954482515
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_28(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x17);
	hash.append(0x30);
	hash.append(0xe5);
	hash.append(0x76);
	hash.append(0x14);
	hash.append(0x44);
	hash.append(0x77);
	hash.append(0x2a);
	hash.append(0x6b);
	hash.append(0x50);
	hash.append(0xbc);
	hash.append(0x27);
	hash.append(0x23);
	hash.append(0x49);
	hash.append(0x4d);
	hash.append(0xb6);
	hash.append(0x35);
	hash.append(0x3d);
	hash.append(0x8a);
	hash.append(0xb1);
	hash.append(0x1b);
	hash.append(0x57);
	hash.append(0x20);
	hash.append(0x54);
	hash.append(0x8);
	hash.append(0x98);
	hash.append(0xdf);
	hash.append(0xa6);
	hash.append(0x5b);
	hash.append(0x50);
	hash.append(0xd0);
	hash.append(0x6a);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x1);
	auth_data.append(0x89);
	auth_data.append(0x43);
	auth_data.append(0x3c);
	auth_data.append(0x3e);
	auth_data.append(0x4b);
	auth_data.append(0x75);
	auth_data.append(0x5);
	auth_data.append(0x6b);
	auth_data.append(0x86);
	auth_data.append(0xb5);
	auth_data.append(0xff);
	auth_data.append(0x49);
	auth_data.append(0xa0);
	auth_data.append(0x84);
	auth_data.append(0x4c);
	auth_data.append(0xa3);
	auth_data.append(0xb5);
	auth_data.append(0xf0);
	auth_data.append(0x42);
	auth_data.append(0x23);
	auth_data.append(0x23);
	auth_data.append(0x6f);
	auth_data.append(0x84);
	auth_data.append(0xcd);
	auth_data.append(0xd4);
	auth_data.append(0x5f);
	auth_data.append(0xb2);
	auth_data.append(0xf6);
	auth_data.append(0x72);
	auth_data.append(0x49);
	auth_data.append(0x58);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x68);
	sig.append(0xf6);
	sig.append(0x5f);
	sig.append(0x89);
	sig.append(0x4e);
	sig.append(0xba);
	sig.append(0xd7);
	sig.append(0xa1);
	sig.append(0x13);
	sig.append(0x7f);
	sig.append(0x56);
	sig.append(0x8f);
	sig.append(0xbd);
	sig.append(0x4c);
	sig.append(0xa8);
	sig.append(0x72);
	sig.append(0xf6);
	sig.append(0xce);
	sig.append(0x94);
	sig.append(0xca);
	sig.append(0x53);
	sig.append(0x29);
	sig.append(0x9a);
	sig.append(0x31);
	sig.append(0x25);
	sig.append(0x83);
	sig.append(0xcd);
	sig.append(0x75);
	sig.append(0x46);
	sig.append(0xa6);
	sig.append(0xa0);
	sig.append(0x0);
	sig.append(0xa);
	sig.append(0xb);
	sig.append(0x1a);
	sig.append(0x26);
	sig.append(0x6f);
	sig.append(0x60);
	sig.append(0xd3);
	sig.append(0x58);
	sig.append(0x24);
	sig.append(0x57);
	sig.append(0x10);
	sig.append(0x7f);
	sig.append(0x75);
	sig.append(0x5d);
	sig.append(0xba);
	sig.append(0xb9);
	sig.append(0x23);
	sig.append(0xd3);
	sig.append(0x4b);
	sig.append(0x91);
	sig.append(0x50);
	sig.append(0x3e);
	sig.append(0x8e);
	sig.append(0x0);
	sig.append(0x87);
	sig.append(0xfe);
	sig.append(0xe3);
	sig.append(0x18);
	sig.append(0xf9);
	sig.append(0xd9);
	sig.append(0x9c);
	sig.append(0xd5);
	let pk = PublicKey {
		 x: 91363397799673547904101681317555396182415190028545496350671843086674827400633, 
		 y: 26380517836232576979800510083122014512840702262586661976550355032529529004452
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_29(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xb5);
	hash.append(0x6b);
	hash.append(0x96);
	hash.append(0x9f);
	hash.append(0xd2);
	hash.append(0x53);
	hash.append(0xe6);
	hash.append(0xca);
	hash.append(0x5f);
	hash.append(0x96);
	hash.append(0x92);
	hash.append(0x80);
	hash.append(0xad);
	hash.append(0x4d);
	hash.append(0x22);
	hash.append(0x7d);
	hash.append(0xee);
	hash.append(0xa2);
	hash.append(0xb3);
	hash.append(0x59);
	hash.append(0x5b);
	hash.append(0xcc);
	hash.append(0xe2);
	hash.append(0x8a);
	hash.append(0x25);
	hash.append(0xd3);
	hash.append(0x14);
	hash.append(0x99);
	hash.append(0x60);
	hash.append(0xf9);
	hash.append(0xa9);
	hash.append(0xa1);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xfc);
	auth_data.append(0xfa);
	auth_data.append(0xab);
	auth_data.append(0xb);
	auth_data.append(0x5e);
	auth_data.append(0x82);
	auth_data.append(0x34);
	auth_data.append(0x21);
	auth_data.append(0xf9);
	auth_data.append(0xda);
	auth_data.append(0xcf);
	auth_data.append(0xdf);
	auth_data.append(0xf6);
	auth_data.append(0x6b);
	auth_data.append(0x7a);
	auth_data.append(0x8);
	auth_data.append(0x7b);
	auth_data.append(0x4);
	auth_data.append(0x1a);
	auth_data.append(0x53);
	auth_data.append(0x9b);
	auth_data.append(0xb0);
	auth_data.append(0xb9);
	auth_data.append(0x4c);
	auth_data.append(0x25);
	auth_data.append(0x7b);
	auth_data.append(0xc5);
	auth_data.append(0xa3);
	auth_data.append(0xcd);
	auth_data.append(0xe5);
	auth_data.append(0x53);
	auth_data.append(0x5);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xf7);
	sig.append(0xfa);
	sig.append(0x42);
	sig.append(0xaf);
	sig.append(0x43);
	sig.append(0xb8);
	sig.append(0x59);
	sig.append(0x69);
	sig.append(0xcb);
	sig.append(0x41);
	sig.append(0xcf);
	sig.append(0x9b);
	sig.append(0x1c);
	sig.append(0x30);
	sig.append(0x6f);
	sig.append(0x8d);
	sig.append(0x1d);
	sig.append(0x7f);
	sig.append(0x76);
	sig.append(0x2);
	sig.append(0x4d);
	sig.append(0x33);
	sig.append(0x68);
	sig.append(0xff);
	sig.append(0xf);
	sig.append(0x86);
	sig.append(0x99);
	sig.append(0x7c);
	sig.append(0x98);
	sig.append(0xa7);
	sig.append(0x11);
	sig.append(0x53);
	sig.append(0xed);
	sig.append(0x7c);
	sig.append(0x2);
	sig.append(0xad);
	sig.append(0xc0);
	sig.append(0xa8);
	sig.append(0xa0);
	sig.append(0x6e);
	sig.append(0x5c);
	sig.append(0x8b);
	sig.append(0xde);
	sig.append(0xec);
	sig.append(0xe2);
	sig.append(0x1d);
	sig.append(0xfe);
	sig.append(0xe1);
	sig.append(0xd9);
	sig.append(0xcf);
	sig.append(0x3d);
	sig.append(0x57);
	sig.append(0xc6);
	sig.append(0xe0);
	sig.append(0x37);
	sig.append(0x74);
	sig.append(0xd1);
	sig.append(0xd);
	sig.append(0xa1);
	sig.append(0xb7);
	sig.append(0xc3);
	sig.append(0xd6);
	sig.append(0x1c);
	sig.append(0x48);
	let pk = PublicKey {
		 x: 91404900775037555652457889101094039463769928731547148946597312320824168471175, 
		 y: 9437739581471825599896388390993812736126365190749474328049261810070336274384
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_30(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x74);
	hash.append(0xd6);
	hash.append(0xf2);
	hash.append(0x97);
	hash.append(0xde);
	hash.append(0x5f);
	hash.append(0x67);
	hash.append(0xd5);
	hash.append(0x8b);
	hash.append(0x28);
	hash.append(0x5b);
	hash.append(0xa7);
	hash.append(0xdc);
	hash.append(0x13);
	hash.append(0x7b);
	hash.append(0xba);
	hash.append(0x7f);
	hash.append(0x4e);
	hash.append(0x17);
	hash.append(0x33);
	hash.append(0xea);
	hash.append(0x9e);
	hash.append(0x4e);
	hash.append(0x6a);
	hash.append(0x9c);
	hash.append(0xe4);
	hash.append(0x60);
	hash.append(0x19);
	hash.append(0xf9);
	hash.append(0xb0);
	hash.append(0xa5);
	hash.append(0x28);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xd7);
	auth_data.append(0x8d);
	auth_data.append(0x4d);
	auth_data.append(0x35);
	auth_data.append(0x2c);
	auth_data.append(0x95);
	auth_data.append(0x6a);
	auth_data.append(0x6);
	auth_data.append(0xc9);
	auth_data.append(0x40);
	auth_data.append(0x7f);
	auth_data.append(0x85);
	auth_data.append(0xa9);
	auth_data.append(0xca);
	auth_data.append(0x85);
	auth_data.append(0x9d);
	auth_data.append(0x46);
	auth_data.append(0x8);
	auth_data.append(0xa9);
	auth_data.append(0x6);
	auth_data.append(0x6);
	auth_data.append(0x8e);
	auth_data.append(0x55);
	auth_data.append(0xd2);
	auth_data.append(0xa);
	auth_data.append(0x7e);
	auth_data.append(0xab);
	auth_data.append(0x89);
	auth_data.append(0x79);
	auth_data.append(0x5d);
	auth_data.append(0xe5);
	auth_data.append(0xd1);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x32);
	sig.append(0xe8);
	sig.append(0x96);
	sig.append(0xe5);
	sig.append(0x71);
	sig.append(0xc9);
	sig.append(0x6d);
	sig.append(0xec);
	sig.append(0x91);
	sig.append(0xc0);
	sig.append(0xf);
	sig.append(0x6b);
	sig.append(0x57);
	sig.append(0x49);
	sig.append(0xab);
	sig.append(0x22);
	sig.append(0xdc);
	sig.append(0x65);
	sig.append(0x92);
	sig.append(0x5a);
	sig.append(0x83);
	sig.append(0x14);
	sig.append(0xd2);
	sig.append(0x17);
	sig.append(0xcd);
	sig.append(0x90);
	sig.append(0x10);
	sig.append(0xa8);
	sig.append(0xed);
	sig.append(0xd6);
	sig.append(0xe3);
	sig.append(0xd6);
	sig.append(0xe1);
	sig.append(0xd);
	sig.append(0xcd);
	sig.append(0xcd);
	sig.append(0xbc);
	sig.append(0xe3);
	sig.append(0xe9);
	sig.append(0x6c);
	sig.append(0xcf);
	sig.append(0x97);
	sig.append(0x91);
	sig.append(0x3);
	sig.append(0x58);
	sig.append(0xc6);
	sig.append(0x91);
	sig.append(0x68);
	sig.append(0x3e);
	sig.append(0xf3);
	sig.append(0x55);
	sig.append(0x7a);
	sig.append(0x19);
	sig.append(0x4b);
	sig.append(0x5e);
	sig.append(0x28);
	sig.append(0x22);
	sig.append(0x1);
	sig.append(0x2);
	sig.append(0x47);
	sig.append(0xe);
	sig.append(0x52);
	sig.append(0x85);
	sig.append(0xf0);
	let pk = PublicKey {
		 x: 103246304022563843826844832846490728915263617442679605901614614723365615602319, 
		 y: 64816470582320892824166943388740845146166637398018404830019603722278332156966
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_31(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x37);
	hash.append(0x9);
	hash.append(0x6c);
	hash.append(0x33);
	hash.append(0x1c);
	hash.append(0x9c);
	hash.append(0xbd);
	hash.append(0x74);
	hash.append(0xad);
	hash.append(0x2f);
	hash.append(0x84);
	hash.append(0x5a);
	hash.append(0xa2);
	hash.append(0x3a);
	hash.append(0x6f);
	hash.append(0x36);
	hash.append(0xa1);
	hash.append(0x8c);
	hash.append(0xa8);
	hash.append(0x2d);
	hash.append(0xdd);
	hash.append(0x22);
	hash.append(0xfd);
	hash.append(0x6);
	hash.append(0xe2);
	hash.append(0xb1);
	hash.append(0xc3);
	hash.append(0x1a);
	hash.append(0xf6);
	hash.append(0xdb);
	hash.append(0xae);
	hash.append(0x90);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x38);
	auth_data.append(0xc2);
	auth_data.append(0x3d);
	auth_data.append(0x83);
	auth_data.append(0xcc);
	auth_data.append(0x57);
	auth_data.append(0xd3);
	auth_data.append(0xe5);
	auth_data.append(0x7a);
	auth_data.append(0x3f);
	auth_data.append(0xa2);
	auth_data.append(0x4);
	auth_data.append(0x8a);
	auth_data.append(0x4b);
	auth_data.append(0xb2);
	auth_data.append(0x3e);
	auth_data.append(0x3f);
	auth_data.append(0x60);
	auth_data.append(0xb8);
	auth_data.append(0x71);
	auth_data.append(0x6);
	auth_data.append(0x89);
	auth_data.append(0x4f);
	auth_data.append(0xe7);
	auth_data.append(0x22);
	auth_data.append(0x75);
	auth_data.append(0xf8);
	auth_data.append(0xa6);
	auth_data.append(0x86);
	auth_data.append(0xb6);
	auth_data.append(0x9b);
	auth_data.append(0xab);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x8b);
	sig.append(0xef);
	sig.append(0x91);
	sig.append(0xd5);
	sig.append(0xe8);
	sig.append(0x80);
	sig.append(0x84);
	sig.append(0xda);
	sig.append(0x8a);
	sig.append(0x27);
	sig.append(0xaa);
	sig.append(0x10);
	sig.append(0xdc);
	sig.append(0xd6);
	sig.append(0x20);
	sig.append(0xa5);
	sig.append(0x14);
	sig.append(0x50);
	sig.append(0x24);
	sig.append(0x81);
	sig.append(0x9a);
	sig.append(0x69);
	sig.append(0x7c);
	sig.append(0x52);
	sig.append(0xac);
	sig.append(0x74);
	sig.append(0x50);
	sig.append(0x57);
	sig.append(0x2a);
	sig.append(0xb3);
	sig.append(0xd);
	sig.append(0x60);
	sig.append(0xdc);
	sig.append(0x21);
	sig.append(0x65);
	sig.append(0x50);
	sig.append(0xe1);
	sig.append(0xbc);
	sig.append(0xef);
	sig.append(0xc4);
	sig.append(0xbe);
	sig.append(0xf7);
	sig.append(0x38);
	sig.append(0xbd);
	sig.append(0x8e);
	sig.append(0x4d);
	sig.append(0xe5);
	sig.append(0x73);
	sig.append(0x2e);
	sig.append(0xd7);
	sig.append(0xe0);
	sig.append(0x95);
	sig.append(0x33);
	sig.append(0x57);
	sig.append(0xa5);
	sig.append(0x4b);
	sig.append(0x43);
	sig.append(0x70);
	sig.append(0x5c);
	sig.append(0xba);
	sig.append(0xf);
	sig.append(0x22);
	sig.append(0xcf);
	sig.append(0x37);
	let pk = PublicKey {
		 x: 11804841552165976841501125305795312041423093718254531807860192863146791737484, 
		 y: 107840742961744138739851822254400155028917245545407857690073751050683141744817
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_32(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x19);
	hash.append(0xc3);
	hash.append(0x18);
	hash.append(0x79);
	hash.append(0xe9);
	hash.append(0x93);
	hash.append(0x90);
	hash.append(0x9);
	hash.append(0x45);
	hash.append(0x96);
	hash.append(0x79);
	hash.append(0xa4);
	hash.append(0xd8);
	hash.append(0x76);
	hash.append(0x85);
	hash.append(0xc7);
	hash.append(0xf4);
	hash.append(0xb0);
	hash.append(0xc8);
	hash.append(0x8b);
	hash.append(0x47);
	hash.append(0x3);
	hash.append(0x62);
	hash.append(0xd7);
	hash.append(0x4c);
	hash.append(0x44);
	hash.append(0xe6);
	hash.append(0xf7);
	hash.append(0x2a);
	hash.append(0xe1);
	hash.append(0x3a);
	hash.append(0x5a);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xf0);
	auth_data.append(0xc);
	auth_data.append(0x69);
	auth_data.append(0xb1);
	auth_data.append(0xd3);
	auth_data.append(0xbe);
	auth_data.append(0x62);
	auth_data.append(0xa1);
	auth_data.append(0x75);
	auth_data.append(0x9);
	auth_data.append(0x1e);
	auth_data.append(0x76);
	auth_data.append(0x1a);
	auth_data.append(0xac);
	auth_data.append(0x70);
	auth_data.append(0x31);
	auth_data.append(0x83);
	auth_data.append(0x15);
	auth_data.append(0x77);
	auth_data.append(0x3f);
	auth_data.append(0xac);
	auth_data.append(0x13);
	auth_data.append(0xed);
	auth_data.append(0xab);
	auth_data.append(0x84);
	auth_data.append(0x2c);
	auth_data.append(0xb8);
	auth_data.append(0xaa);
	auth_data.append(0xba);
	auth_data.append(0x3);
	auth_data.append(0xbc);
	auth_data.append(0x5a);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x5d);
	sig.append(0xfc);
	sig.append(0xdd);
	sig.append(0xdb);
	sig.append(0xb9);
	sig.append(0xc7);
	sig.append(0xc0);
	sig.append(0xfb);
	sig.append(0x37);
	sig.append(0x65);
	sig.append(0xa1);
	sig.append(0x53);
	sig.append(0x9b);
	sig.append(0xc9);
	sig.append(0xd0);
	sig.append(0xe9);
	sig.append(0x1);
	sig.append(0x9b);
	sig.append(0x91);
	sig.append(0x75);
	sig.append(0xf5);
	sig.append(0xf7);
	sig.append(0x1c);
	sig.append(0x25);
	sig.append(0xc8);
	sig.append(0x97);
	sig.append(0x9a);
	sig.append(0x4c);
	sig.append(0x37);
	sig.append(0x7);
	sig.append(0x33);
	sig.append(0x98);
	sig.append(0x33);
	sig.append(0xf6);
	sig.append(0x6);
	sig.append(0xc9);
	sig.append(0x54);
	sig.append(0x56);
	sig.append(0x68);
	sig.append(0x39);
	sig.append(0xa5);
	sig.append(0x1b);
	sig.append(0x52);
	sig.append(0xb2);
	sig.append(0x41);
	sig.append(0xad);
	sig.append(0x98);
	sig.append(0xed);
	sig.append(0x11);
	sig.append(0x69);
	sig.append(0x5a);
	sig.append(0x4d);
	sig.append(0x2d);
	sig.append(0x84);
	sig.append(0xcd);
	sig.append(0xbe);
	sig.append(0x66);
	sig.append(0x91);
	sig.append(0x5f);
	sig.append(0xd1);
	sig.append(0x52);
	sig.append(0xb8);
	sig.append(0x48);
	sig.append(0xeb);
	let pk = PublicKey {
		 x: 17602870936433784073155528382151529004239318213610491881571523678579501179833, 
		 y: 68824029432404627415750538308360787393540626536529225600729082015123019288106
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_33(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x30);
	hash.append(0xfe);
	hash.append(0x46);
	hash.append(0x6f);
	hash.append(0x20);
	hash.append(0xc7);
	hash.append(0x8d);
	hash.append(0x49);
	hash.append(0x1d);
	hash.append(0x49);
	hash.append(0x57);
	hash.append(0x48);
	hash.append(0xd1);
	hash.append(0x27);
	hash.append(0x6e);
	hash.append(0xce);
	hash.append(0x39);
	hash.append(0x8f);
	hash.append(0x2e);
	hash.append(0x4);
	hash.append(0x5);
	hash.append(0xa4);
	hash.append(0xaf);
	hash.append(0x5);
	hash.append(0x83);
	hash.append(0x31);
	hash.append(0x79);
	hash.append(0x79);
	hash.append(0xfc);
	hash.append(0x95);
	hash.append(0x62);
	hash.append(0xbe);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x11);
	auth_data.append(0x1c);
	auth_data.append(0x56);
	auth_data.append(0xde);
	auth_data.append(0xba);
	auth_data.append(0x12);
	auth_data.append(0x63);
	auth_data.append(0x4e);
	auth_data.append(0xd6);
	auth_data.append(0x7);
	auth_data.append(0x3b);
	auth_data.append(0x8f);
	auth_data.append(0x39);
	auth_data.append(0x29);
	auth_data.append(0x20);
	auth_data.append(0x19);
	auth_data.append(0x1e);
	auth_data.append(0x3b);
	auth_data.append(0x1f);
	auth_data.append(0x79);
	auth_data.append(0x5e);
	auth_data.append(0xe4);
	auth_data.append(0xc1);
	auth_data.append(0xcd);
	auth_data.append(0xe);
	auth_data.append(0xa1);
	auth_data.append(0xa);
	auth_data.append(0xbd);
	auth_data.append(0x36);
	auth_data.append(0x81);
	auth_data.append(0x18);
	auth_data.append(0xfd);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x71);
	sig.append(0x5e);
	sig.append(0xb1);
	sig.append(0x84);
	sig.append(0xbb);
	sig.append(0x93);
	sig.append(0xb1);
	sig.append(0x47);
	sig.append(0x89);
	sig.append(0xe2);
	sig.append(0x4d);
	sig.append(0x40);
	sig.append(0x68);
	sig.append(0x4b);
	sig.append(0xd1);
	sig.append(0xf2);
	sig.append(0x76);
	sig.append(0x9a);
	sig.append(0x80);
	sig.append(0x2d);
	sig.append(0x53);
	sig.append(0xf5);
	sig.append(0x36);
	sig.append(0x64);
	sig.append(0x83);
	sig.append(0xcf);
	sig.append(0xe5);
	sig.append(0x63);
	sig.append(0xe);
	sig.append(0x41);
	sig.append(0xaa);
	sig.append(0x3);
	sig.append(0xdc);
	sig.append(0x91);
	sig.append(0xc7);
	sig.append(0x4d);
	sig.append(0x4a);
	sig.append(0xbd);
	sig.append(0x50);
	sig.append(0xec);
	sig.append(0x1a);
	sig.append(0x58);
	sig.append(0xf7);
	sig.append(0x9d);
	sig.append(0xa4);
	sig.append(0x1a);
	sig.append(0x93);
	sig.append(0x3b);
	sig.append(0xcc);
	sig.append(0x0);
	sig.append(0x5e);
	sig.append(0xc9);
	sig.append(0xc7);
	sig.append(0xd3);
	sig.append(0x54);
	sig.append(0xd9);
	sig.append(0x48);
	sig.append(0x65);
	sig.append(0x64);
	sig.append(0x15);
	sig.append(0x73);
	sig.append(0xf4);
	sig.append(0xfd);
	sig.append(0x31);
	let pk = PublicKey {
		 x: 104806125266679511825825551731242082626619270438486194133974392979074305840674, 
		 y: 71375826806452127675000210293167411907060885836447319346274222561762996605667
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_34(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x6);
	hash.append(0xd6);
	hash.append(0xda);
	hash.append(0x9f);
	hash.append(0x62);
	hash.append(0x7c);
	hash.append(0x53);
	hash.append(0x10);
	hash.append(0x82);
	hash.append(0xe4);
	hash.append(0x1d);
	hash.append(0x20);
	hash.append(0x95);
	hash.append(0x4a);
	hash.append(0x72);
	hash.append(0x38);
	hash.append(0xd5);
	hash.append(0xc4);
	hash.append(0xfa);
	hash.append(0xdb);
	hash.append(0xcd);
	hash.append(0x46);
	hash.append(0xf5);
	hash.append(0xb0);
	hash.append(0xe3);
	hash.append(0xf7);
	hash.append(0x2b);
	hash.append(0x3d);
	hash.append(0xbc);
	hash.append(0x41);
	hash.append(0x76);
	hash.append(0x85);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x91);
	auth_data.append(0xe4);
	auth_data.append(0xcf);
	auth_data.append(0xc9);
	auth_data.append(0xa5);
	auth_data.append(0xfa);
	auth_data.append(0x2c);
	auth_data.append(0x91);
	auth_data.append(0xb9);
	auth_data.append(0x17);
	auth_data.append(0x85);
	auth_data.append(0xdc);
	auth_data.append(0x0);
	auth_data.append(0x1c);
	auth_data.append(0xc8);
	auth_data.append(0xed);
	auth_data.append(0x57);
	auth_data.append(0x71);
	auth_data.append(0x87);
	auth_data.append(0x5c);
	auth_data.append(0x73);
	auth_data.append(0x29);
	auth_data.append(0xde);
	auth_data.append(0x60);
	auth_data.append(0xf5);
	auth_data.append(0x5c);
	auth_data.append(0xe6);
	auth_data.append(0x62);
	auth_data.append(0x11);
	auth_data.append(0xf2);
	auth_data.append(0x59);
	auth_data.append(0x1c);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x47);
	sig.append(0x40);
	sig.append(0x83);
	sig.append(0xec);
	sig.append(0xc1);
	sig.append(0xbc);
	sig.append(0xe);
	sig.append(0xc9);
	sig.append(0xcc);
	sig.append(0xb7);
	sig.append(0x88);
	sig.append(0xe6);
	sig.append(0x4e);
	sig.append(0x99);
	sig.append(0x52);
	sig.append(0xf2);
	sig.append(0x30);
	sig.append(0xa3);
	sig.append(0x11);
	sig.append(0x80);
	sig.append(0xec);
	sig.append(0xcd);
	sig.append(0xe6);
	sig.append(0xd1);
	sig.append(0x9a);
	sig.append(0x6c);
	sig.append(0x86);
	sig.append(0x79);
	sig.append(0xa9);
	sig.append(0xb6);
	sig.append(0x1a);
	sig.append(0xd);
	sig.append(0x9f);
	sig.append(0x4e);
	sig.append(0x58);
	sig.append(0x97);
	sig.append(0xa8);
	sig.append(0xe9);
	sig.append(0x6f);
	sig.append(0x5c);
	sig.append(0xf9);
	sig.append(0x5c);
	sig.append(0xea);
	sig.append(0xa2);
	sig.append(0x78);
	sig.append(0xfa);
	sig.append(0x63);
	sig.append(0x56);
	sig.append(0xcf);
	sig.append(0x70);
	sig.append(0x7a);
	sig.append(0x3);
	sig.append(0x37);
	sig.append(0xc4);
	sig.append(0x58);
	sig.append(0x76);
	sig.append(0x4e);
	sig.append(0x2d);
	sig.append(0x9e);
	sig.append(0xf9);
	sig.append(0x3e);
	sig.append(0x94);
	sig.append(0xae);
	sig.append(0x9f);
	let pk = PublicKey {
		 x: 46145922551619589358808607293309144891833415274056313430929032278797615229725, 
		 y: 95564270554738488049607933056527964201749970268142451086288565552128713593376
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_35(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xc3);
	hash.append(0x20);
	hash.append(0xaa);
	hash.append(0x21);
	hash.append(0x92);
	hash.append(0x57);
	hash.append(0x64);
	hash.append(0xa5);
	hash.append(0x85);
	hash.append(0x80);
	hash.append(0x2b);
	hash.append(0xe5);
	hash.append(0xea);
	hash.append(0xf0);
	hash.append(0xe5);
	hash.append(0x4);
	hash.append(0xb0);
	hash.append(0xcc);
	hash.append(0xe0);
	hash.append(0x43);
	hash.append(0xf3);
	hash.append(0x3);
	hash.append(0xfa);
	hash.append(0x2);
	hash.append(0xef);
	hash.append(0xff);
	hash.append(0xaf);
	hash.append(0x69);
	hash.append(0x6d);
	hash.append(0x2f);
	hash.append(0x19);
	hash.append(0xfd);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xa4);
	auth_data.append(0x58);
	auth_data.append(0x6b);
	auth_data.append(0xe7);
	auth_data.append(0xdc);
	auth_data.append(0x1d);
	auth_data.append(0x7d);
	auth_data.append(0xf3);
	auth_data.append(0xd3);
	auth_data.append(0x27);
	auth_data.append(0x6);
	auth_data.append(0x4a);
	auth_data.append(0x8a);
	auth_data.append(0x82);
	auth_data.append(0xb0);
	auth_data.append(0x27);
	auth_data.append(0x39);
	auth_data.append(0x6f);
	auth_data.append(0x48);
	auth_data.append(0xf5);
	auth_data.append(0xf7);
	auth_data.append(0x40);
	auth_data.append(0x59);
	auth_data.append(0xcb);
	auth_data.append(0xe6);
	auth_data.append(0x29);
	auth_data.append(0x36);
	auth_data.append(0x64);
	auth_data.append(0xe2);
	auth_data.append(0x9e);
	auth_data.append(0xca);
	auth_data.append(0x99);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x7d);
	sig.append(0xb7);
	sig.append(0xc5);
	sig.append(0x25);
	sig.append(0xdd);
	sig.append(0xee);
	sig.append(0xff);
	sig.append(0x16);
	sig.append(0x7f);
	sig.append(0x59);
	sig.append(0x9c);
	sig.append(0x9e);
	sig.append(0xa9);
	sig.append(0x1b);
	sig.append(0xcb);
	sig.append(0xf1);
	sig.append(0xd4);
	sig.append(0x75);
	sig.append(0x51);
	sig.append(0x97);
	sig.append(0x47);
	sig.append(0xc0);
	sig.append(0xc);
	sig.append(0x2d);
	sig.append(0xa3);
	sig.append(0x55);
	sig.append(0xb0);
	sig.append(0xe1);
	sig.append(0x9f);
	sig.append(0xb);
	sig.append(0x52);
	sig.append(0xe6);
	sig.append(0x7b);
	sig.append(0x51);
	sig.append(0x9);
	sig.append(0x7d);
	sig.append(0xf8);
	sig.append(0x4b);
	sig.append(0x59);
	sig.append(0xc1);
	sig.append(0x65);
	sig.append(0x5c);
	sig.append(0xf3);
	sig.append(0x41);
	sig.append(0xd7);
	sig.append(0x37);
	sig.append(0x6d);
	sig.append(0x8b);
	sig.append(0x3e);
	sig.append(0x8d);
	sig.append(0x84);
	sig.append(0xd8);
	sig.append(0x24);
	sig.append(0x8e);
	sig.append(0x5b);
	sig.append(0x80);
	sig.append(0xb3);
	sig.append(0x1e);
	sig.append(0xe4);
	sig.append(0x68);
	sig.append(0x7c);
	sig.append(0x5f);
	sig.append(0xf2);
	sig.append(0x6);
	let pk = PublicKey {
		 x: 47442732028610378759076246264159599369175839218625989390010463991248696552658, 
		 y: 28749343988386678063019073717748000587572716477922314177016378134748218067343
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_36(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x48);
	hash.append(0x3c);
	hash.append(0x18);
	hash.append(0x64);
	hash.append(0x32);
	hash.append(0x0);
	hash.append(0xc4);
	hash.append(0x81);
	hash.append(0x64);
	hash.append(0xca);
	hash.append(0x65);
	hash.append(0x8);
	hash.append(0x13);
	hash.append(0x8a);
	hash.append(0x95);
	hash.append(0x46);
	hash.append(0xb4);
	hash.append(0x9);
	hash.append(0xdb);
	hash.append(0x3);
	hash.append(0x85);
	hash.append(0x94);
	hash.append(0xcf);
	hash.append(0xf4);
	hash.append(0x2f);
	hash.append(0xf4);
	hash.append(0xb9);
	hash.append(0xc1);
	hash.append(0xad);
	hash.append(0x3);
	hash.append(0x8b);
	hash.append(0x3a);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x43);
	auth_data.append(0x23);
	auth_data.append(0xb9);
	auth_data.append(0x83);
	auth_data.append(0xac);
	auth_data.append(0x9);
	auth_data.append(0x88);
	auth_data.append(0xfe);
	auth_data.append(0x10);
	auth_data.append(0x61);
	auth_data.append(0xa8);
	auth_data.append(0x74);
	auth_data.append(0x49);
	auth_data.append(0xaa);
	auth_data.append(0x54);
	auth_data.append(0x2d);
	auth_data.append(0x7b);
	auth_data.append(0xe6);
	auth_data.append(0xe0);
	auth_data.append(0xb2);
	auth_data.append(0xcd);
	auth_data.append(0xe6);
	auth_data.append(0x37);
	auth_data.append(0xbf);
	auth_data.append(0xbe);
	auth_data.append(0x5c);
	auth_data.append(0xf7);
	auth_data.append(0x70);
	auth_data.append(0x76);
	auth_data.append(0x4a);
	auth_data.append(0x15);
	auth_data.append(0x81);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x37);
	sig.append(0x6d);
	sig.append(0xe5);
	sig.append(0xd7);
	sig.append(0xff);
	sig.append(0x5b);
	sig.append(0xdd);
	sig.append(0x64);
	sig.append(0x5f);
	sig.append(0x2c);
	sig.append(0x96);
	sig.append(0xbd);
	sig.append(0x7);
	sig.append(0x94);
	sig.append(0x2);
	sig.append(0x5d);
	sig.append(0x43);
	sig.append(0x94);
	sig.append(0xca);
	sig.append(0xc1);
	sig.append(0x3);
	sig.append(0x87);
	sig.append(0xb0);
	sig.append(0x13);
	sig.append(0x46);
	sig.append(0xa);
	sig.append(0xcb);
	sig.append(0x1f);
	sig.append(0x10);
	sig.append(0x29);
	sig.append(0xc5);
	sig.append(0x7a);
	sig.append(0x31);
	sig.append(0x6a);
	sig.append(0x33);
	sig.append(0x2b);
	sig.append(0x9e);
	sig.append(0xbc);
	sig.append(0x51);
	sig.append(0x42);
	sig.append(0x45);
	sig.append(0x2c);
	sig.append(0x61);
	sig.append(0xef);
	sig.append(0xd5);
	sig.append(0x79);
	sig.append(0x20);
	sig.append(0xbc);
	sig.append(0x42);
	sig.append(0x0);
	sig.append(0x1b);
	sig.append(0x54);
	sig.append(0xd4);
	sig.append(0x47);
	sig.append(0x62);
	sig.append(0x3e);
	sig.append(0x18);
	sig.append(0x18);
	sig.append(0xae);
	sig.append(0xe5);
	sig.append(0x55);
	sig.append(0xba);
	sig.append(0x2f);
	sig.append(0xe2);
	let pk = PublicKey {
		 x: 75815677308398084314266658069045952936620350683224265112093511698360016755831, 
		 y: 101856617374146811384441854189434380043271534907775687396681833002241793248045
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_37(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xc6);
	hash.append(0x5b);
	hash.append(0xf0);
	hash.append(0xda);
	hash.append(0x9c);
	hash.append(0x96);
	hash.append(0xf6);
	hash.append(0x36);
	hash.append(0xff);
	hash.append(0x4d);
	hash.append(0xd7);
	hash.append(0x8);
	hash.append(0x2);
	hash.append(0x48);
	hash.append(0x3e);
	hash.append(0x4);
	hash.append(0x2);
	hash.append(0x25);
	hash.append(0x1a);
	hash.append(0xf);
	hash.append(0xe9);
	hash.append(0xb8);
	hash.append(0x86);
	hash.append(0x3a);
	hash.append(0x3d);
	hash.append(0xc7);
	hash.append(0xe2);
	hash.append(0xa8);
	hash.append(0xcf);
	hash.append(0x86);
	hash.append(0x71);
	hash.append(0xa3);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xd2);
	auth_data.append(0x4d);
	auth_data.append(0xac);
	auth_data.append(0x75);
	auth_data.append(0xb4);
	auth_data.append(0x66);
	auth_data.append(0xb4);
	auth_data.append(0xe2);
	auth_data.append(0x4a);
	auth_data.append(0xe2);
	auth_data.append(0x93);
	auth_data.append(0x1d);
	auth_data.append(0x29);
	auth_data.append(0xc6);
	auth_data.append(0x4f);
	auth_data.append(0x47);
	auth_data.append(0x8b);
	auth_data.append(0x3);
	auth_data.append(0x2);
	auth_data.append(0xfb);
	auth_data.append(0x65);
	auth_data.append(0x3d);
	auth_data.append(0xa7);
	auth_data.append(0x19);
	auth_data.append(0x8a);
	auth_data.append(0x75);
	auth_data.append(0x9f);
	auth_data.append(0x4c);
	auth_data.append(0x24);
	auth_data.append(0x46);
	auth_data.append(0xc4);
	auth_data.append(0x63);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x12);
	sig.append(0xd9);
	sig.append(0xae);
	sig.append(0x7e);
	sig.append(0x1e);
	sig.append(0xd7);
	sig.append(0xbf);
	sig.append(0x1);
	sig.append(0x65);
	sig.append(0x51);
	sig.append(0x6);
	sig.append(0x2c);
	sig.append(0x4c);
	sig.append(0x54);
	sig.append(0xe0);
	sig.append(0xbe);
	sig.append(0x66);
	sig.append(0x70);
	sig.append(0xcf);
	sig.append(0x5a);
	sig.append(0x9d);
	sig.append(0x80);
	sig.append(0xb4);
	sig.append(0xa6);
	sig.append(0xde);
	sig.append(0xa6);
	sig.append(0x10);
	sig.append(0xcb);
	sig.append(0xfd);
	sig.append(0x8b);
	sig.append(0x3b);
	sig.append(0x52);
	sig.append(0xcb);
	sig.append(0x8e);
	sig.append(0xd9);
	sig.append(0xa7);
	sig.append(0x50);
	sig.append(0x43);
	sig.append(0x17);
	sig.append(0xb0);
	sig.append(0x8e);
	sig.append(0xc);
	sig.append(0xcb);
	sig.append(0xdf);
	sig.append(0x3f);
	sig.append(0xd6);
	sig.append(0x76);
	sig.append(0x96);
	sig.append(0xc2);
	sig.append(0xd9);
	sig.append(0xeb);
	sig.append(0x0);
	sig.append(0x55);
	sig.append(0x73);
	sig.append(0x2b);
	sig.append(0x8);
	sig.append(0x8a);
	sig.append(0x86);
	sig.append(0xcb);
	sig.append(0x54);
	sig.append(0x49);
	sig.append(0xf8);
	sig.append(0x2b);
	sig.append(0xfb);
	let pk = PublicKey {
		 x: 31735892470563379674191195198228203688378482075598637454949604093349148339439, 
		 y: 73155745044981537694167324319011033656618749321090059258593785951817906726612
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_38(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x75);
	hash.append(0x49);
	hash.append(0x87);
	hash.append(0xa0);
	hash.append(0x41);
	hash.append(0x3e);
	hash.append(0x40);
	hash.append(0x95);
	hash.append(0xcf);
	hash.append(0xb7);
	hash.append(0x56);
	hash.append(0xc7);
	hash.append(0xa2);
	hash.append(0xe3);
	hash.append(0x58);
	hash.append(0xf0);
	hash.append(0x74);
	hash.append(0xf3);
	hash.append(0xc3);
	hash.append(0x2f);
	hash.append(0xb5);
	hash.append(0x4d);
	hash.append(0x23);
	hash.append(0x5b);
	hash.append(0xb5);
	hash.append(0x24);
	hash.append(0x7);
	hash.append(0xa7);
	hash.append(0x7a);
	hash.append(0xfc);
	hash.append(0xa6);
	hash.append(0xea);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xf6);
	auth_data.append(0x45);
	auth_data.append(0x9a);
	auth_data.append(0x88);
	auth_data.append(0x1f);
	auth_data.append(0x3a);
	auth_data.append(0x50);
	auth_data.append(0x6b);
	auth_data.append(0xaa);
	auth_data.append(0xaf);
	auth_data.append(0xb7);
	auth_data.append(0xe6);
	auth_data.append(0x54);
	auth_data.append(0x99);
	auth_data.append(0x72);
	auth_data.append(0x94);
	auth_data.append(0xd9);
	auth_data.append(0x4b);
	auth_data.append(0x79);
	auth_data.append(0xb6);
	auth_data.append(0x82);
	auth_data.append(0x49);
	auth_data.append(0xd3);
	auth_data.append(0x1f);
	auth_data.append(0x39);
	auth_data.append(0x2d);
	auth_data.append(0x3a);
	auth_data.append(0xd7);
	auth_data.append(0x3f);
	auth_data.append(0xdc);
	auth_data.append(0x89);
	auth_data.append(0x57);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x24);
	sig.append(0x2e);
	sig.append(0xc7);
	sig.append(0x4e);
	sig.append(0x85);
	sig.append(0x82);
	sig.append(0x1b);
	sig.append(0x33);
	sig.append(0x98);
	sig.append(0x64);
	sig.append(0x3d);
	sig.append(0x51);
	sig.append(0x2d);
	sig.append(0x42);
	sig.append(0x95);
	sig.append(0xd3);
	sig.append(0x54);
	sig.append(0x48);
	sig.append(0x2a);
	sig.append(0x94);
	sig.append(0xc9);
	sig.append(0xf5);
	sig.append(0x7b);
	sig.append(0x53);
	sig.append(0x10);
	sig.append(0x9b);
	sig.append(0x2);
	sig.append(0xa0);
	sig.append(0x29);
	sig.append(0x55);
	sig.append(0x97);
	sig.append(0x5d);
	sig.append(0xdd);
	sig.append(0xf9);
	sig.append(0xf7);
	sig.append(0x6f);
	sig.append(0xe5);
	sig.append(0xb0);
	sig.append(0x9e);
	sig.append(0x9b);
	sig.append(0x10);
	sig.append(0xcf);
	sig.append(0xd0);
	sig.append(0x64);
	sig.append(0xee);
	sig.append(0xe1);
	sig.append(0x6e);
	sig.append(0x76);
	sig.append(0x32);
	sig.append(0x5e);
	sig.append(0xbf);
	sig.append(0x17);
	sig.append(0x12);
	sig.append(0x67);
	sig.append(0x7e);
	sig.append(0xee);
	sig.append(0xb);
	sig.append(0xd9);
	sig.append(0x69);
	sig.append(0x2e);
	sig.append(0xce);
	sig.append(0x74);
	sig.append(0xe9);
	sig.append(0xba);
	let pk = PublicKey {
		 x: 50393207219175932193465723024735716133758996527333063416849139198963970567259, 
		 y: 8406576748988975411745378140700002824710342076061571858148248205473484379987
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_39(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x10);
	hash.append(0x17);
	hash.append(0x2);
	hash.append(0xa6);
	hash.append(0x0);
	hash.append(0xad);
	hash.append(0xf5);
	hash.append(0x76);
	hash.append(0x4c);
	hash.append(0x18);
	hash.append(0xb4);
	hash.append(0xaa);
	hash.append(0xe2);
	hash.append(0xc2);
	hash.append(0x16);
	hash.append(0xc8);
	hash.append(0x89);
	hash.append(0x10);
	hash.append(0x53);
	hash.append(0xec);
	hash.append(0xeb);
	hash.append(0xaa);
	hash.append(0x8a);
	hash.append(0x18);
	hash.append(0xe2);
	hash.append(0xa);
	hash.append(0x19);
	hash.append(0x27);
	hash.append(0x1d);
	hash.append(0xd0);
	hash.append(0xd);
	hash.append(0x99);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x8a);
	auth_data.append(0x6);
	auth_data.append(0x64);
	auth_data.append(0xff);
	auth_data.append(0x60);
	auth_data.append(0x43);
	auth_data.append(0x5);
	auth_data.append(0xa4);
	auth_data.append(0xb6);
	auth_data.append(0x16);
	auth_data.append(0x4e);
	auth_data.append(0x98);
	auth_data.append(0xdc);
	auth_data.append(0xe);
	auth_data.append(0x66);
	auth_data.append(0x94);
	auth_data.append(0xba);
	auth_data.append(0x5d);
	auth_data.append(0xaa);
	auth_data.append(0x82);
	auth_data.append(0xc1);
	auth_data.append(0xa5);
	auth_data.append(0xc2);
	auth_data.append(0xdf);
	auth_data.append(0x4f);
	auth_data.append(0x6);
	auth_data.append(0x62);
	auth_data.append(0xc1);
	auth_data.append(0xc7);
	auth_data.append(0xb0);
	auth_data.append(0x58);
	auth_data.append(0x92);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xd5);
	sig.append(0x5);
	sig.append(0x84);
	sig.append(0x75);
	sig.append(0xde);
	sig.append(0x70);
	sig.append(0xfb);
	sig.append(0x57);
	sig.append(0x31);
	sig.append(0x87);
	sig.append(0x93);
	sig.append(0x11);
	sig.append(0xfe);
	sig.append(0x23);
	sig.append(0x8c);
	sig.append(0xfb);
	sig.append(0xf1);
	sig.append(0x54);
	sig.append(0xa0);
	sig.append(0xd4);
	sig.append(0x9);
	sig.append(0xab);
	sig.append(0xe1);
	sig.append(0xb1);
	sig.append(0x4e);
	sig.append(0xfb);
	sig.append(0xfa);
	sig.append(0x82);
	sig.append(0x9);
	sig.append(0x24);
	sig.append(0x74);
	sig.append(0xf3);
	sig.append(0x68);
	sig.append(0x31);
	sig.append(0x8e);
	sig.append(0x73);
	sig.append(0xe);
	sig.append(0x9f);
	sig.append(0x61);
	sig.append(0xe4);
	sig.append(0xb7);
	sig.append(0xde);
	sig.append(0x4e);
	sig.append(0x35);
	sig.append(0xd3);
	sig.append(0x70);
	sig.append(0x1f);
	sig.append(0x99);
	sig.append(0xd1);
	sig.append(0x72);
	sig.append(0x7b);
	sig.append(0xeb);
	sig.append(0xc1);
	sig.append(0x6e);
	sig.append(0x3e);
	sig.append(0xf3);
	sig.append(0x14);
	sig.append(0x66);
	sig.append(0x52);
	sig.append(0x70);
	sig.append(0x22);
	sig.append(0x21);
	sig.append(0x7b);
	sig.append(0xcd);
	let pk = PublicKey {
		 x: 102342821835290212826761222306432352149968434053561887382491683901372506272545, 
		 y: 93197997126451905771965747407590000702484632621593511715686857923593753184821
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_40(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x0);
	hash.append(0xdb);
	hash.append(0xc8);
	hash.append(0xb4);
	hash.append(0x9f);
	hash.append(0x11);
	hash.append(0xd5);
	hash.append(0xe7);
	hash.append(0x7f);
	hash.append(0xe5);
	hash.append(0x5c);
	hash.append(0x4d);
	hash.append(0x35);
	hash.append(0x21);
	hash.append(0xc);
	hash.append(0x3f);
	hash.append(0xcd);
	hash.append(0xa2);
	hash.append(0x6d);
	hash.append(0x7f);
	hash.append(0x24);
	hash.append(0xf1);
	hash.append(0x7);
	hash.append(0x4f);
	hash.append(0xf);
	hash.append(0x57);
	hash.append(0x0);
	hash.append(0xbc);
	hash.append(0x6c);
	hash.append(0xfc);
	hash.append(0x2b);
	hash.append(0xfe);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xa9);
	auth_data.append(0x4);
	auth_data.append(0x86);
	auth_data.append(0x63);
	auth_data.append(0xc8);
	auth_data.append(0x46);
	auth_data.append(0x91);
	auth_data.append(0xa1);
	auth_data.append(0xa1);
	auth_data.append(0xd9);
	auth_data.append(0x69);
	auth_data.append(0xc9);
	auth_data.append(0xc5);
	auth_data.append(0x8f);
	auth_data.append(0x40);
	auth_data.append(0xc4);
	auth_data.append(0x93);
	auth_data.append(0x7d);
	auth_data.append(0x9a);
	auth_data.append(0x71);
	auth_data.append(0x5b);
	auth_data.append(0xb6);
	auth_data.append(0xcc);
	auth_data.append(0xee);
	auth_data.append(0x8);
	auth_data.append(0xc3);
	auth_data.append(0x55);
	auth_data.append(0x4f);
	auth_data.append(0xb5);
	auth_data.append(0x9b);
	auth_data.append(0xc0);
	auth_data.append(0x95);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x67);
	sig.append(0xc9);
	sig.append(0x31);
	sig.append(0x34);
	sig.append(0x59);
	sig.append(0xf);
	sig.append(0x1f);
	sig.append(0x5f);
	sig.append(0xe6);
	sig.append(0x4e);
	sig.append(0xe8);
	sig.append(0xe);
	sig.append(0xb7);
	sig.append(0x51);
	sig.append(0xcc);
	sig.append(0xed);
	sig.append(0x76);
	sig.append(0x49);
	sig.append(0xb5);
	sig.append(0x3e);
	sig.append(0xdf);
	sig.append(0x6b);
	sig.append(0xb5);
	sig.append(0x2f);
	sig.append(0xdb);
	sig.append(0x2f);
	sig.append(0xd6);
	sig.append(0x69);
	sig.append(0x51);
	sig.append(0x31);
	sig.append(0x28);
	sig.append(0xcd);
	sig.append(0x30);
	sig.append(0x47);
	sig.append(0x37);
	sig.append(0x63);
	sig.append(0xfb);
	sig.append(0xc6);
	sig.append(0xf1);
	sig.append(0x36);
	sig.append(0x84);
	sig.append(0xb5);
	sig.append(0xef);
	sig.append(0xc4);
	sig.append(0xdc);
	sig.append(0xb1);
	sig.append(0x21);
	sig.append(0xb1);
	sig.append(0x14);
	sig.append(0x1f);
	sig.append(0x84);
	sig.append(0xe);
	sig.append(0x9);
	sig.append(0xf3);
	sig.append(0x65);
	sig.append(0xd3);
	sig.append(0x31);
	sig.append(0x6e);
	sig.append(0x75);
	sig.append(0x9b);
	sig.append(0xec);
	sig.append(0x2b);
	sig.append(0x20);
	sig.append(0x92);
	let pk = PublicKey {
		 x: 50772685744990161841461639195314508313405332773097371119886217060860661918749, 
		 y: 27370641819467922252986377054193423056450053254461420583554349241653046288672
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_41(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x97);
	hash.append(0x48);
	hash.append(0xc1);
	hash.append(0xc4);
	hash.append(0x9c);
	hash.append(0x70);
	hash.append(0x3f);
	hash.append(0x96);
	hash.append(0x9b);
	hash.append(0xc9);
	hash.append(0x54);
	hash.append(0xd2);
	hash.append(0x4d);
	hash.append(0x5b);
	hash.append(0x15);
	hash.append(0xb7);
	hash.append(0xdd);
	hash.append(0xfd);
	hash.append(0x97);
	hash.append(0x25);
	hash.append(0x7f);
	hash.append(0xd5);
	hash.append(0xb5);
	hash.append(0x73);
	hash.append(0xb9);
	hash.append(0xf8);
	hash.append(0xd);
	hash.append(0x3c);
	hash.append(0x59);
	hash.append(0xfc);
	hash.append(0x68);
	hash.append(0xa9);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xe8);
	auth_data.append(0x8d);
	auth_data.append(0x1d);
	auth_data.append(0xc);
	auth_data.append(0x9c);
	auth_data.append(0xde);
	auth_data.append(0x1c);
	auth_data.append(0xf3);
	auth_data.append(0xc7);
	auth_data.append(0x2c);
	auth_data.append(0x75);
	auth_data.append(0xa);
	auth_data.append(0x20);
	auth_data.append(0x15);
	auth_data.append(0x11);
	auth_data.append(0x7b);
	auth_data.append(0x64);
	auth_data.append(0xca);
	auth_data.append(0xfc);
	auth_data.append(0x88);
	auth_data.append(0xbc);
	auth_data.append(0x77);
	auth_data.append(0xd4);
	auth_data.append(0x24);
	auth_data.append(0xa2);
	auth_data.append(0x6f);
	auth_data.append(0x28);
	auth_data.append(0x13);
	auth_data.append(0xa6);
	auth_data.append(0xea);
	auth_data.append(0x8e);
	auth_data.append(0x2f);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xeb);
	sig.append(0x0);
	sig.append(0xea);
	sig.append(0xf4);
	sig.append(0xea);
	sig.append(0x2c);
	sig.append(0x48);
	sig.append(0x71);
	sig.append(0xd9);
	sig.append(0x1f);
	sig.append(0xef);
	sig.append(0x38);
	sig.append(0x4);
	sig.append(0xe6);
	sig.append(0xd1);
	sig.append(0xb4);
	sig.append(0x71);
	sig.append(0x4a);
	sig.append(0xfb);
	sig.append(0xb7);
	sig.append(0xd5);
	sig.append(0x73);
	sig.append(0x16);
	sig.append(0x85);
	sig.append(0x4a);
	sig.append(0x53);
	sig.append(0x2a);
	sig.append(0x6a);
	sig.append(0x2a);
	sig.append(0x38);
	sig.append(0xac);
	sig.append(0x3);
	sig.append(0x6a);
	sig.append(0xb2);
	sig.append(0xdc);
	sig.append(0xa2);
	sig.append(0x3b);
	sig.append(0xdc);
	sig.append(0x4d);
	sig.append(0x85);
	sig.append(0x15);
	sig.append(0x1);
	sig.append(0xde);
	sig.append(0x36);
	sig.append(0x2e);
	sig.append(0xb9);
	sig.append(0x3d);
	sig.append(0xc1);
	sig.append(0x6c);
	sig.append(0xd3);
	sig.append(0x2d);
	sig.append(0xae);
	sig.append(0xb8);
	sig.append(0xc0);
	sig.append(0xff);
	sig.append(0xd7);
	sig.append(0x71);
	sig.append(0x92);
	sig.append(0x5b);
	sig.append(0xfd);
	sig.append(0x3f);
	sig.append(0xdf);
	sig.append(0xa3);
	sig.append(0x2a);
	let pk = PublicKey {
		 x: 19908025220770597318591523162982332108484560484403534054318207955786442690438, 
		 y: 107309697821814590138334120639843764772465282076919921245925930310723487403709
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_42(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xfa);
	hash.append(0xa3);
	hash.append(0x22);
	hash.append(0xfd);
	hash.append(0x7a);
	hash.append(0x9c);
	hash.append(0xa8);
	hash.append(0x3c);
	hash.append(0x91);
	hash.append(0x37);
	hash.append(0x9d);
	hash.append(0xcb);
	hash.append(0xfd);
	hash.append(0xca);
	hash.append(0x29);
	hash.append(0xe);
	hash.append(0x42);
	hash.append(0x4d);
	hash.append(0x9a);
	hash.append(0xa9);
	hash.append(0x9b);
	hash.append(0xa);
	hash.append(0xab);
	hash.append(0x52);
	hash.append(0x35);
	hash.append(0x9);
	hash.append(0xb5);
	hash.append(0x5d);
	hash.append(0x29);
	hash.append(0x3d);
	hash.append(0x41);
	hash.append(0xc7);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x15);
	auth_data.append(0x18);
	auth_data.append(0xf2);
	auth_data.append(0x5c);
	auth_data.append(0xbb);
	auth_data.append(0xff);
	auth_data.append(0xb7);
	auth_data.append(0xd0);
	auth_data.append(0x76);
	auth_data.append(0x8);
	auth_data.append(0xd4);
	auth_data.append(0x9e);
	auth_data.append(0x7b);
	auth_data.append(0x83);
	auth_data.append(0x40);
	auth_data.append(0x7b);
	auth_data.append(0xf7);
	auth_data.append(0x29);
	auth_data.append(0x4e);
	auth_data.append(0xff);
	auth_data.append(0x69);
	auth_data.append(0x16);
	auth_data.append(0x95);
	auth_data.append(0x50);
	auth_data.append(0x84);
	auth_data.append(0x15);
	auth_data.append(0x75);
	auth_data.append(0xb6);
	auth_data.append(0xf4);
	auth_data.append(0xc3);
	auth_data.append(0x6e);
	auth_data.append(0x47);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xd7);
	sig.append(0x10);
	sig.append(0xf9);
	sig.append(0x7b);
	sig.append(0xf1);
	sig.append(0xcf);
	sig.append(0x84);
	sig.append(0x19);
	sig.append(0xf2);
	sig.append(0xa9);
	sig.append(0x1e);
	sig.append(0x5f);
	sig.append(0xf8);
	sig.append(0xaa);
	sig.append(0x9d);
	sig.append(0x49);
	sig.append(0xcb);
	sig.append(0xb8);
	sig.append(0xb7);
	sig.append(0xfb);
	sig.append(0x69);
	sig.append(0x34);
	sig.append(0x2);
	sig.append(0x29);
	sig.append(0x4f);
	sig.append(0xb6);
	sig.append(0xb9);
	sig.append(0xc0);
	sig.append(0x37);
	sig.append(0x5a);
	sig.append(0x49);
	sig.append(0x57);
	sig.append(0xa3);
	sig.append(0x26);
	sig.append(0xbe);
	sig.append(0x8e);
	sig.append(0x50);
	sig.append(0x90);
	sig.append(0xc1);
	sig.append(0xa3);
	sig.append(0xc9);
	sig.append(0x77);
	sig.append(0x8a);
	sig.append(0x56);
	sig.append(0x94);
	sig.append(0x2b);
	sig.append(0xb6);
	sig.append(0x61);
	sig.append(0x4e);
	sig.append(0x0);
	sig.append(0xab);
	sig.append(0x7a);
	sig.append(0x2d);
	sig.append(0x51);
	sig.append(0xa9);
	sig.append(0x74);
	sig.append(0x59);
	sig.append(0x7a);
	sig.append(0xfb);
	sig.append(0x91);
	sig.append(0x9f);
	sig.append(0xe8);
	sig.append(0xf5);
	sig.append(0xd2);
	let pk = PublicKey {
		 x: 94860560212770684094074031556674410808143976857023048234633019541000528238542, 
		 y: 11505360667059802392453803178701014853809768628707837246604576323258201988050
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_43(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x40);
	hash.append(0x56);
	hash.append(0x75);
	hash.append(0xa1);
	hash.append(0x95);
	hash.append(0x81);
	hash.append(0x6d);
	hash.append(0x86);
	hash.append(0x35);
	hash.append(0xd2);
	hash.append(0x7);
	hash.append(0xfb);
	hash.append(0x65);
	hash.append(0xf6);
	hash.append(0x30);
	hash.append(0x8b);
	hash.append(0xbb);
	hash.append(0xba);
	hash.append(0x12);
	hash.append(0x25);
	hash.append(0xb1);
	hash.append(0xf);
	hash.append(0x7e);
	hash.append(0x27);
	hash.append(0x3b);
	hash.append(0xe7);
	hash.append(0x16);
	hash.append(0xbb);
	hash.append(0x39);
	hash.append(0xd6);
	hash.append(0xe9);
	hash.append(0xa);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x7b);
	auth_data.append(0xd0);
	auth_data.append(0xa2);
	auth_data.append(0x77);
	auth_data.append(0xd0);
	auth_data.append(0x61);
	auth_data.append(0x1f);
	auth_data.append(0x61);
	auth_data.append(0xec);
	auth_data.append(0xbc);
	auth_data.append(0x4f);
	auth_data.append(0x1);
	auth_data.append(0x78);
	auth_data.append(0x2);
	auth_data.append(0xca);
	auth_data.append(0x57);
	auth_data.append(0x4d);
	auth_data.append(0x2b);
	auth_data.append(0x30);
	auth_data.append(0x4e);
	auth_data.append(0xef);
	auth_data.append(0xcf);
	auth_data.append(0xac);
	auth_data.append(0xb7);
	auth_data.append(0x9e);
	auth_data.append(0xa5);
	auth_data.append(0x24);
	auth_data.append(0xb0);
	auth_data.append(0xc);
	auth_data.append(0xf4);
	auth_data.append(0x19);
	auth_data.append(0xc2);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xb5);
	sig.append(0xab);
	sig.append(0x47);
	sig.append(0x5f);
	sig.append(0x56);
	sig.append(0xd8);
	sig.append(0x54);
	sig.append(0x63);
	sig.append(0xaa);
	sig.append(0xe6);
	sig.append(0x71);
	sig.append(0x16);
	sig.append(0x40);
	sig.append(0x25);
	sig.append(0xe4);
	sig.append(0xa1);
	sig.append(0xe3);
	sig.append(0x98);
	sig.append(0xb0);
	sig.append(0x57);
	sig.append(0x39);
	sig.append(0x24);
	sig.append(0xd7);
	sig.append(0xe9);
	sig.append(0xbf);
	sig.append(0xb);
	sig.append(0x25);
	sig.append(0x2a);
	sig.append(0x84);
	sig.append(0x9b);
	sig.append(0x62);
	sig.append(0x3b);
	sig.append(0x66);
	sig.append(0x3e);
	sig.append(0x16);
	sig.append(0xd5);
	sig.append(0xc8);
	sig.append(0x5d);
	sig.append(0xd);
	sig.append(0xaf);
	sig.append(0xca);
	sig.append(0x2d);
	sig.append(0x9c);
	sig.append(0x17);
	sig.append(0x1a);
	sig.append(0x21);
	sig.append(0x99);
	sig.append(0x81);
	sig.append(0xa8);
	sig.append(0xcf);
	sig.append(0xd8);
	sig.append(0x70);
	sig.append(0xed);
	sig.append(0x3f);
	sig.append(0x9a);
	sig.append(0xbc);
	sig.append(0xeb);
	sig.append(0x6a);
	sig.append(0xe2);
	sig.append(0xba);
	sig.append(0xee);
	sig.append(0xde);
	sig.append(0x62);
	sig.append(0xf8);
	let pk = PublicKey {
		 x: 32409009229031203421045064258403355442348664726613976947876349158760888645793, 
		 y: 2824164193873134616097999608797418261233183139343539267428263845382420290985
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_44(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x4b);
	hash.append(0xb6);
	hash.append(0xdf);
	hash.append(0x8f);
	hash.append(0xff);
	hash.append(0x80);
	hash.append(0x77);
	hash.append(0x3c);
	hash.append(0xfe);
	hash.append(0x7);
	hash.append(0x1f);
	hash.append(0x31);
	hash.append(0x82);
	hash.append(0xc0);
	hash.append(0xc0);
	hash.append(0x34);
	hash.append(0xa1);
	hash.append(0x28);
	hash.append(0xfe);
	hash.append(0x8d);
	hash.append(0x2b);
	hash.append(0xbb);
	hash.append(0x7f);
	hash.append(0x54);
	hash.append(0x94);
	hash.append(0x60);
	hash.append(0x7d);
	hash.append(0x84);
	hash.append(0xc9);
	hash.append(0x92);
	hash.append(0xdc);
	hash.append(0x91);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xe6);
	auth_data.append(0x91);
	auth_data.append(0x5a);
	auth_data.append(0x1c);
	auth_data.append(0x4e);
	auth_data.append(0x58);
	auth_data.append(0x73);
	auth_data.append(0x36);
	auth_data.append(0xd6);
	auth_data.append(0x5);
	auth_data.append(0x3b);
	auth_data.append(0xcf);
	auth_data.append(0xe0);
	auth_data.append(0xbc);
	auth_data.append(0x2f);
	auth_data.append(0xbe);
	auth_data.append(0x7f);
	auth_data.append(0x27);
	auth_data.append(0x36);
	auth_data.append(0xba);
	auth_data.append(0xce);
	auth_data.append(0xa3);
	auth_data.append(0xb2);
	auth_data.append(0xa);
	auth_data.append(0x14);
	auth_data.append(0x5f);
	auth_data.append(0xca);
	auth_data.append(0xb4);
	auth_data.append(0xaf);
	auth_data.append(0xa8);
	auth_data.append(0xbc);
	auth_data.append(0xdd);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xe6);
	sig.append(0x2f);
	sig.append(0x3d);
	sig.append(0x54);
	sig.append(0x6b);
	sig.append(0xe);
	sig.append(0x51);
	sig.append(0x4);
	sig.append(0xda);
	sig.append(0x3d);
	sig.append(0xc5);
	sig.append(0x19);
	sig.append(0x45);
	sig.append(0x93);
	sig.append(0xed);
	sig.append(0xa6);
	sig.append(0xff);
	sig.append(0x55);
	sig.append(0x12);
	sig.append(0x35);
	sig.append(0x79);
	sig.append(0x4f);
	sig.append(0x21);
	sig.append(0x4d);
	sig.append(0x46);
	sig.append(0x37);
	sig.append(0x55);
	sig.append(0x34);
	sig.append(0xd9);
	sig.append(0x77);
	sig.append(0xb6);
	sig.append(0x99);
	sig.append(0xed);
	sig.append(0x98);
	sig.append(0x1e);
	sig.append(0xe9);
	sig.append(0xb2);
	sig.append(0x1c);
	sig.append(0xdf);
	sig.append(0x92);
	sig.append(0x49);
	sig.append(0xc4);
	sig.append(0x41);
	sig.append(0xa3);
	sig.append(0xf2);
	sig.append(0x17);
	sig.append(0xd7);
	sig.append(0x39);
	sig.append(0x97);
	sig.append(0x4d);
	sig.append(0xf9);
	sig.append(0xb9);
	sig.append(0x6e);
	sig.append(0x7f);
	sig.append(0xbd);
	sig.append(0x71);
	sig.append(0x52);
	sig.append(0xc);
	sig.append(0xcd);
	sig.append(0xa6);
	sig.append(0xb3);
	sig.append(0x68);
	sig.append(0xb1);
	sig.append(0x95);
	let pk = PublicKey {
		 x: 67646329003363955569197602688366642233282034874871807411091346614263456948456, 
		 y: 18779871993288778390171484084337204076754504792379961313070678704468142891178
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_45(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x49);
	hash.append(0x37);
	hash.append(0x83);
	hash.append(0xcc);
	hash.append(0x92);
	hash.append(0x2c);
	hash.append(0xd2);
	hash.append(0x13);
	hash.append(0xc);
	hash.append(0xc8);
	hash.append(0x4c);
	hash.append(0x96);
	hash.append(0x3f);
	hash.append(0xb8);
	hash.append(0x51);
	hash.append(0x13);
	hash.append(0x13);
	hash.append(0xaa);
	hash.append(0x40);
	hash.append(0x8f);
	hash.append(0x19);
	hash.append(0x8d);
	hash.append(0xe5);
	hash.append(0x38);
	hash.append(0x5c);
	hash.append(0x33);
	hash.append(0x4);
	hash.append(0x55);
	hash.append(0xf8);
	hash.append(0xae);
	hash.append(0x40);
	hash.append(0x1b);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x28);
	auth_data.append(0xc0);
	auth_data.append(0x84);
	auth_data.append(0xfb);
	auth_data.append(0xb0);
	auth_data.append(0x18);
	auth_data.append(0x75);
	auth_data.append(0xa);
	auth_data.append(0x6e);
	auth_data.append(0xa1);
	auth_data.append(0x32);
	auth_data.append(0xb1);
	auth_data.append(0xec);
	auth_data.append(0xd);
	auth_data.append(0x84);
	auth_data.append(0x6f);
	auth_data.append(0xb2);
	auth_data.append(0x34);
	auth_data.append(0x42);
	auth_data.append(0xab);
	auth_data.append(0x62);
	auth_data.append(0xb2);
	auth_data.append(0x53);
	auth_data.append(0x3c);
	auth_data.append(0xc8);
	auth_data.append(0x49);
	auth_data.append(0xb1);
	auth_data.append(0x7c);
	auth_data.append(0x3d);
	auth_data.append(0x7e);
	auth_data.append(0xa1);
	auth_data.append(0x2);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xf1);
	sig.append(0xdf);
	sig.append(0x32);
	sig.append(0x8f);
	sig.append(0xca);
	sig.append(0xed);
	sig.append(0x3d);
	sig.append(0xbb);
	sig.append(0xe9);
	sig.append(0x36);
	sig.append(0x52);
	sig.append(0xac);
	sig.append(0xa1);
	sig.append(0x4c);
	sig.append(0xbf);
	sig.append(0xbe);
	sig.append(0xa1);
	sig.append(0x5c);
	sig.append(0x57);
	sig.append(0xcb);
	sig.append(0x90);
	sig.append(0x8f);
	sig.append(0xc5);
	sig.append(0xea);
	sig.append(0x9a);
	sig.append(0xa2);
	sig.append(0x77);
	sig.append(0x6e);
	sig.append(0xcb);
	sig.append(0xa3);
	sig.append(0xc9);
	sig.append(0x15);
	sig.append(0x72);
	sig.append(0x92);
	sig.append(0xbb);
	sig.append(0xf5);
	sig.append(0x45);
	sig.append(0x3b);
	sig.append(0xf4);
	sig.append(0xaf);
	sig.append(0xff);
	sig.append(0x7e);
	sig.append(0x71);
	sig.append(0xb8);
	sig.append(0x87);
	sig.append(0xa9);
	sig.append(0xda);
	sig.append(0xf0);
	sig.append(0x6b);
	sig.append(0x1e);
	sig.append(0x24);
	sig.append(0x0);
	sig.append(0xe0);
	sig.append(0x21);
	sig.append(0x4c);
	sig.append(0x21);
	sig.append(0x80);
	sig.append(0xa1);
	sig.append(0xd2);
	sig.append(0xf);
	sig.append(0x7);
	sig.append(0xa4);
	sig.append(0x1c);
	sig.append(0xaa);
	let pk = PublicKey {
		 x: 31426752463556500998489312332310737810639758564278898493353542417992175933173, 
		 y: 105059005760063842279222827357933764695979039758184788944304793033890558517939
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_46(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x96);
	hash.append(0xda);
	hash.append(0x4b);
	hash.append(0x6e);
	hash.append(0xf9);
	hash.append(0xfd);
	hash.append(0x6c);
	hash.append(0x70);
	hash.append(0x1c);
	hash.append(0xc);
	hash.append(0x24);
	hash.append(0xd8);
	hash.append(0x52);
	hash.append(0x85);
	hash.append(0xf1);
	hash.append(0xdf);
	hash.append(0xd);
	hash.append(0x93);
	hash.append(0xdc);
	hash.append(0x1);
	hash.append(0xf3);
	hash.append(0x9a);
	hash.append(0xf2);
	hash.append(0x41);
	hash.append(0x25);
	hash.append(0x68);
	hash.append(0x31);
	hash.append(0xb4);
	hash.append(0x7);
	hash.append(0x79);
	hash.append(0x96);
	hash.append(0x5f);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xab);
	auth_data.append(0x9f);
	auth_data.append(0xb4);
	auth_data.append(0xef);
	auth_data.append(0xaf);
	auth_data.append(0xb1);
	auth_data.append(0x7a);
	auth_data.append(0xed);
	auth_data.append(0xb9);
	auth_data.append(0x4a);
	auth_data.append(0xc6);
	auth_data.append(0x5f);
	auth_data.append(0x94);
	auth_data.append(0x2a);
	auth_data.append(0x46);
	auth_data.append(0x9b);
	auth_data.append(0xe8);
	auth_data.append(0x17);
	auth_data.append(0xe0);
	auth_data.append(0x10);
	auth_data.append(0x40);
	auth_data.append(0x5);
	auth_data.append(0x37);
	auth_data.append(0xd5);
	auth_data.append(0xd1);
	auth_data.append(0x4c);
	auth_data.append(0xf0);
	auth_data.append(0x24);
	auth_data.append(0x93);
	auth_data.append(0xb6);
	auth_data.append(0x2d);
	auth_data.append(0x89);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xe4);
	sig.append(0x4d);
	sig.append(0x4c);
	sig.append(0x3f);
	sig.append(0x7f);
	sig.append(0x80);
	sig.append(0xe3);
	sig.append(0xe);
	sig.append(0x9d);
	sig.append(0xfc);
	sig.append(0x7c);
	sig.append(0x1c);
	sig.append(0xef);
	sig.append(0x61);
	sig.append(0x86);
	sig.append(0xff);
	sig.append(0xf5);
	sig.append(0xcb);
	sig.append(0x5);
	sig.append(0xa8);
	sig.append(0xdb);
	sig.append(0x75);
	sig.append(0x1d);
	sig.append(0x78);
	sig.append(0x46);
	sig.append(0xb4);
	sig.append(0xd3);
	sig.append(0x73);
	sig.append(0x12);
	sig.append(0x3d);
	sig.append(0x3c);
	sig.append(0x42);
	sig.append(0x99);
	sig.append(0xd4);
	sig.append(0x7c);
	sig.append(0xb4);
	sig.append(0x57);
	sig.append(0xc8);
	sig.append(0x4c);
	sig.append(0xd1);
	sig.append(0x2);
	sig.append(0xce);
	sig.append(0xfc);
	sig.append(0x1f);
	sig.append(0xa2);
	sig.append(0xd);
	sig.append(0xc6);
	sig.append(0x98);
	sig.append(0xbe);
	sig.append(0x4e);
	sig.append(0xee);
	sig.append(0xb9);
	sig.append(0x1a);
	sig.append(0x2a);
	sig.append(0x42);
	sig.append(0x6e);
	sig.append(0x2);
	sig.append(0xb2);
	sig.append(0x79);
	sig.append(0x91);
	sig.append(0x99);
	sig.append(0x90);
	sig.append(0xcb);
	sig.append(0x74);
	let pk = PublicKey {
		 x: 58039892540736120486372261060908706447618843831266606864752520613893521641573, 
		 y: 44193471539535946960329080790491976555614956938179686327257527073410978020884
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_47(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xfd);
	hash.append(0xdf);
	hash.append(0x74);
	hash.append(0xb7);
	hash.append(0xb);
	hash.append(0x1b);
	hash.append(0xc8);
	hash.append(0xfd);
	hash.append(0x3c);
	hash.append(0x86);
	hash.append(0xd4);
	hash.append(0xe7);
	hash.append(0xfc);
	hash.append(0x3b);
	hash.append(0x69);
	hash.append(0x93);
	hash.append(0xdd);
	hash.append(0xb3);
	hash.append(0x36);
	hash.append(0x5f);
	hash.append(0x8a);
	hash.append(0xcb);
	hash.append(0xde);
	hash.append(0x6e);
	hash.append(0xc8);
	hash.append(0x9f);
	hash.append(0x46);
	hash.append(0x2f);
	hash.append(0xc3);
	hash.append(0xe8);
	hash.append(0x84);
	hash.append(0x16);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xd6);
	auth_data.append(0xe1);
	auth_data.append(0x8b);
	auth_data.append(0xd);
	auth_data.append(0x1a);
	auth_data.append(0xe6);
	auth_data.append(0x24);
	auth_data.append(0x38);
	auth_data.append(0xaa);
	auth_data.append(0x1e);
	auth_data.append(0x84);
	auth_data.append(0xa8);
	auth_data.append(0x61);
	auth_data.append(0x9f);
	auth_data.append(0x57);
	auth_data.append(0xee);
	auth_data.append(0x6a);
	auth_data.append(0x30);
	auth_data.append(0x92);
	auth_data.append(0xad);
	auth_data.append(0x28);
	auth_data.append(0x86);
	auth_data.append(0x50);
	auth_data.append(0xe0);
	auth_data.append(0xc3);
	auth_data.append(0x54);
	auth_data.append(0x91);
	auth_data.append(0xe6);
	auth_data.append(0x3a);
	auth_data.append(0x33);
	auth_data.append(0x4e);
	auth_data.append(0x34);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xaf);
	sig.append(0xa);
	sig.append(0xf6);
	sig.append(0x80);
	sig.append(0x1f);
	sig.append(0xd1);
	sig.append(0xbc);
	sig.append(0x9d);
	sig.append(0x55);
	sig.append(0xcb);
	sig.append(0xc9);
	sig.append(0x40);
	sig.append(0x9f);
	sig.append(0x2);
	sig.append(0x8);
	sig.append(0xdf);
	sig.append(0xeb);
	sig.append(0x6d);
	sig.append(0xa2);
	sig.append(0xc2);
	sig.append(0xbf);
	sig.append(0x8b);
	sig.append(0xfd);
	sig.append(0x11);
	sig.append(0xbc);
	sig.append(0xda);
	sig.append(0x2e);
	sig.append(0x7e);
	sig.append(0x3e);
	sig.append(0x88);
	sig.append(0x29);
	sig.append(0x93);
	sig.append(0x50);
	sig.append(0xfc);
	sig.append(0xd3);
	sig.append(0x9c);
	sig.append(0x6e);
	sig.append(0xc7);
	sig.append(0x65);
	sig.append(0x25);
	sig.append(0xb9);
	sig.append(0x4c);
	sig.append(0x22);
	sig.append(0xfb);
	sig.append(0x34);
	sig.append(0x72);
	sig.append(0x82);
	sig.append(0x5e);
	sig.append(0xf8);
	sig.append(0x61);
	sig.append(0xda);
	sig.append(0x4d);
	sig.append(0xe9);
	sig.append(0xe1);
	sig.append(0x95);
	sig.append(0x7c);
	sig.append(0x10);
	sig.append(0xfb);
	sig.append(0xc7);
	sig.append(0x37);
	sig.append(0xab);
	sig.append(0x16);
	sig.append(0x8);
	sig.append(0x17);
	let pk = PublicKey {
		 x: 79810659476990615479012021849462067379101818264623783451891883053770571087475, 
		 y: 39841346813008752247306966883633776606273076296129890755569638975877430250864
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_48(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xec);
	hash.append(0x4d);
	hash.append(0x83);
	hash.append(0x6f);
	hash.append(0xc7);
	hash.append(0x8f);
	hash.append(0x8c);
	hash.append(0x2b);
	hash.append(0xc9);
	hash.append(0x5e);
	hash.append(0x3b);
	hash.append(0x96);
	hash.append(0x2a);
	hash.append(0xe5);
	hash.append(0xd9);
	hash.append(0x24);
	hash.append(0x16);
	hash.append(0x2f);
	hash.append(0x6d);
	hash.append(0x34);
	hash.append(0xdc);
	hash.append(0x12);
	hash.append(0x1c);
	hash.append(0x67);
	hash.append(0xbe);
	hash.append(0xe1);
	hash.append(0x6a);
	hash.append(0x72);
	hash.append(0x4d);
	hash.append(0x8f);
	hash.append(0xc9);
	hash.append(0x31);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x6f);
	auth_data.append(0xaa);
	auth_data.append(0xbd);
	auth_data.append(0x51);
	auth_data.append(0x7c);
	auth_data.append(0x23);
	auth_data.append(0x9b);
	auth_data.append(0x6c);
	auth_data.append(0xcc);
	auth_data.append(0xf1);
	auth_data.append(0x3a);
	auth_data.append(0xbd);
	auth_data.append(0x54);
	auth_data.append(0x47);
	auth_data.append(0x16);
	auth_data.append(0xd4);
	auth_data.append(0x37);
	auth_data.append(0xd1);
	auth_data.append(0x82);
	auth_data.append(0x7a);
	auth_data.append(0x67);
	auth_data.append(0xa5);
	auth_data.append(0xac);
	auth_data.append(0x10);
	auth_data.append(0x77);
	auth_data.append(0xae);
	auth_data.append(0x8a);
	auth_data.append(0xf);
	auth_data.append(0xbb);
	auth_data.append(0x27);
	auth_data.append(0x43);
	auth_data.append(0x27);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x7f);
	sig.append(0xc9);
	sig.append(0x4b);
	sig.append(0x4a);
	sig.append(0x73);
	sig.append(0xcd);
	sig.append(0x86);
	sig.append(0x2a);
	sig.append(0x2a);
	sig.append(0xe);
	sig.append(0x3a);
	sig.append(0x7e);
	sig.append(0x83);
	sig.append(0x1f);
	sig.append(0x47);
	sig.append(0x49);
	sig.append(0xea);
	sig.append(0x66);
	sig.append(0x4d);
	sig.append(0x3d);
	sig.append(0xd2);
	sig.append(0xd6);
	sig.append(0x58);
	sig.append(0x5c);
	sig.append(0x98);
	sig.append(0xb9);
	sig.append(0x9d);
	sig.append(0xc6);
	sig.append(0x5b);
	sig.append(0xa3);
	sig.append(0x85);
	sig.append(0x59);
	sig.append(0x28);
	sig.append(0x92);
	sig.append(0x2f);
	sig.append(0xd2);
	sig.append(0x85);
	sig.append(0x90);
	sig.append(0x8c);
	sig.append(0x7e);
	sig.append(0x7f);
	sig.append(0x72);
	sig.append(0xeb);
	sig.append(0x6f);
	sig.append(0x2c);
	sig.append(0xf3);
	sig.append(0xfa);
	sig.append(0xa0);
	sig.append(0xb6);
	sig.append(0xfc);
	sig.append(0xb5);
	sig.append(0x7d);
	sig.append(0x37);
	sig.append(0xa7);
	sig.append(0xb3);
	sig.append(0xfe);
	sig.append(0x16);
	sig.append(0xb4);
	sig.append(0xe5);
	sig.append(0xbc);
	sig.append(0xaf);
	sig.append(0x3d);
	sig.append(0xb5);
	sig.append(0xdc);
	let pk = PublicKey {
		 x: 25772876872961801609408654759904568575614935108874335288115897786530866020279, 
		 y: 114932434375637073762496682594323643702550720693568593223225319744707288685503
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_49(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x73);
	hash.append(0x0);
	hash.append(0x73);
	hash.append(0xda);
	hash.append(0xc5);
	hash.append(0xad);
	hash.append(0x92);
	hash.append(0xd3);
	hash.append(0xa2);
	hash.append(0xdb);
	hash.append(0x93);
	hash.append(0x9b);
	hash.append(0x42);
	hash.append(0x94);
	hash.append(0xb0);
	hash.append(0xc0);
	hash.append(0xee);
	hash.append(0x49);
	hash.append(0xaa);
	hash.append(0x40);
	hash.append(0xba);
	hash.append(0xe9);
	hash.append(0x96);
	hash.append(0x1a);
	hash.append(0xfa);
	hash.append(0xf4);
	hash.append(0x9c);
	hash.append(0x97);
	hash.append(0xde);
	hash.append(0xc5);
	hash.append(0xa7);
	hash.append(0xf0);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xc3);
	auth_data.append(0x0);
	auth_data.append(0x45);
	auth_data.append(0x6d);
	auth_data.append(0x9c);
	auth_data.append(0xff);
	auth_data.append(0xf9);
	auth_data.append(0x74);
	auth_data.append(0x72);
	auth_data.append(0x15);
	auth_data.append(0xf2);
	auth_data.append(0xc4);
	auth_data.append(0x50);
	auth_data.append(0xc);
	auth_data.append(0xec);
	auth_data.append(0xf3);
	auth_data.append(0xf7);
	auth_data.append(0x78);
	auth_data.append(0xcb);
	auth_data.append(0x5b);
	auth_data.append(0x5e);
	auth_data.append(0xa1);
	auth_data.append(0x39);
	auth_data.append(0xd4);
	auth_data.append(0x9a);
	auth_data.append(0xec);
	auth_data.append(0x45);
	auth_data.append(0x28);
	auth_data.append(0xef);
	auth_data.append(0x70);
	auth_data.append(0x76);
	auth_data.append(0xb);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xb1);
	sig.append(0x1c);
	sig.append(0x94);
	sig.append(0xca);
	sig.append(0xc2);
	sig.append(0xba);
	sig.append(0xeb);
	sig.append(0xf2);
	sig.append(0x48);
	sig.append(0x4e);
	sig.append(0xb7);
	sig.append(0xab);
	sig.append(0xd4);
	sig.append(0x67);
	sig.append(0xc);
	sig.append(0xee);
	sig.append(0xa1);
	sig.append(0x3);
	sig.append(0xa4);
	sig.append(0x9);
	sig.append(0xb6);
	sig.append(0x49);
	sig.append(0x2c);
	sig.append(0xe7);
	sig.append(0x1b);
	sig.append(0xeb);
	sig.append(0x3c);
	sig.append(0x63);
	sig.append(0xed);
	sig.append(0xd3);
	sig.append(0x5b);
	sig.append(0xb6);
	sig.append(0xd7);
	sig.append(0xbc);
	sig.append(0x42);
	sig.append(0x66);
	sig.append(0xf5);
	sig.append(0x7d);
	sig.append(0x41);
	sig.append(0xf5);
	sig.append(0x30);
	sig.append(0x8e);
	sig.append(0xf7);
	sig.append(0xf);
	sig.append(0xa2);
	sig.append(0xc9);
	sig.append(0x3b);
	sig.append(0x8);
	sig.append(0xfd);
	sig.append(0x56);
	sig.append(0x8d);
	sig.append(0xc2);
	sig.append(0x30);
	sig.append(0xb);
	sig.append(0x37);
	sig.append(0x6);
	sig.append(0xa7);
	sig.append(0x80);
	sig.append(0xd0);
	sig.append(0xfe);
	sig.append(0xc9);
	sig.append(0xcd);
	sig.append(0x3a);
	sig.append(0xdf);
	let pk = PublicKey {
		 x: 70481951859368815033638855541421788509351952583260818478177178864684956414190, 
		 y: 88612285852798053876336080498009982136115815860594991264662135137180268766271
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_50(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x29);
	hash.append(0x53);
	hash.append(0xcf);
	hash.append(0xb7);
	hash.append(0xeb);
	hash.append(0xf);
	hash.append(0xba);
	hash.append(0xb6);
	hash.append(0x73);
	hash.append(0x23);
	hash.append(0x6);
	hash.append(0x2);
	hash.append(0x90);
	hash.append(0x9);
	hash.append(0xd8);
	hash.append(0xfb);
	hash.append(0xe5);
	hash.append(0x33);
	hash.append(0x46);
	hash.append(0x6a);
	hash.append(0xe9);
	hash.append(0x7);
	hash.append(0x70);
	hash.append(0xf5);
	hash.append(0x1c);
	hash.append(0xfb);
	hash.append(0x2a);
	hash.append(0x2e);
	hash.append(0xe4);
	hash.append(0x6);
	hash.append(0x9);
	hash.append(0xb);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x85);
	auth_data.append(0x96);
	auth_data.append(0x3e);
	auth_data.append(0x50);
	auth_data.append(0x7a);
	auth_data.append(0x8d);
	auth_data.append(0xca);
	auth_data.append(0x2);
	auth_data.append(0xbe);
	auth_data.append(0x97);
	auth_data.append(0x45);
	auth_data.append(0x8a);
	auth_data.append(0xf3);
	auth_data.append(0xb1);
	auth_data.append(0x68);
	auth_data.append(0xd4);
	auth_data.append(0xf6);
	auth_data.append(0xe8);
	auth_data.append(0xb4);
	auth_data.append(0x1a);
	auth_data.append(0x18);
	auth_data.append(0xab);
	auth_data.append(0xa5);
	auth_data.append(0xca);
	auth_data.append(0xb2);
	auth_data.append(0x6d);
	auth_data.append(0xf6);
	auth_data.append(0xc8);
	auth_data.append(0xf1);
	auth_data.append(0x6a);
	auth_data.append(0xfa);
	auth_data.append(0x69);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x70);
	sig.append(0x75);
	sig.append(0xa4);
	sig.append(0x87);
	sig.append(0x86);
	sig.append(0xae);
	sig.append(0x5e);
	sig.append(0x2a);
	sig.append(0x22);
	sig.append(0x7b);
	sig.append(0x3b);
	sig.append(0x4f);
	sig.append(0x38);
	sig.append(0xdc);
	sig.append(0xee);
	sig.append(0x74);
	sig.append(0xa6);
	sig.append(0xd2);
	sig.append(0xb9);
	sig.append(0x59);
	sig.append(0x47);
	sig.append(0x2e);
	sig.append(0x97);
	sig.append(0x6c);
	sig.append(0xc1);
	sig.append(0xac);
	sig.append(0x96);
	sig.append(0x92);
	sig.append(0xee);
	sig.append(0x33);
	sig.append(0xf6);
	sig.append(0x28);
	sig.append(0x75);
	sig.append(0x83);
	sig.append(0x8b);
	sig.append(0x29);
	sig.append(0xc);
	sig.append(0x53);
	sig.append(0x82);
	sig.append(0x55);
	sig.append(0xdf);
	sig.append(0xa2);
	sig.append(0x20);
	sig.append(0x4);
	sig.append(0x52);
	sig.append(0x2c);
	sig.append(0x67);
	sig.append(0xac);
	sig.append(0x9e);
	sig.append(0xda);
	sig.append(0x3a);
	sig.append(0xef);
	sig.append(0xb3);
	sig.append(0xc9);
	sig.append(0xdd);
	sig.append(0x58);
	sig.append(0x9);
	sig.append(0xb3);
	sig.append(0x8d);
	sig.append(0x3c);
	sig.append(0x6f);
	sig.append(0x37);
	sig.append(0xf4);
	sig.append(0x2d);
	let pk = PublicKey {
		 x: 13312519681231251220653636234194359674113270136233797565280148642888860708359, 
		 y: 29155267750115528960051764461704711006716647200840965280935973507133131928964
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_51(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xdf);
	hash.append(0x98);
	hash.append(0x6f);
	hash.append(0xe);
	hash.append(0x35);
	hash.append(0x7e);
	hash.append(0x4a);
	hash.append(0x56);
	hash.append(0xa0);
	hash.append(0x67);
	hash.append(0x85);
	hash.append(0xfd);
	hash.append(0xa);
	hash.append(0xea);
	hash.append(0x64);
	hash.append(0x84);
	hash.append(0x6f);
	hash.append(0x31);
	hash.append(0x6a);
	hash.append(0x37);
	hash.append(0x15);
	hash.append(0x6c);
	hash.append(0xfa);
	hash.append(0xfc);
	hash.append(0xd5);
	hash.append(0xde);
	hash.append(0x87);
	hash.append(0x85);
	hash.append(0x78);
	hash.append(0x64);
	hash.append(0x17);
	hash.append(0x85);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x65);
	auth_data.append(0xd1);
	auth_data.append(0xb5);
	auth_data.append(0xd8);
	auth_data.append(0x45);
	auth_data.append(0xe2);
	auth_data.append(0xa2);
	auth_data.append(0x7);
	auth_data.append(0xfe);
	auth_data.append(0xfb);
	auth_data.append(0xf6);
	auth_data.append(0x4);
	auth_data.append(0xca);
	auth_data.append(0x19);
	auth_data.append(0x5f);
	auth_data.append(0x59);
	auth_data.append(0xf8);
	auth_data.append(0xfd);
	auth_data.append(0x36);
	auth_data.append(0xfb);
	auth_data.append(0xed);
	auth_data.append(0x22);
	auth_data.append(0x6e);
	auth_data.append(0xa6);
	auth_data.append(0x93);
	auth_data.append(0x24);
	auth_data.append(0x3);
	auth_data.append(0x68);
	auth_data.append(0x9a);
	auth_data.append(0xbe);
	auth_data.append(0x20);
	auth_data.append(0x9a);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x50);
	sig.append(0x26);
	sig.append(0xbc);
	sig.append(0x9a);
	sig.append(0x7c);
	sig.append(0x53);
	sig.append(0xd6);
	sig.append(0x36);
	sig.append(0xc8);
	sig.append(0x73);
	sig.append(0x60);
	sig.append(0x55);
	sig.append(0x29);
	sig.append(0xc3);
	sig.append(0x47);
	sig.append(0x52);
	sig.append(0xee);
	sig.append(0x73);
	sig.append(0x1c);
	sig.append(0x79);
	sig.append(0x14);
	sig.append(0x53);
	sig.append(0x1d);
	sig.append(0xdb);
	sig.append(0x3b);
	sig.append(0x48);
	sig.append(0x8e);
	sig.append(0x58);
	sig.append(0xd3);
	sig.append(0xe1);
	sig.append(0xce);
	sig.append(0x44);
	sig.append(0xed);
	sig.append(0x47);
	sig.append(0x35);
	sig.append(0xbb);
	sig.append(0xf8);
	sig.append(0xbd);
	sig.append(0x55);
	sig.append(0x33);
	sig.append(0xb0);
	sig.append(0xe);
	sig.append(0x44);
	sig.append(0x59);
	sig.append(0x14);
	sig.append(0xcf);
	sig.append(0x1b);
	sig.append(0x26);
	sig.append(0x59);
	sig.append(0x6b);
	sig.append(0x8);
	sig.append(0x49);
	sig.append(0x64);
	sig.append(0x3c);
	sig.append(0xd5);
	sig.append(0x2e);
	sig.append(0xd4);
	sig.append(0x9b);
	sig.append(0xcb);
	sig.append(0x42);
	sig.append(0xb8);
	sig.append(0x1f);
	sig.append(0xef);
	sig.append(0x2c);
	let pk = PublicKey {
		 x: 71857049567232957853454820488995536479918423467340296326401392127749140709206, 
		 y: 75106255592313517084124004346132088508385619261546224896881372345765351000325
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_52(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x37);
	hash.append(0x19);
	hash.append(0x28);
	hash.append(0x5e);
	hash.append(0x70);
	hash.append(0xac);
	hash.append(0x6a);
	hash.append(0x9c);
	hash.append(0x80);
	hash.append(0x88);
	hash.append(0xb6);
	hash.append(0x84);
	hash.append(0x4);
	hash.append(0x3);
	hash.append(0x77);
	hash.append(0x1b);
	hash.append(0x55);
	hash.append(0xe2);
	hash.append(0x3c);
	hash.append(0x9a);
	hash.append(0x72);
	hash.append(0xdd);
	hash.append(0x13);
	hash.append(0xc9);
	hash.append(0xf);
	hash.append(0xca);
	hash.append(0x5b);
	hash.append(0xca);
	hash.append(0x69);
	hash.append(0x1b);
	hash.append(0xe);
	hash.append(0xd4);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x5d);
	auth_data.append(0x42);
	auth_data.append(0x2d);
	auth_data.append(0x5a);
	auth_data.append(0x1a);
	auth_data.append(0x9e);
	auth_data.append(0xe0);
	auth_data.append(0x8f);
	auth_data.append(0xc9);
	auth_data.append(0x3a);
	auth_data.append(0x2);
	auth_data.append(0xf3);
	auth_data.append(0x6e);
	auth_data.append(0xf0);
	auth_data.append(0x11);
	auth_data.append(0x40);
	auth_data.append(0xc5);
	auth_data.append(0xaf);
	auth_data.append(0xad);
	auth_data.append(0x99);
	auth_data.append(0x5e);
	auth_data.append(0x7b);
	auth_data.append(0x4a);
	auth_data.append(0xf0);
	auth_data.append(0xd8);
	auth_data.append(0x9a);
	auth_data.append(0x42);
	auth_data.append(0x49);
	auth_data.append(0x92);
	auth_data.append(0x54);
	auth_data.append(0xfd);
	auth_data.append(0x74);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xcc);
	sig.append(0x5b);
	sig.append(0xe2);
	sig.append(0x38);
	sig.append(0xce);
	sig.append(0xb8);
	sig.append(0xac);
	sig.append(0x31);
	sig.append(0xb7);
	sig.append(0x75);
	sig.append(0x9a);
	sig.append(0xf8);
	sig.append(0x64);
	sig.append(0x59);
	sig.append(0x12);
	sig.append(0xbd);
	sig.append(0x3f);
	sig.append(0xbe);
	sig.append(0xb0);
	sig.append(0xe1);
	sig.append(0xd7);
	sig.append(0x4a);
	sig.append(0xf);
	sig.append(0x16);
	sig.append(0x8e);
	sig.append(0x9e);
	sig.append(0x9a);
	sig.append(0x78);
	sig.append(0xcf);
	sig.append(0x19);
	sig.append(0x8b);
	sig.append(0xf5);
	sig.append(0xfc);
	sig.append(0x92);
	sig.append(0xb5);
	sig.append(0xeb);
	sig.append(0xdb);
	sig.append(0x7);
	sig.append(0x56);
	sig.append(0xb9);
	sig.append(0x7b);
	sig.append(0x2c);
	sig.append(0xea);
	sig.append(0xfe);
	sig.append(0x7e);
	sig.append(0xfc);
	sig.append(0x4e);
	sig.append(0xc3);
	sig.append(0x8);
	sig.append(0x7d);
	sig.append(0x1c);
	sig.append(0xe5);
	sig.append(0x32);
	sig.append(0xc0);
	sig.append(0x2b);
	sig.append(0x55);
	sig.append(0x38);
	sig.append(0x13);
	sig.append(0x34);
	sig.append(0x11);
	sig.append(0x2b);
	sig.append(0xe7);
	sig.append(0x0);
	sig.append(0x24);
	let pk = PublicKey {
		 x: 21120682071333817436367609926181992521829165060185088489043123331142344562143, 
		 y: 66992553934981847975540972318829713796448724023857834221664262299553910828216
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_53(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xa8);
	hash.append(0xe0);
	hash.append(0xdb);
	hash.append(0x28);
	hash.append(0x54);
	hash.append(0x8d);
	hash.append(0xfa);
	hash.append(0xab);
	hash.append(0x62);
	hash.append(0x55);
	hash.append(0x33);
	hash.append(0x5);
	hash.append(0x30);
	hash.append(0xc6);
	hash.append(0xcf);
	hash.append(0xe5);
	hash.append(0x12);
	hash.append(0x5b);
	hash.append(0x90);
	hash.append(0xcf);
	hash.append(0x8a);
	hash.append(0x5);
	hash.append(0xbf);
	hash.append(0x6b);
	hash.append(0x2d);
	hash.append(0xa3);
	hash.append(0xe7);
	hash.append(0xf5);
	hash.append(0x7b);
	hash.append(0x46);
	hash.append(0x32);
	hash.append(0xc9);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xaf);
	auth_data.append(0xbc);
	auth_data.append(0x7f);
	auth_data.append(0x35);
	auth_data.append(0x6a);
	auth_data.append(0xa1);
	auth_data.append(0xd8);
	auth_data.append(0xce);
	auth_data.append(0xdb);
	auth_data.append(0xf1);
	auth_data.append(0xb3);
	auth_data.append(0xe4);
	auth_data.append(0x79);
	auth_data.append(0x15);
	auth_data.append(0xf9);
	auth_data.append(0x75);
	auth_data.append(0x2c);
	auth_data.append(0x64);
	auth_data.append(0x9b);
	auth_data.append(0x21);
	auth_data.append(0xdf);
	auth_data.append(0x96);
	auth_data.append(0x0);
	auth_data.append(0x25);
	auth_data.append(0xd0);
	auth_data.append(0xd7);
	auth_data.append(0x92);
	auth_data.append(0x26);
	auth_data.append(0x1b);
	auth_data.append(0x30);
	auth_data.append(0x28);
	auth_data.append(0x9e);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xe6);
	sig.append(0x67);
	sig.append(0x60);
	sig.append(0xe7);
	sig.append(0xf4);
	sig.append(0x97);
	sig.append(0x9c);
	sig.append(0x21);
	sig.append(0x68);
	sig.append(0x2f);
	sig.append(0x61);
	sig.append(0x2);
	sig.append(0xb6);
	sig.append(0xee);
	sig.append(0x26);
	sig.append(0xaf);
	sig.append(0x30);
	sig.append(0x1b);
	sig.append(0xb0);
	sig.append(0x2f);
	sig.append(0xe6);
	sig.append(0x76);
	sig.append(0x25);
	sig.append(0x6b);
	sig.append(0x46);
	sig.append(0x5c);
	sig.append(0xfc);
	sig.append(0x52);
	sig.append(0xde);
	sig.append(0xde);
	sig.append(0x19);
	sig.append(0x56);
	sig.append(0x37);
	sig.append(0xf5);
	sig.append(0x6e);
	sig.append(0xb1);
	sig.append(0xeb);
	sig.append(0xa7);
	sig.append(0xca);
	sig.append(0x48);
	sig.append(0x3f);
	sig.append(0x35);
	sig.append(0x58);
	sig.append(0x7e);
	sig.append(0x96);
	sig.append(0x58);
	sig.append(0xe7);
	sig.append(0x2c);
	sig.append(0xfa);
	sig.append(0x2e);
	sig.append(0xd2);
	sig.append(0x33);
	sig.append(0x5b);
	sig.append(0x5d);
	sig.append(0x19);
	sig.append(0xfb);
	sig.append(0x27);
	sig.append(0xda);
	sig.append(0xfe);
	sig.append(0xd8);
	sig.append(0x45);
	sig.append(0x3b);
	sig.append(0x94);
	sig.append(0xd7);
	let pk = PublicKey {
		 x: 68383626331294577711136049171107797511215864402752264788288448564482751290438, 
		 y: 99575908584008401082622977683820012698551560406814898166475628763121396189346
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_54(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x7c);
	hash.append(0xa3);
	hash.append(0xb0);
	hash.append(0xb7);
	hash.append(0x3a);
	hash.append(0x3c);
	hash.append(0xd1);
	hash.append(0xc7);
	hash.append(0x3e);
	hash.append(0x30);
	hash.append(0xd5);
	hash.append(0x44);
	hash.append(0xa5);
	hash.append(0x14);
	hash.append(0xcc);
	hash.append(0xc6);
	hash.append(0x8e);
	hash.append(0xa2);
	hash.append(0x2a);
	hash.append(0x69);
	hash.append(0xa0);
	hash.append(0xa4);
	hash.append(0x29);
	hash.append(0xe1);
	hash.append(0x41);
	hash.append(0x89);
	hash.append(0xf9);
	hash.append(0xe0);
	hash.append(0xd0);
	hash.append(0x61);
	hash.append(0xa1);
	hash.append(0x4a);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xfb);
	auth_data.append(0xb9);
	auth_data.append(0xac);
	auth_data.append(0x95);
	auth_data.append(0x28);
	auth_data.append(0x70);
	auth_data.append(0x4b);
	auth_data.append(0x93);
	auth_data.append(0xd8);
	auth_data.append(0x64);
	auth_data.append(0x23);
	auth_data.append(0xd8);
	auth_data.append(0x4d);
	auth_data.append(0xca);
	auth_data.append(0x93);
	auth_data.append(0xc9);
	auth_data.append(0x1f);
	auth_data.append(0x99);
	auth_data.append(0xc9);
	auth_data.append(0xc);
	auth_data.append(0xc3);
	auth_data.append(0x86);
	auth_data.append(0x91);
	auth_data.append(0x4f);
	auth_data.append(0xba);
	auth_data.append(0xc6);
	auth_data.append(0x5f);
	auth_data.append(0x4);
	auth_data.append(0x2a);
	auth_data.append(0xbc);
	auth_data.append(0x79);
	auth_data.append(0xe8);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xab);
	sig.append(0x7f);
	sig.append(0xd9);
	sig.append(0x28);
	sig.append(0xd5);
	sig.append(0x90);
	sig.append(0x1);
	sig.append(0xc4);
	sig.append(0xb9);
	sig.append(0xd1);
	sig.append(0xf3);
	sig.append(0xd6);
	sig.append(0xd1);
	sig.append(0x77);
	sig.append(0x30);
	sig.append(0x20);
	sig.append(0xf);
	sig.append(0x7d);
	sig.append(0xc9);
	sig.append(0x15);
	sig.append(0xdb);
	sig.append(0xc1);
	sig.append(0x4b);
	sig.append(0x80);
	sig.append(0x92);
	sig.append(0x95);
	sig.append(0x11);
	sig.append(0xfd);
	sig.append(0xb7);
	sig.append(0xb2);
	sig.append(0x90);
	sig.append(0x94);
	sig.append(0xd7);
	sig.append(0xa0);
	sig.append(0x67);
	sig.append(0x9b);
	sig.append(0xa6);
	sig.append(0x7b);
	sig.append(0x4e);
	sig.append(0x50);
	sig.append(0xaf);
	sig.append(0x84);
	sig.append(0xf7);
	sig.append(0x1c);
	sig.append(0xb1);
	sig.append(0xe3);
	sig.append(0xbb);
	sig.append(0x98);
	sig.append(0x6a);
	sig.append(0x75);
	sig.append(0xf2);
	sig.append(0x50);
	sig.append(0x50);
	sig.append(0x8a);
	sig.append(0xcd);
	sig.append(0x96);
	sig.append(0x33);
	sig.append(0xab);
	sig.append(0x70);
	sig.append(0x27);
	sig.append(0x30);
	sig.append(0xe9);
	sig.append(0xe3);
	sig.append(0x31);
	let pk = PublicKey {
		 x: 66021457239304995128178142791602796942683279486189288688342035277446834208078, 
		 y: 94738921152671231570146721750863336915465484210643964929352001847333518452154
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_55(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x8a);
	hash.append(0xeb);
	hash.append(0x7a);
	hash.append(0x5a);
	hash.append(0x56);
	hash.append(0xe);
	hash.append(0x1a);
	hash.append(0xa7);
	hash.append(0xa5);
	hash.append(0x5b);
	hash.append(0xe6);
	hash.append(0x39);
	hash.append(0xe1);
	hash.append(0x67);
	hash.append(0x98);
	hash.append(0x24);
	hash.append(0x51);
	hash.append(0xc2);
	hash.append(0x63);
	hash.append(0xec);
	hash.append(0x2b);
	hash.append(0x2d);
	hash.append(0x83);
	hash.append(0xc1);
	hash.append(0x4b);
	hash.append(0x71);
	hash.append(0x45);
	hash.append(0x33);
	hash.append(0x85);
	hash.append(0x5f);
	hash.append(0xb);
	hash.append(0xb0);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x49);
	auth_data.append(0xf2);
	auth_data.append(0x4e);
	auth_data.append(0xb7);
	auth_data.append(0xef);
	auth_data.append(0x9a);
	auth_data.append(0x7b);
	auth_data.append(0x54);
	auth_data.append(0x0);
	auth_data.append(0x2);
	auth_data.append(0xa5);
	auth_data.append(0x6);
	auth_data.append(0xa6);
	auth_data.append(0xd9);
	auth_data.append(0x96);
	auth_data.append(0x6e);
	auth_data.append(0xfd);
	auth_data.append(0x47);
	auth_data.append(0x75);
	auth_data.append(0x3c);
	auth_data.append(0xd3);
	auth_data.append(0xa5);
	auth_data.append(0x65);
	auth_data.append(0xa6);
	auth_data.append(0x1a);
	auth_data.append(0x4b);
	auth_data.append(0x2f);
	auth_data.append(0x54);
	auth_data.append(0xad);
	auth_data.append(0xbc);
	auth_data.append(0xad);
	auth_data.append(0xfe);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x55);
	sig.append(0x53);
	sig.append(0xcf);
	sig.append(0xe9);
	sig.append(0xe6);
	sig.append(0x60);
	sig.append(0x7b);
	sig.append(0x2e);
	sig.append(0x9);
	sig.append(0x29);
	sig.append(0x90);
	sig.append(0x45);
	sig.append(0x70);
	sig.append(0x9b);
	sig.append(0x91);
	sig.append(0x4b);
	sig.append(0xf);
	sig.append(0x79);
	sig.append(0x7e);
	sig.append(0x84);
	sig.append(0xf3);
	sig.append(0xfd);
	sig.append(0xb);
	sig.append(0x60);
	sig.append(0x64);
	sig.append(0x1);
	sig.append(0x87);
	sig.append(0x83);
	sig.append(0x1d);
	sig.append(0xab);
	sig.append(0xcd);
	sig.append(0x6b);
	sig.append(0xe3);
	sig.append(0x35);
	sig.append(0xb5);
	sig.append(0x9d);
	sig.append(0xb2);
	sig.append(0xb5);
	sig.append(0x14);
	sig.append(0x5f);
	sig.append(0xd5);
	sig.append(0x2d);
	sig.append(0x70);
	sig.append(0x0);
	sig.append(0x50);
	sig.append(0xe5);
	sig.append(0xd1);
	sig.append(0x84);
	sig.append(0xdb);
	sig.append(0xdd);
	sig.append(0x88);
	sig.append(0x22);
	sig.append(0x20);
	sig.append(0xf0);
	sig.append(0x13);
	sig.append(0x71);
	sig.append(0xde);
	sig.append(0x7d);
	sig.append(0xc5);
	sig.append(0x7f);
	sig.append(0xf);
	sig.append(0xc7);
	sig.append(0x5f);
	sig.append(0xc6);
	let pk = PublicKey {
		 x: 101949608099408330184893403925641708063138146150523260049628452655249877222712, 
		 y: 1469809206363755046073328127803466522892796674599143149168252853036270020836
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_56(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x77);
	hash.append(0x1d);
	hash.append(0xfb);
	hash.append(0xea);
	hash.append(0xf);
	hash.append(0x51);
	hash.append(0x27);
	hash.append(0x80);
	hash.append(0x1b);
	hash.append(0x8e);
	hash.append(0xee);
	hash.append(0x8e);
	hash.append(0x87);
	hash.append(0xaa);
	hash.append(0x7c);
	hash.append(0x9b);
	hash.append(0xfd);
	hash.append(0xf4);
	hash.append(0x49);
	hash.append(0xa6);
	hash.append(0xf);
	hash.append(0x9b);
	hash.append(0xc5);
	hash.append(0x35);
	hash.append(0x52);
	hash.append(0x6c);
	hash.append(0x4e);
	hash.append(0x8f);
	hash.append(0x14);
	hash.append(0xb3);
	hash.append(0x7e);
	hash.append(0xb6);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xc1);
	auth_data.append(0x5e);
	auth_data.append(0x26);
	auth_data.append(0x49);
	auth_data.append(0x17);
	auth_data.append(0x93);
	auth_data.append(0x65);
	auth_data.append(0x8c);
	auth_data.append(0x97);
	auth_data.append(0xc0);
	auth_data.append(0x13);
	auth_data.append(0xcc);
	auth_data.append(0x33);
	auth_data.append(0x22);
	auth_data.append(0xc);
	auth_data.append(0xfb);
	auth_data.append(0x1f);
	auth_data.append(0x73);
	auth_data.append(0x7d);
	auth_data.append(0xb9);
	auth_data.append(0x9f);
	auth_data.append(0xde);
	auth_data.append(0x59);
	auth_data.append(0x15);
	auth_data.append(0xb6);
	auth_data.append(0xc);
	auth_data.append(0xb9);
	auth_data.append(0xa0);
	auth_data.append(0x54);
	auth_data.append(0xe0);
	auth_data.append(0x70);
	auth_data.append(0x51);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x3f);
	sig.append(0xf1);
	sig.append(0xa0);
	sig.append(0xed);
	sig.append(0x5f);
	sig.append(0x8f);
	sig.append(0x50);
	sig.append(0xfc);
	sig.append(0x58);
	sig.append(0x8);
	sig.append(0x3e);
	sig.append(0xad);
	sig.append(0x7);
	sig.append(0xf5);
	sig.append(0xfe);
	sig.append(0x46);
	sig.append(0xd3);
	sig.append(0x63);
	sig.append(0xad);
	sig.append(0x18);
	sig.append(0xcb);
	sig.append(0xdf);
	sig.append(0xea);
	sig.append(0xa1);
	sig.append(0xa9);
	sig.append(0xe6);
	sig.append(0x76);
	sig.append(0x2a);
	sig.append(0x75);
	sig.append(0x97);
	sig.append(0x5);
	sig.append(0xcc);
	sig.append(0x78);
	sig.append(0x95);
	sig.append(0xd9);
	sig.append(0x9d);
	sig.append(0xfa);
	sig.append(0x23);
	sig.append(0xdb);
	sig.append(0xda);
	sig.append(0xbf);
	sig.append(0x5a);
	sig.append(0xe9);
	sig.append(0x3f);
	sig.append(0x9f);
	sig.append(0xb6);
	sig.append(0x1f);
	sig.append(0x79);
	sig.append(0xb1);
	sig.append(0xa6);
	sig.append(0x54);
	sig.append(0xb0);
	sig.append(0xb9);
	sig.append(0x2b);
	sig.append(0xba);
	sig.append(0x41);
	sig.append(0x2a);
	sig.append(0x8e);
	sig.append(0x6b);
	sig.append(0x3f);
	sig.append(0x1);
	sig.append(0x93);
	sig.append(0x8d);
	sig.append(0x3a);
	let pk = PublicKey {
		 x: 86739042771591682816927272107225677842202661912758291691745482692960597902243, 
		 y: 50506556874505782836898303854141690003228854489811206830558679614692990495786
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_57(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x96);
	hash.append(0xd5);
	hash.append(0x4d);
	hash.append(0xe0);
	hash.append(0xdc);
	hash.append(0xfd);
	hash.append(0xea);
	hash.append(0x3c);
	hash.append(0x92);
	hash.append(0xd6);
	hash.append(0x64);
	hash.append(0xd2);
	hash.append(0xc4);
	hash.append(0xfd);
	hash.append(0x84);
	hash.append(0x54);
	hash.append(0x50);
	hash.append(0x79);
	hash.append(0xe0);
	hash.append(0xee);
	hash.append(0x70);
	hash.append(0x80);
	hash.append(0xb7);
	hash.append(0x3a);
	hash.append(0x80);
	hash.append(0x73);
	hash.append(0x4f);
	hash.append(0x90);
	hash.append(0x94);
	hash.append(0x6);
	hash.append(0x4e);
	hash.append(0xc2);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x76);
	auth_data.append(0xe9);
	auth_data.append(0x14);
	auth_data.append(0x11);
	auth_data.append(0x6e);
	auth_data.append(0x3f);
	auth_data.append(0x9f);
	auth_data.append(0x1a);
	auth_data.append(0x98);
	auth_data.append(0xf1);
	auth_data.append(0x6e);
	auth_data.append(0xba);
	auth_data.append(0x2b);
	auth_data.append(0x47);
	auth_data.append(0xba);
	auth_data.append(0xaf);
	auth_data.append(0xf0);
	auth_data.append(0xa2);
	auth_data.append(0x37);
	auth_data.append(0x1e);
	auth_data.append(0x93);
	auth_data.append(0xc8);
	auth_data.append(0x0);
	auth_data.append(0x14);
	auth_data.append(0x16);
	auth_data.append(0x9e);
	auth_data.append(0xf0);
	auth_data.append(0x4);
	auth_data.append(0xe1);
	auth_data.append(0x3e);
	auth_data.append(0x29);
	auth_data.append(0x90);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xb3);
	sig.append(0xd9);
	sig.append(0x9a);
	sig.append(0xa8);
	sig.append(0xcb);
	sig.append(0x1d);
	sig.append(0xea);
	sig.append(0x90);
	sig.append(0x72);
	sig.append(0x92);
	sig.append(0x13);
	sig.append(0xce);
	sig.append(0xee);
	sig.append(0x7d);
	sig.append(0x73);
	sig.append(0x56);
	sig.append(0x77);
	sig.append(0x3);
	sig.append(0xbd);
	sig.append(0x1e);
	sig.append(0x5f);
	sig.append(0xde);
	sig.append(0xdc);
	sig.append(0xcc);
	sig.append(0x92);
	sig.append(0x9);
	sig.append(0xd3);
	sig.append(0xf2);
	sig.append(0xdb);
	sig.append(0xd3);
	sig.append(0x14);
	sig.append(0x84);
	sig.append(0xfc);
	sig.append(0xe5);
	sig.append(0x34);
	sig.append(0x8e);
	sig.append(0x3c);
	sig.append(0xd0);
	sig.append(0xa7);
	sig.append(0x99);
	sig.append(0x3f);
	sig.append(0xda);
	sig.append(0xf0);
	sig.append(0x22);
	sig.append(0xb9);
	sig.append(0x38);
	sig.append(0x13);
	sig.append(0x30);
	sig.append(0x2c);
	sig.append(0xf9);
	sig.append(0xb9);
	sig.append(0xa6);
	sig.append(0x30);
	sig.append(0x42);
	sig.append(0xe7);
	sig.append(0x79);
	sig.append(0xaf);
	sig.append(0xea);
	sig.append(0x77);
	sig.append(0x1e);
	sig.append(0x2c);
	sig.append(0x55);
	sig.append(0xb9);
	sig.append(0xfb);
	let pk = PublicKey {
		 x: 106734883840067151952554990444272225971460221516624928129182549958024337313984, 
		 y: 11541525884172259001411638044033846613294595601926043470346615663829854007803
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_58(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xed);
	hash.append(0xcb);
	hash.append(0xb5);
	hash.append(0x51);
	hash.append(0x18);
	hash.append(0x9a);
	hash.append(0xca);
	hash.append(0xce);
	hash.append(0x53);
	hash.append(0xad);
	hash.append(0xc);
	hash.append(0xf2);
	hash.append(0xf1);
	hash.append(0xa6);
	hash.append(0xb3);
	hash.append(0xae);
	hash.append(0x6b);
	hash.append(0x34);
	hash.append(0xb2);
	hash.append(0xf2);
	hash.append(0xf5);
	hash.append(0x63);
	hash.append(0xae);
	hash.append(0x34);
	hash.append(0x76);
	hash.append(0x6);
	hash.append(0xf0);
	hash.append(0x27);
	hash.append(0x6);
	hash.append(0x6e);
	hash.append(0xaa);
	hash.append(0x63);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xd0);
	auth_data.append(0x2);
	auth_data.append(0xf9);
	auth_data.append(0x4);
	auth_data.append(0x29);
	auth_data.append(0x28);
	auth_data.append(0xcb);
	auth_data.append(0xa4);
	auth_data.append(0xde);
	auth_data.append(0x4c);
	auth_data.append(0xe2);
	auth_data.append(0xfd);
	auth_data.append(0x75);
	auth_data.append(0xa8);
	auth_data.append(0x42);
	auth_data.append(0xfa);
	auth_data.append(0x74);
	auth_data.append(0x83);
	auth_data.append(0x38);
	auth_data.append(0x30);
	auth_data.append(0x6f);
	auth_data.append(0xed);
	auth_data.append(0xfa);
	auth_data.append(0x8a);
	auth_data.append(0x96);
	auth_data.append(0x89);
	auth_data.append(0xe9);
	auth_data.append(0x3d);
	auth_data.append(0xe8);
	auth_data.append(0xaa);
	auth_data.append(0xb2);
	auth_data.append(0x26);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xa9);
	sig.append(0xc3);
	sig.append(0xe8);
	sig.append(0xd9);
	sig.append(0x67);
	sig.append(0xe2);
	sig.append(0x18);
	sig.append(0x98);
	sig.append(0x60);
	sig.append(0x31);
	sig.append(0xcc);
	sig.append(0xcc);
	sig.append(0xed);
	sig.append(0xee);
	sig.append(0x30);
	sig.append(0xd9);
	sig.append(0x34);
	sig.append(0xc2);
	sig.append(0x93);
	sig.append(0xf);
	sig.append(0x57);
	sig.append(0xb7);
	sig.append(0xa);
	sig.append(0x2);
	sig.append(0x1d);
	sig.append(0x76);
	sig.append(0xc4);
	sig.append(0xd5);
	sig.append(0xd7);
	sig.append(0x54);
	sig.append(0xe4);
	sig.append(0x13);
	sig.append(0xf7);
	sig.append(0x70);
	sig.append(0x59);
	sig.append(0xd8);
	sig.append(0xb1);
	sig.append(0x46);
	sig.append(0x5a);
	sig.append(0xfc);
	sig.append(0xb8);
	sig.append(0x8f);
	sig.append(0x27);
	sig.append(0x8f);
	sig.append(0x29);
	sig.append(0x22);
	sig.append(0x54);
	sig.append(0xfb);
	sig.append(0xa0);
	sig.append(0xbb);
	sig.append(0xfc);
	sig.append(0xe9);
	sig.append(0xe3);
	sig.append(0x53);
	sig.append(0x55);
	sig.append(0x8f);
	sig.append(0xe8);
	sig.append(0xa0);
	sig.append(0x1c);
	sig.append(0x68);
	sig.append(0x25);
	sig.append(0xd0);
	sig.append(0xd4);
	sig.append(0x5e);
	let pk = PublicKey {
		 x: 12159521388404972666625776485096423785723118756396395829587590006324029545587, 
		 y: 77110802680277479012144962782235438467505878640446468106952453327114953170972
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_59(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x28);
	hash.append(0x53);
	hash.append(0xe7);
	hash.append(0x7a);
	hash.append(0x7f);
	hash.append(0xe6);
	hash.append(0x54);
	hash.append(0xe0);
	hash.append(0x37);
	hash.append(0x3e);
	hash.append(0xf5);
	hash.append(0x6e);
	hash.append(0xc7);
	hash.append(0x59);
	hash.append(0xad);
	hash.append(0x2a);
	hash.append(0xae);
	hash.append(0x33);
	hash.append(0xb0);
	hash.append(0xbd);
	hash.append(0x4d);
	hash.append(0x9e);
	hash.append(0x8c);
	hash.append(0x6c);
	hash.append(0x68);
	hash.append(0x52);
	hash.append(0x9d);
	hash.append(0x11);
	hash.append(0xb2);
	hash.append(0xd3);
	hash.append(0xb6);
	hash.append(0x9e);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x3f);
	auth_data.append(0xc5);
	auth_data.append(0x14);
	auth_data.append(0x49);
	auth_data.append(0x5e);
	auth_data.append(0x9d);
	auth_data.append(0x29);
	auth_data.append(0x5a);
	auth_data.append(0xda);
	auth_data.append(0xaa);
	auth_data.append(0x5c);
	auth_data.append(0xbe);
	auth_data.append(0x31);
	auth_data.append(0x38);
	auth_data.append(0xb);
	auth_data.append(0x67);
	auth_data.append(0x5f);
	auth_data.append(0x27);
	auth_data.append(0xbe);
	auth_data.append(0xd9);
	auth_data.append(0x18);
	auth_data.append(0x83);
	auth_data.append(0xc8);
	auth_data.append(0xa9);
	auth_data.append(0x3a);
	auth_data.append(0xa);
	auth_data.append(0x4);
	auth_data.append(0xf9);
	auth_data.append(0xd1);
	auth_data.append(0x4);
	auth_data.append(0x25);
	auth_data.append(0x70);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xa9);
	sig.append(0x21);
	sig.append(0x2c);
	sig.append(0x13);
	sig.append(0xc2);
	sig.append(0x3);
	sig.append(0x22);
	sig.append(0xf7);
	sig.append(0xfb);
	sig.append(0x5a);
	sig.append(0x2b);
	sig.append(0x50);
	sig.append(0x3f);
	sig.append(0x6e);
	sig.append(0x7e);
	sig.append(0xc4);
	sig.append(0x9d);
	sig.append(0x8);
	sig.append(0xde);
	sig.append(0x55);
	sig.append(0x7f);
	sig.append(0x32);
	sig.append(0xc);
	sig.append(0x19);
	sig.append(0x7d);
	sig.append(0xa6);
	sig.append(0x60);
	sig.append(0x84);
	sig.append(0x33);
	sig.append(0x63);
	sig.append(0xb6);
	sig.append(0xbb);
	sig.append(0xb8);
	sig.append(0x99);
	sig.append(0xcb);
	sig.append(0x27);
	sig.append(0xbd);
	sig.append(0xba);
	sig.append(0xa8);
	sig.append(0x3f);
	sig.append(0xb3);
	sig.append(0xc4);
	sig.append(0xee);
	sig.append(0xb2);
	sig.append(0xf8);
	sig.append(0x4f);
	sig.append(0xa0);
	sig.append(0xb9);
	sig.append(0x19);
	sig.append(0x1);
	sig.append(0x3);
	sig.append(0xa3);
	sig.append(0xdd);
	sig.append(0xf1);
	sig.append(0xaa);
	sig.append(0x6f);
	sig.append(0x33);
	sig.append(0xe7);
	sig.append(0x74);
	sig.append(0x3a);
	sig.append(0x42);
	sig.append(0x3e);
	sig.append(0xc7);
	sig.append(0xc);
	let pk = PublicKey {
		 x: 34391251501842893979939502586506477812718405531968049102990311457023234546476, 
		 y: 59201208056489734715006888755120470842415729634828326828840434704826221553070
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_60(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x5b);
	hash.append(0x3d);
	hash.append(0xad);
	hash.append(0x6f);
	hash.append(0x73);
	hash.append(0x4e);
	hash.append(0xbf);
	hash.append(0x58);
	hash.append(0xed);
	hash.append(0x9);
	hash.append(0x63);
	hash.append(0xb6);
	hash.append(0xe7);
	hash.append(0xbe);
	hash.append(0x76);
	hash.append(0xdb);
	hash.append(0xf1);
	hash.append(0x5);
	hash.append(0xa7);
	hash.append(0xec);
	hash.append(0xdb);
	hash.append(0x88);
	hash.append(0x54);
	hash.append(0x75);
	hash.append(0x67);
	hash.append(0x23);
	hash.append(0x46);
	hash.append(0xc3);
	hash.append(0x7d);
	hash.append(0x91);
	hash.append(0xe0);
	hash.append(0xd0);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xc7);
	auth_data.append(0xfd);
	auth_data.append(0x1b);
	auth_data.append(0x82);
	auth_data.append(0x5);
	auth_data.append(0x78);
	auth_data.append(0xb);
	auth_data.append(0x17);
	auth_data.append(0xdd);
	auth_data.append(0x31);
	auth_data.append(0x13);
	auth_data.append(0xf3);
	auth_data.append(0x70);
	auth_data.append(0x5c);
	auth_data.append(0xd6);
	auth_data.append(0x19);
	auth_data.append(0x48);
	auth_data.append(0xee);
	auth_data.append(0x9f);
	auth_data.append(0x45);
	auth_data.append(0x40);
	auth_data.append(0x52);
	auth_data.append(0x1b);
	auth_data.append(0x16);
	auth_data.append(0xe2);
	auth_data.append(0xda);
	auth_data.append(0xa1);
	auth_data.append(0xe2);
	auth_data.append(0x89);
	auth_data.append(0x82);
	auth_data.append(0x22);
	auth_data.append(0xe8);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x8b);
	sig.append(0x9a);
	sig.append(0xa3);
	sig.append(0x82);
	sig.append(0x6);
	sig.append(0xa7);
	sig.append(0x8d);
	sig.append(0x70);
	sig.append(0xe8);
	sig.append(0xe9);
	sig.append(0xe5);
	sig.append(0xd5);
	sig.append(0x3c);
	sig.append(0x3b);
	sig.append(0x23);
	sig.append(0x33);
	sig.append(0xb2);
	sig.append(0x94);
	sig.append(0xcc);
	sig.append(0xfa);
	sig.append(0x96);
	sig.append(0xc0);
	sig.append(0xaf);
	sig.append(0xae);
	sig.append(0x16);
	sig.append(0x24);
	sig.append(0xf3);
	sig.append(0xcf);
	sig.append(0x93);
	sig.append(0x4a);
	sig.append(0x82);
	sig.append(0x43);
	sig.append(0xb1);
	sig.append(0xfa);
	sig.append(0xad);
	sig.append(0x7d);
	sig.append(0x8a);
	sig.append(0xd3);
	sig.append(0x74);
	sig.append(0x7);
	sig.append(0x26);
	sig.append(0x57);
	sig.append(0x57);
	sig.append(0xb2);
	sig.append(0xc9);
	sig.append(0x25);
	sig.append(0x55);
	sig.append(0x4a);
	sig.append(0x9f);
	sig.append(0x58);
	sig.append(0xbd);
	sig.append(0xaf);
	sig.append(0x1b);
	sig.append(0xe6);
	sig.append(0x7c);
	sig.append(0xc6);
	sig.append(0xd7);
	sig.append(0xd4);
	sig.append(0xd);
	sig.append(0xd4);
	sig.append(0x25);
	sig.append(0x69);
	sig.append(0x59);
	sig.append(0x8e);
	let pk = PublicKey {
		 x: 35155627431826095895320000895300070044846403444147951290123321188717298036178, 
		 y: 24580606966573320130615994362204684016020935987734890207111367018967624551246
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_61(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x77);
	hash.append(0x34);
	hash.append(0xf);
	hash.append(0x4a);
	hash.append(0x58);
	hash.append(0x2d);
	hash.append(0x84);
	hash.append(0x57);
	hash.append(0x51);
	hash.append(0xd7);
	hash.append(0xc7);
	hash.append(0xc9);
	hash.append(0xb6);
	hash.append(0x73);
	hash.append(0x6e);
	hash.append(0xe5);
	hash.append(0x68);
	hash.append(0xb1);
	hash.append(0x7f);
	hash.append(0xbf);
	hash.append(0x9e);
	hash.append(0x50);
	hash.append(0xdb);
	hash.append(0x71);
	hash.append(0x1d);
	hash.append(0x52);
	hash.append(0x12);
	hash.append(0x66);
	hash.append(0x32);
	hash.append(0x3b);
	hash.append(0x32);
	hash.append(0x24);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x41);
	auth_data.append(0x4b);
	auth_data.append(0x92);
	auth_data.append(0x9a);
	auth_data.append(0x90);
	auth_data.append(0xb4);
	auth_data.append(0x40);
	auth_data.append(0x52);
	auth_data.append(0x32);
	auth_data.append(0x8b);
	auth_data.append(0x34);
	auth_data.append(0x7f);
	auth_data.append(0x26);
	auth_data.append(0x5c);
	auth_data.append(0xfd);
	auth_data.append(0x10);
	auth_data.append(0x10);
	auth_data.append(0x73);
	auth_data.append(0x88);
	auth_data.append(0x11);
	auth_data.append(0xd3);
	auth_data.append(0x6e);
	auth_data.append(0x5d);
	auth_data.append(0xf);
	auth_data.append(0x29);
	auth_data.append(0xd5);
	auth_data.append(0xbe);
	auth_data.append(0xec);
	auth_data.append(0xbf);
	auth_data.append(0x2c);
	auth_data.append(0xfb);
	auth_data.append(0x19);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xd7);
	sig.append(0xae);
	sig.append(0xb0);
	sig.append(0x73);
	sig.append(0x99);
	sig.append(0xd0);
	sig.append(0xa4);
	sig.append(0xb6);
	sig.append(0x0);
	sig.append(0x80);
	sig.append(0xa1);
	sig.append(0xe4);
	sig.append(0x3d);
	sig.append(0xe6);
	sig.append(0x6);
	sig.append(0xc2);
	sig.append(0x2d);
	sig.append(0xd4);
	sig.append(0x50);
	sig.append(0xaa);
	sig.append(0xba);
	sig.append(0xd1);
	sig.append(0x61);
	sig.append(0xe0);
	sig.append(0xd0);
	sig.append(0x70);
	sig.append(0x31);
	sig.append(0x4b);
	sig.append(0xfc);
	sig.append(0x18);
	sig.append(0xa);
	sig.append(0xb7);
	sig.append(0x64);
	sig.append(0xc0);
	sig.append(0xa1);
	sig.append(0xae);
	sig.append(0x68);
	sig.append(0xe0);
	sig.append(0xd2);
	sig.append(0x24);
	sig.append(0x62);
	sig.append(0xd8);
	sig.append(0xaa);
	sig.append(0xfc);
	sig.append(0xa4);
	sig.append(0x36);
	sig.append(0xac);
	sig.append(0x8e);
	sig.append(0xf5);
	sig.append(0xe9);
	sig.append(0x7e);
	sig.append(0xe6);
	sig.append(0x9f);
	sig.append(0x5f);
	sig.append(0x25);
	sig.append(0x3c);
	sig.append(0xda);
	sig.append(0xfe);
	sig.append(0x81);
	sig.append(0xaa);
	sig.append(0x45);
	sig.append(0x3c);
	sig.append(0x35);
	sig.append(0x1);
	let pk = PublicKey {
		 x: 97661448906425836978820878787239291086310747649304061196612910730022938349098, 
		 y: 99758698177208286881024209374737192195035863739088020855983770522820354955450
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_62(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x35);
	hash.append(0x97);
	hash.append(0xbb);
	hash.append(0xc3);
	hash.append(0xf6);
	hash.append(0x70);
	hash.append(0x1c);
	hash.append(0xc0);
	hash.append(0xc1);
	hash.append(0xbd);
	hash.append(0x58);
	hash.append(0xcf);
	hash.append(0x28);
	hash.append(0x2b);
	hash.append(0x8e);
	hash.append(0x76);
	hash.append(0xb6);
	hash.append(0xf0);
	hash.append(0x28);
	hash.append(0x82);
	hash.append(0xfd);
	hash.append(0xfd);
	hash.append(0xa2);
	hash.append(0x9c);
	hash.append(0x72);
	hash.append(0xf8);
	hash.append(0x64);
	hash.append(0x2b);
	hash.append(0x95);
	hash.append(0xfb);
	hash.append(0xa3);
	hash.append(0x17);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x5);
	auth_data.append(0x31);
	auth_data.append(0xa6);
	auth_data.append(0x5e);
	auth_data.append(0x5e);
	auth_data.append(0x80);
	auth_data.append(0xa3);
	auth_data.append(0x60);
	auth_data.append(0x8d);
	auth_data.append(0x57);
	auth_data.append(0xbf);
	auth_data.append(0xbd);
	auth_data.append(0xb8);
	auth_data.append(0x7f);
	auth_data.append(0x61);
	auth_data.append(0x97);
	auth_data.append(0x25);
	auth_data.append(0x48);
	auth_data.append(0xa5);
	auth_data.append(0x2e);
	auth_data.append(0x98);
	auth_data.append(0xbe);
	auth_data.append(0x7a);
	auth_data.append(0x43);
	auth_data.append(0x12);
	auth_data.append(0x4a);
	auth_data.append(0x45);
	auth_data.append(0x93);
	auth_data.append(0xf9);
	auth_data.append(0xff);
	auth_data.append(0xb4);
	auth_data.append(0xb7);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x9e);
	sig.append(0x98);
	sig.append(0x5c);
	sig.append(0x22);
	sig.append(0x33);
	sig.append(0x8a);
	sig.append(0x57);
	sig.append(0x88);
	sig.append(0x88);
	sig.append(0xcf);
	sig.append(0x36);
	sig.append(0x49);
	sig.append(0x2c);
	sig.append(0x21);
	sig.append(0x93);
	sig.append(0x19);
	sig.append(0x18);
	sig.append(0x5);
	sig.append(0x97);
	sig.append(0x89);
	sig.append(0x21);
	sig.append(0x44);
	sig.append(0x4f);
	sig.append(0xc);
	sig.append(0x66);
	sig.append(0x2d);
	sig.append(0xbf);
	sig.append(0xc8);
	sig.append(0x6e);
	sig.append(0xcf);
	sig.append(0x84);
	sig.append(0x95);
	sig.append(0x3c);
	sig.append(0x1b);
	sig.append(0x58);
	sig.append(0x48);
	sig.append(0x9e);
	sig.append(0xae);
	sig.append(0xb9);
	sig.append(0x96);
	sig.append(0xe);
	sig.append(0x3d);
	sig.append(0x8d);
	sig.append(0xa2);
	sig.append(0x1d);
	sig.append(0x90);
	sig.append(0x8c);
	sig.append(0xd3);
	sig.append(0xdf);
	sig.append(0x3a);
	sig.append(0x1d);
	sig.append(0xd7);
	sig.append(0xea);
	sig.append(0x4a);
	sig.append(0x98);
	sig.append(0x71);
	sig.append(0x12);
	sig.append(0x76);
	sig.append(0x2f);
	sig.append(0x4f);
	sig.append(0x61);
	sig.append(0x2c);
	sig.append(0x4d);
	sig.append(0x1a);
	let pk = PublicKey {
		 x: 80412647965029419730209697730216910812089923801085999122106259607612043074656, 
		 y: 12492668959772103214814269937930918677005995495201340813582247553320521654588
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_63(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x81);
	hash.append(0xf3);
	hash.append(0x21);
	hash.append(0xb);
	hash.append(0xd0);
	hash.append(0x75);
	hash.append(0x8f);
	hash.append(0x31);
	hash.append(0xe3);
	hash.append(0x43);
	hash.append(0xf3);
	hash.append(0x19);
	hash.append(0xe2);
	hash.append(0x34);
	hash.append(0x6f);
	hash.append(0xac);
	hash.append(0x3);
	hash.append(0x5e);
	hash.append(0xe0);
	hash.append(0x65);
	hash.append(0x6b);
	hash.append(0xd8);
	hash.append(0xc6);
	hash.append(0x36);
	hash.append(0x92);
	hash.append(0x92);
	hash.append(0x3d);
	hash.append(0x35);
	hash.append(0x6c);
	hash.append(0x14);
	hash.append(0xe2);
	hash.append(0x40);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x2b);
	auth_data.append(0xe4);
	auth_data.append(0x20);
	auth_data.append(0x26);
	auth_data.append(0xb6);
	auth_data.append(0xb1);
	auth_data.append(0x12);
	auth_data.append(0xc0);
	auth_data.append(0xa7);
	auth_data.append(0xd2);
	auth_data.append(0x1d);
	auth_data.append(0xba);
	auth_data.append(0x13);
	auth_data.append(0x55);
	auth_data.append(0xbb);
	auth_data.append(0xc6);
	auth_data.append(0x61);
	auth_data.append(0x29);
	auth_data.append(0x51);
	auth_data.append(0x78);
	auth_data.append(0xfa);
	auth_data.append(0x2d);
	auth_data.append(0x6d);
	auth_data.append(0xdf);
	auth_data.append(0xd);
	auth_data.append(0x5f);
	auth_data.append(0x65);
	auth_data.append(0xe8);
	auth_data.append(0x7);
	auth_data.append(0xc);
	auth_data.append(0xbf);
	auth_data.append(0xc5);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xda);
	sig.append(0x37);
	sig.append(0x49);
	sig.append(0x33);
	sig.append(0x15);
	sig.append(0xab);
	sig.append(0x75);
	sig.append(0xe1);
	sig.append(0xcd);
	sig.append(0x54);
	sig.append(0x19);
	sig.append(0x13);
	sig.append(0x64);
	sig.append(0xd9);
	sig.append(0xea);
	sig.append(0x9b);
	sig.append(0x62);
	sig.append(0xc0);
	sig.append(0x97);
	sig.append(0x14);
	sig.append(0x91);
	sig.append(0xe8);
	sig.append(0xfe);
	sig.append(0x50);
	sig.append(0x82);
	sig.append(0x22);
	sig.append(0x9e);
	sig.append(0x70);
	sig.append(0x44);
	sig.append(0x76);
	sig.append(0x68);
	sig.append(0xa8);
	sig.append(0xc3);
	sig.append(0x5f);
	sig.append(0x52);
	sig.append(0xf5);
	sig.append(0x2b);
	sig.append(0xfc);
	sig.append(0xf6);
	sig.append(0xc1);
	sig.append(0x38);
	sig.append(0x29);
	sig.append(0xd6);
	sig.append(0x98);
	sig.append(0x15);
	sig.append(0xa8);
	sig.append(0xbd);
	sig.append(0xe7);
	sig.append(0x9e);
	sig.append(0x89);
	sig.append(0x93);
	sig.append(0x22);
	sig.append(0x3f);
	sig.append(0xf3);
	sig.append(0x40);
	sig.append(0xca);
	sig.append(0xc2);
	sig.append(0x49);
	sig.append(0xb6);
	sig.append(0x2f);
	sig.append(0xbe);
	sig.append(0xef);
	sig.append(0x82);
	sig.append(0xd2);
	let pk = PublicKey {
		 x: 36844754733387663591250769192756260137807882646417148084215123407630473271040, 
		 y: 3211594774059674976499582100000217851542656388340688529664965841015066346358
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_64(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x72);
	hash.append(0xcc);
	hash.append(0xf1);
	hash.append(0x74);
	hash.append(0x46);
	hash.append(0x53);
	hash.append(0x1c);
	hash.append(0x15);
	hash.append(0x1a);
	hash.append(0xc0);
	hash.append(0x28);
	hash.append(0xa8);
	hash.append(0x77);
	hash.append(0x3c);
	hash.append(0xeb);
	hash.append(0xc);
	hash.append(0xa4);
	hash.append(0xa6);
	hash.append(0x33);
	hash.append(0xb8);
	hash.append(0x4f);
	hash.append(0xe5);
	hash.append(0x15);
	hash.append(0xa2);
	hash.append(0x5b);
	hash.append(0x8e);
	hash.append(0x6e);
	hash.append(0x82);
	hash.append(0xfa);
	hash.append(0xd4);
	hash.append(0x8a);
	hash.append(0x76);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x84);
	auth_data.append(0x68);
	auth_data.append(0xc0);
	auth_data.append(0x23);
	auth_data.append(0xa7);
	auth_data.append(0x5c);
	auth_data.append(0x50);
	auth_data.append(0x8e);
	auth_data.append(0xe3);
	auth_data.append(0xa9);
	auth_data.append(0x97);
	auth_data.append(0xc4);
	auth_data.append(0xc5);
	auth_data.append(0x23);
	auth_data.append(0x2);
	auth_data.append(0x40);
	auth_data.append(0xb9);
	auth_data.append(0x4c);
	auth_data.append(0xb2);
	auth_data.append(0x3d);
	auth_data.append(0xd5);
	auth_data.append(0xfa);
	auth_data.append(0xb2);
	auth_data.append(0x62);
	auth_data.append(0x9a);
	auth_data.append(0xfe);
	auth_data.append(0x1e);
	auth_data.append(0x61);
	auth_data.append(0x8);
	auth_data.append(0x3f);
	auth_data.append(0xb2);
	auth_data.append(0x32);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xc3);
	sig.append(0xfd);
	sig.append(0x4f);
	sig.append(0xeb);
	sig.append(0xf8);
	sig.append(0x3);
	sig.append(0x3b);
	sig.append(0xdf);
	sig.append(0x41);
	sig.append(0x6a);
	sig.append(0xbb);
	sig.append(0x4d);
	sig.append(0x7d);
	sig.append(0xa7);
	sig.append(0x32);
	sig.append(0xb6);
	sig.append(0xf7);
	sig.append(0x18);
	sig.append(0x79);
	sig.append(0x7c);
	sig.append(0xe1);
	sig.append(0xa);
	sig.append(0x9a);
	sig.append(0xf4);
	sig.append(0x2a);
	sig.append(0x79);
	sig.append(0xa2);
	sig.append(0x31);
	sig.append(0x23);
	sig.append(0x36);
	sig.append(0x79);
	sig.append(0x61);
	sig.append(0x46);
	sig.append(0xb);
	sig.append(0xba);
	sig.append(0xb2);
	sig.append(0x33);
	sig.append(0x2b);
	sig.append(0x15);
	sig.append(0xe8);
	sig.append(0x9a);
	sig.append(0x1f);
	sig.append(0x44);
	sig.append(0x2e);
	sig.append(0x2e);
	sig.append(0x6);
	sig.append(0x3);
	sig.append(0xef);
	sig.append(0xd5);
	sig.append(0x2d);
	sig.append(0xfd);
	sig.append(0xfd);
	sig.append(0x69);
	sig.append(0xb9);
	sig.append(0xb1);
	sig.append(0x71);
	sig.append(0xba);
	sig.append(0xd5);
	sig.append(0xfb);
	sig.append(0xec);
	sig.append(0x73);
	sig.append(0xf1);
	sig.append(0x4b);
	sig.append(0x94);
	let pk = PublicKey {
		 x: 77562917339750459740667948175673191602350822784737431142164527821481324910468, 
		 y: 38302464282221195286525651648026104452086023489753376473875989406122357536785
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_65(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xa4);
	hash.append(0x5d);
	hash.append(0xec);
	hash.append(0x91);
	hash.append(0xdc);
	hash.append(0xb6);
	hash.append(0xf6);
	hash.append(0xae);
	hash.append(0xa1);
	hash.append(0x94);
	hash.append(0x64);
	hash.append(0xc7);
	hash.append(0x9b);
	hash.append(0x89);
	hash.append(0xb8);
	hash.append(0xa3);
	hash.append(0x99);
	hash.append(0xea);
	hash.append(0xfc);
	hash.append(0xac);
	hash.append(0x33);
	hash.append(0x62);
	hash.append(0x51);
	hash.append(0xbb);
	hash.append(0x8d);
	hash.append(0x54);
	hash.append(0x4);
	hash.append(0xd8);
	hash.append(0xfa);
	hash.append(0x51);
	hash.append(0x3e);
	hash.append(0x80);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x5);
	auth_data.append(0xd2);
	auth_data.append(0xe0);
	auth_data.append(0x3e);
	auth_data.append(0xb2);
	auth_data.append(0x60);
	auth_data.append(0x39);
	auth_data.append(0xd1);
	auth_data.append(0x5c);
	auth_data.append(0x50);
	auth_data.append(0xc0);
	auth_data.append(0x28);
	auth_data.append(0xd);
	auth_data.append(0x4);
	auth_data.append(0xa0);
	auth_data.append(0x3d);
	auth_data.append(0xdd);
	auth_data.append(0x56);
	auth_data.append(0x2f);
	auth_data.append(0x13);
	auth_data.append(0x6c);
	auth_data.append(0xf7);
	auth_data.append(0xab);
	auth_data.append(0x3e);
	auth_data.append(0xff);
	auth_data.append(0xa8);
	auth_data.append(0x8b);
	auth_data.append(0xb2);
	auth_data.append(0xc);
	auth_data.append(0x8);
	auth_data.append(0xd3);
	auth_data.append(0x9a);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xd);
	sig.append(0xa3);
	sig.append(0x82);
	sig.append(0x61);
	sig.append(0xb2);
	sig.append(0x2f);
	sig.append(0xcc);
	sig.append(0xf8);
	sig.append(0x1b);
	sig.append(0x89);
	sig.append(0x57);
	sig.append(0x3a);
	sig.append(0xe2);
	sig.append(0x39);
	sig.append(0xa2);
	sig.append(0xfc);
	sig.append(0x80);
	sig.append(0x37);
	sig.append(0x99);
	sig.append(0x8b);
	sig.append(0xa3);
	sig.append(0x73);
	sig.append(0xdb);
	sig.append(0x7);
	sig.append(0xdf);
	sig.append(0x5);
	sig.append(0x50);
	sig.append(0xba);
	sig.append(0xf2);
	sig.append(0xcb);
	sig.append(0xe2);
	sig.append(0x7);
	sig.append(0xf8);
	sig.append(0x88);
	sig.append(0x25);
	sig.append(0xd9);
	sig.append(0x25);
	sig.append(0x65);
	sig.append(0xaf);
	sig.append(0x67);
	sig.append(0x61);
	sig.append(0x3b);
	sig.append(0xac);
	sig.append(0x91);
	sig.append(0xc2);
	sig.append(0xa6);
	sig.append(0x11);
	sig.append(0x1e);
	sig.append(0xc7);
	sig.append(0x40);
	sig.append(0x59);
	sig.append(0xa2);
	sig.append(0x4a);
	sig.append(0xb8);
	sig.append(0x79);
	sig.append(0x67);
	sig.append(0x6c);
	sig.append(0xb9);
	sig.append(0xb9);
	sig.append(0x47);
	sig.append(0x13);
	sig.append(0xe4);
	sig.append(0x7a);
	sig.append(0x9d);
	let pk = PublicKey {
		 x: 9397665932324130274667022678820799620223781224328910270209971068722748262523, 
		 y: 69168760075532472492440701163772573845314753914938899343590454393514895685970
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_66(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x4);
	hash.append(0xdf);
	hash.append(0x1e);
	hash.append(0xf);
	hash.append(0x99);
	hash.append(0x2d);
	hash.append(0xd);
	hash.append(0x29);
	hash.append(0x18);
	hash.append(0xc8);
	hash.append(0x4c);
	hash.append(0xc4);
	hash.append(0x4c);
	hash.append(0x8d);
	hash.append(0xf4);
	hash.append(0x4a);
	hash.append(0x1c);
	hash.append(0xa7);
	hash.append(0x74);
	hash.append(0x67);
	hash.append(0xa);
	hash.append(0xe3);
	hash.append(0x60);
	hash.append(0xbe);
	hash.append(0xda);
	hash.append(0x74);
	hash.append(0x27);
	hash.append(0x65);
	hash.append(0x3e);
	hash.append(0x1e);
	hash.append(0x3c);
	hash.append(0xe4);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xf2);
	auth_data.append(0x34);
	auth_data.append(0xcc);
	auth_data.append(0xab);
	auth_data.append(0x90);
	auth_data.append(0x63);
	auth_data.append(0x8b);
	auth_data.append(0xcf);
	auth_data.append(0x6a);
	auth_data.append(0x99);
	auth_data.append(0x38);
	auth_data.append(0x85);
	auth_data.append(0x45);
	auth_data.append(0xd0);
	auth_data.append(0x73);
	auth_data.append(0x44);
	auth_data.append(0x21);
	auth_data.append(0xdf);
	auth_data.append(0xd8);
	auth_data.append(0xdf);
	auth_data.append(0x45);
	auth_data.append(0x8b);
	auth_data.append(0xfb);
	auth_data.append(0xbc);
	auth_data.append(0xff);
	auth_data.append(0xc0);
	auth_data.append(0x26);
	auth_data.append(0xe1);
	auth_data.append(0x8b);
	auth_data.append(0x22);
	auth_data.append(0x30);
	auth_data.append(0x2b);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x53);
	sig.append(0xa);
	sig.append(0xf8);
	sig.append(0x8e);
	sig.append(0x8a);
	sig.append(0x40);
	sig.append(0x89);
	sig.append(0xfb);
	sig.append(0x76);
	sig.append(0x89);
	sig.append(0xca);
	sig.append(0x64);
	sig.append(0x44);
	sig.append(0x68);
	sig.append(0x7d);
	sig.append(0x18);
	sig.append(0xfc);
	sig.append(0xf3);
	sig.append(0x3c);
	sig.append(0xf);
	sig.append(0xda);
	sig.append(0x58);
	sig.append(0x14);
	sig.append(0xa4);
	sig.append(0x76);
	sig.append(0x89);
	sig.append(0xdb);
	sig.append(0x95);
	sig.append(0x40);
	sig.append(0x73);
	sig.append(0xfe);
	sig.append(0xd8);
	sig.append(0x4);
	sig.append(0xcc);
	sig.append(0x79);
	sig.append(0x91);
	sig.append(0xbf);
	sig.append(0xa7);
	sig.append(0xfc);
	sig.append(0x8e);
	sig.append(0xac);
	sig.append(0x68);
	sig.append(0x35);
	sig.append(0x6f);
	sig.append(0xc4);
	sig.append(0x92);
	sig.append(0xde);
	sig.append(0x47);
	sig.append(0x40);
	sig.append(0xb2);
	sig.append(0xdd);
	sig.append(0x4e);
	sig.append(0x14);
	sig.append(0x23);
	sig.append(0x20);
	sig.append(0x70);
	sig.append(0x6a);
	sig.append(0x33);
	sig.append(0x2e);
	sig.append(0x91);
	sig.append(0x42);
	sig.append(0xa8);
	sig.append(0x54);
	sig.append(0x14);
	let pk = PublicKey {
		 x: 95309457722789446050256501503139377078980506588874046195466706402721923323973, 
		 y: 88578834334496037387229906231110916906448701424556095224301301226248579891080
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_67(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x20);
	hash.append(0x7c);
	hash.append(0x25);
	hash.append(0xba);
	hash.append(0xae);
	hash.append(0xbb);
	hash.append(0x76);
	hash.append(0x2a);
	hash.append(0x9e);
	hash.append(0xe0);
	hash.append(0x15);
	hash.append(0xe7);
	hash.append(0xb7);
	hash.append(0xed);
	hash.append(0x92);
	hash.append(0x91);
	hash.append(0x38);
	hash.append(0xbd);
	hash.append(0x7c);
	hash.append(0x59);
	hash.append(0x1b);
	hash.append(0x19);
	hash.append(0xaf);
	hash.append(0x62);
	hash.append(0xa5);
	hash.append(0xf2);
	hash.append(0x1b);
	hash.append(0x35);
	hash.append(0xd5);
	hash.append(0x82);
	hash.append(0x73);
	hash.append(0xb3);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xdb);
	auth_data.append(0xdc);
	auth_data.append(0x62);
	auth_data.append(0xf6);
	auth_data.append(0x41);
	auth_data.append(0x15);
	auth_data.append(0xaa);
	auth_data.append(0x49);
	auth_data.append(0x52);
	auth_data.append(0x42);
	auth_data.append(0xb1);
	auth_data.append(0x4e);
	auth_data.append(0xfd);
	auth_data.append(0xd0);
	auth_data.append(0x73);
	auth_data.append(0x87);
	auth_data.append(0x23);
	auth_data.append(0xd7);
	auth_data.append(0x31);
	auth_data.append(0x7e);
	auth_data.append(0x80);
	auth_data.append(0xe1);
	auth_data.append(0xb6);
	auth_data.append(0x88);
	auth_data.append(0x2c);
	auth_data.append(0x6d);
	auth_data.append(0xa2);
	auth_data.append(0x19);
	auth_data.append(0x22);
	auth_data.append(0xe9);
	auth_data.append(0x7d);
	auth_data.append(0xc1);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xad);
	sig.append(0xc1);
	sig.append(0x33);
	sig.append(0x77);
	sig.append(0x87);
	sig.append(0x20);
	sig.append(0x4);
	sig.append(0xa5);
	sig.append(0x30);
	sig.append(0xc4);
	sig.append(0x3f);
	sig.append(0xa);
	sig.append(0xbe);
	sig.append(0xda);
	sig.append(0x83);
	sig.append(0x53);
	sig.append(0xa6);
	sig.append(0x6c);
	sig.append(0x67);
	sig.append(0xc1);
	sig.append(0x77);
	sig.append(0x29);
	sig.append(0x45);
	sig.append(0x3);
	sig.append(0x30);
	sig.append(0xd6);
	sig.append(0x91);
	sig.append(0x4e);
	sig.append(0x45);
	sig.append(0x31);
	sig.append(0x83);
	sig.append(0xaf);
	sig.append(0xc6);
	sig.append(0x20);
	sig.append(0xd9);
	sig.append(0x1f);
	sig.append(0xd3);
	sig.append(0x80);
	sig.append(0x85);
	sig.append(0x10);
	sig.append(0x3d);
	sig.append(0xe7);
	sig.append(0xd);
	sig.append(0x21);
	sig.append(0xb6);
	sig.append(0x9d);
	sig.append(0x6d);
	sig.append(0x16);
	sig.append(0x9d);
	sig.append(0x9f);
	sig.append(0x59);
	sig.append(0x7d);
	sig.append(0xd1);
	sig.append(0x3b);
	sig.append(0x11);
	sig.append(0xfb);
	sig.append(0x8b);
	sig.append(0x45);
	sig.append(0x7a);
	sig.append(0xba);
	sig.append(0x9e);
	sig.append(0x90);
	sig.append(0xb0);
	sig.append(0x1f);
	let pk = PublicKey {
		 x: 60930983255127291626729200641542094168283434327580991962237670187849315829942, 
		 y: 51531895262483823549881155350663356685175951757600863158444264257336692021554
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_68(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xd);
	hash.append(0x1e);
	hash.append(0xec);
	hash.append(0x21);
	hash.append(0xad);
	hash.append(0x57);
	hash.append(0xe2);
	hash.append(0xc7);
	hash.append(0xf5);
	hash.append(0xa9);
	hash.append(0x66);
	hash.append(0x7d);
	hash.append(0xd7);
	hash.append(0x81);
	hash.append(0x7b);
	hash.append(0xd2);
	hash.append(0xf0);
	hash.append(0x43);
	hash.append(0x44);
	hash.append(0x6c);
	hash.append(0x80);
	hash.append(0xe2);
	hash.append(0xf7);
	hash.append(0xf5);
	hash.append(0x68);
	hash.append(0x22);
	hash.append(0x7d);
	hash.append(0x2e);
	hash.append(0x4e);
	hash.append(0xbf);
	hash.append(0xc5);
	hash.append(0x17);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xcf);
	auth_data.append(0x7a);
	auth_data.append(0xcb);
	auth_data.append(0xd5);
	auth_data.append(0x11);
	auth_data.append(0x8b);
	auth_data.append(0x5c);
	auth_data.append(0x0);
	auth_data.append(0x68);
	auth_data.append(0x9c);
	auth_data.append(0x51);
	auth_data.append(0x28);
	auth_data.append(0x9d);
	auth_data.append(0x65);
	auth_data.append(0xd8);
	auth_data.append(0x99);
	auth_data.append(0xe9);
	auth_data.append(0x2e);
	auth_data.append(0x7);
	auth_data.append(0x64);
	auth_data.append(0xc8);
	auth_data.append(0xd4);
	auth_data.append(0xdf);
	auth_data.append(0x5b);
	auth_data.append(0x5c);
	auth_data.append(0x18);
	auth_data.append(0x26);
	auth_data.append(0x8c);
	auth_data.append(0xb7);
	auth_data.append(0xfb);
	auth_data.append(0x9e);
	auth_data.append(0x70);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xd6);
	sig.append(0x34);
	sig.append(0x88);
	sig.append(0x6d);
	sig.append(0x17);
	sig.append(0xcb);
	sig.append(0xf3);
	sig.append(0x60);
	sig.append(0x37);
	sig.append(0x93);
	sig.append(0x9d);
	sig.append(0x99);
	sig.append(0xec);
	sig.append(0x77);
	sig.append(0x75);
	sig.append(0x7b);
	sig.append(0x71);
	sig.append(0x26);
	sig.append(0x81);
	sig.append(0xa4);
	sig.append(0x43);
	sig.append(0xe4);
	sig.append(0xee);
	sig.append(0x95);
	sig.append(0x26);
	sig.append(0x8e);
	sig.append(0xcb);
	sig.append(0xe1);
	sig.append(0xfa);
	sig.append(0xe8);
	sig.append(0x8a);
	sig.append(0x93);
	sig.append(0x15);
	sig.append(0xf9);
	sig.append(0xd4);
	sig.append(0xfd);
	sig.append(0x3d);
	sig.append(0x7b);
	sig.append(0xba);
	sig.append(0xb8);
	sig.append(0x8b);
	sig.append(0x1a);
	sig.append(0x78);
	sig.append(0xca);
	sig.append(0x94);
	sig.append(0x1f);
	sig.append(0xfc);
	sig.append(0x6e);
	sig.append(0x52);
	sig.append(0xd0);
	sig.append(0x1b);
	sig.append(0xf9);
	sig.append(0x6f);
	sig.append(0xd1);
	sig.append(0xf3);
	sig.append(0x7b);
	sig.append(0x56);
	sig.append(0x35);
	sig.append(0x37);
	sig.append(0x6e);
	sig.append(0x2c);
	sig.append(0x70);
	sig.append(0x80);
	sig.append(0xb6);
	let pk = PublicKey {
		 x: 49127740105332522857029167078179877235804504893096921360234721977532866764385, 
		 y: 93951353786922033886732370704076817182670916841132967829406843271380119193014
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_69(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x70);
	hash.append(0x49);
	hash.append(0x17);
	hash.append(0x8b);
	hash.append(0x63);
	hash.append(0xa2);
	hash.append(0xde);
	hash.append(0xa);
	hash.append(0x9b);
	hash.append(0x19);
	hash.append(0xd2);
	hash.append(0xab);
	hash.append(0xf2);
	hash.append(0xba);
	hash.append(0xb4);
	hash.append(0x17);
	hash.append(0x7a);
	hash.append(0xa3);
	hash.append(0x8f);
	hash.append(0xe7);
	hash.append(0x43);
	hash.append(0x10);
	hash.append(0xd9);
	hash.append(0xd6);
	hash.append(0x43);
	hash.append(0x96);
	hash.append(0x9a);
	hash.append(0xc1);
	hash.append(0x20);
	hash.append(0xc8);
	hash.append(0xa3);
	hash.append(0xde);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xf7);
	auth_data.append(0x53);
	auth_data.append(0x6b);
	auth_data.append(0xb0);
	auth_data.append(0x73);
	auth_data.append(0x8a);
	auth_data.append(0x7e);
	auth_data.append(0xe4);
	auth_data.append(0x96);
	auth_data.append(0xdf);
	auth_data.append(0xd1);
	auth_data.append(0xc8);
	auth_data.append(0xa8);
	auth_data.append(0xfd);
	auth_data.append(0xff);
	auth_data.append(0xee);
	auth_data.append(0xb2);
	auth_data.append(0x53);
	auth_data.append(0xc3);
	auth_data.append(0xbe);
	auth_data.append(0xff);
	auth_data.append(0xc);
	auth_data.append(0xa9);
	auth_data.append(0xe1);
	auth_data.append(0xcf);
	auth_data.append(0x73);
	auth_data.append(0x56);
	auth_data.append(0xcb);
	auth_data.append(0x2c);
	auth_data.append(0x48);
	auth_data.append(0x74);
	auth_data.append(0x9);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x97);
	sig.append(0xe8);
	sig.append(0x6d);
	sig.append(0xcf);
	sig.append(0xd5);
	sig.append(0x75);
	sig.append(0x5);
	sig.append(0xd4);
	sig.append(0x6);
	sig.append(0x58);
	sig.append(0xf4);
	sig.append(0x64);
	sig.append(0x2e);
	sig.append(0xb3);
	sig.append(0x27);
	sig.append(0x9f);
	sig.append(0xe);
	sig.append(0xad);
	sig.append(0xdf);
	sig.append(0x40);
	sig.append(0xc1);
	sig.append(0x4c);
	sig.append(0xed);
	sig.append(0xcb);
	sig.append(0xcd);
	sig.append(0x99);
	sig.append(0x50);
	sig.append(0xc1);
	sig.append(0x22);
	sig.append(0x98);
	sig.append(0x54);
	sig.append(0x70);
	sig.append(0xcc);
	sig.append(0xca);
	sig.append(0x59);
	sig.append(0x48);
	sig.append(0xb3);
	sig.append(0x13);
	sig.append(0xad);
	sig.append(0xdc);
	sig.append(0xe8);
	sig.append(0xae);
	sig.append(0xae);
	sig.append(0x25);
	sig.append(0x83);
	sig.append(0xc);
	sig.append(0x54);
	sig.append(0xc);
	sig.append(0xc2);
	sig.append(0xfa);
	sig.append(0x16);
	sig.append(0xf2);
	sig.append(0xed);
	sig.append(0x46);
	sig.append(0xea);
	sig.append(0xa2);
	sig.append(0x1b);
	sig.append(0x18);
	sig.append(0xf5);
	sig.append(0xbf);
	sig.append(0xd9);
	sig.append(0xaf);
	sig.append(0x49);
	sig.append(0x3b);
	let pk = PublicKey {
		 x: 91421574458790833921656175170113567906771806388590119327588741048809502294427, 
		 y: 75477211511844135071413044440079009754355261154228410592997451558622914713060
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_70(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x14);
	hash.append(0x28);
	hash.append(0x5e);
	hash.append(0x2f);
	hash.append(0x25);
	hash.append(0x73);
	hash.append(0xda);
	hash.append(0xa1);
	hash.append(0x3f);
	hash.append(0xa9);
	hash.append(0xae);
	hash.append(0x88);
	hash.append(0x45);
	hash.append(0xdb);
	hash.append(0x4d);
	hash.append(0xf6);
	hash.append(0x37);
	hash.append(0xbc);
	hash.append(0x6f);
	hash.append(0x21);
	hash.append(0x1b);
	hash.append(0xad);
	hash.append(0x68);
	hash.append(0x95);
	hash.append(0xa1);
	hash.append(0xf3);
	hash.append(0x4b);
	hash.append(0x8);
	hash.append(0x82);
	hash.append(0xf9);
	hash.append(0xd2);
	hash.append(0x4c);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x84);
	auth_data.append(0xab);
	auth_data.append(0x38);
	auth_data.append(0x20);
	auth_data.append(0xbb);
	auth_data.append(0x65);
	auth_data.append(0xe1);
	auth_data.append(0x69);
	auth_data.append(0x66);
	auth_data.append(0xd3);
	auth_data.append(0x1c);
	auth_data.append(0x64);
	auth_data.append(0xca);
	auth_data.append(0x12);
	auth_data.append(0xa7);
	auth_data.append(0x20);
	auth_data.append(0x91);
	auth_data.append(0x8e);
	auth_data.append(0xdd);
	auth_data.append(0xd1);
	auth_data.append(0xf6);
	auth_data.append(0xb6);
	auth_data.append(0x93);
	auth_data.append(0x80);
	auth_data.append(0x3b);
	auth_data.append(0x9d);
	auth_data.append(0x9);
	auth_data.append(0xdf);
	auth_data.append(0xd3);
	auth_data.append(0xbc);
	auth_data.append(0x83);
	auth_data.append(0x9f);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xec);
	sig.append(0x25);
	sig.append(0x87);
	sig.append(0x13);
	sig.append(0x10);
	sig.append(0x51);
	sig.append(0x16);
	sig.append(0xe1);
	sig.append(0xd8);
	sig.append(0x8);
	sig.append(0x1b);
	sig.append(0x42);
	sig.append(0x52);
	sig.append(0x70);
	sig.append(0xb7);
	sig.append(0xcb);
	sig.append(0x71);
	sig.append(0x5e);
	sig.append(0x81);
	sig.append(0xe0);
	sig.append(0x11);
	sig.append(0xb);
	sig.append(0xbb);
	sig.append(0x42);
	sig.append(0x0);
	sig.append(0x4c);
	sig.append(0x4b);
	sig.append(0x69);
	sig.append(0x87);
	sig.append(0xf0);
	sig.append(0x31);
	sig.append(0xbd);
	sig.append(0xfd);
	sig.append(0x22);
	sig.append(0x63);
	sig.append(0x95);
	sig.append(0xf4);
	sig.append(0xd);
	sig.append(0xc7);
	sig.append(0xb);
	sig.append(0x96);
	sig.append(0xfc);
	sig.append(0x1d);
	sig.append(0x8c);
	sig.append(0xf2);
	sig.append(0x60);
	sig.append(0x21);
	sig.append(0x18);
	sig.append(0x1f);
	sig.append(0x3f);
	sig.append(0x3f);
	sig.append(0xb7);
	sig.append(0x2e);
	sig.append(0x9f);
	sig.append(0xd4);
	sig.append(0x62);
	sig.append(0x8);
	sig.append(0xbd);
	sig.append(0xbe);
	sig.append(0x26);
	sig.append(0x37);
	sig.append(0x99);
	sig.append(0x4d);
	sig.append(0x39);
	let pk = PublicKey {
		 x: 75033003629083364529201082688335505198065096045922309927878285346301529021758, 
		 y: 66988949083927739548117138386546743110577842789195440898652162086167455315186
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_71(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x98);
	hash.append(0x8d);
	hash.append(0x10);
	hash.append(0x10);
	hash.append(0xd9);
	hash.append(0xaf);
	hash.append(0xf7);
	hash.append(0x3a);
	hash.append(0x8e);
	hash.append(0x31);
	hash.append(0x37);
	hash.append(0x6d);
	hash.append(0x45);
	hash.append(0x0);
	hash.append(0x27);
	hash.append(0xfe);
	hash.append(0x49);
	hash.append(0x1b);
	hash.append(0x55);
	hash.append(0x79);
	hash.append(0x60);
	hash.append(0x49);
	hash.append(0x76);
	hash.append(0x2c);
	hash.append(0xb4);
	hash.append(0x75);
	hash.append(0x17);
	hash.append(0xb1);
	hash.append(0xb3);
	hash.append(0xcf);
	hash.append(0xba);
	hash.append(0xa1);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xa7);
	auth_data.append(0x85);
	auth_data.append(0xc2);
	auth_data.append(0xf8);
	auth_data.append(0x2e);
	auth_data.append(0x90);
	auth_data.append(0x41);
	auth_data.append(0xc8);
	auth_data.append(0xe8);
	auth_data.append(0xe5);
	auth_data.append(0x9c);
	auth_data.append(0x45);
	auth_data.append(0x5e);
	auth_data.append(0x6d);
	auth_data.append(0x5c);
	auth_data.append(0x86);
	auth_data.append(0x8);
	auth_data.append(0x95);
	auth_data.append(0xe);
	auth_data.append(0xa4);
	auth_data.append(0x2b);
	auth_data.append(0x78);
	auth_data.append(0xb7);
	auth_data.append(0x65);
	auth_data.append(0xe0);
	auth_data.append(0x39);
	auth_data.append(0xb1);
	auth_data.append(0x69);
	auth_data.append(0x28);
	auth_data.append(0x6b);
	auth_data.append(0x38);
	auth_data.append(0x35);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xb4);
	sig.append(0x9);
	sig.append(0x6d);
	sig.append(0xe7);
	sig.append(0xd8);
	sig.append(0xcc);
	sig.append(0xca);
	sig.append(0x1d);
	sig.append(0x25);
	sig.append(0xca);
	sig.append(0x35);
	sig.append(0xf9);
	sig.append(0xb8);
	sig.append(0x7c);
	sig.append(0x1b);
	sig.append(0x93);
	sig.append(0x5);
	sig.append(0xf8);
	sig.append(0xa8);
	sig.append(0x6f);
	sig.append(0x2);
	sig.append(0x86);
	sig.append(0xf8);
	sig.append(0x3b);
	sig.append(0x58);
	sig.append(0xde);
	sig.append(0x14);
	sig.append(0x24);
	sig.append(0x86);
	sig.append(0xa5);
	sig.append(0xde);
	sig.append(0xa0);
	sig.append(0x90);
	sig.append(0xa5);
	sig.append(0x51);
	sig.append(0x47);
	sig.append(0x8f);
	sig.append(0x39);
	sig.append(0x5a);
	sig.append(0x8b);
	sig.append(0xef);
	sig.append(0x37);
	sig.append(0x6c);
	sig.append(0xa8);
	sig.append(0x86);
	sig.append(0x95);
	sig.append(0xd6);
	sig.append(0x69);
	sig.append(0x36);
	sig.append(0x4);
	sig.append(0x6b);
	sig.append(0xef);
	sig.append(0xca);
	sig.append(0xf6);
	sig.append(0x4f);
	sig.append(0x2e);
	sig.append(0xf1);
	sig.append(0xf2);
	sig.append(0x76);
	sig.append(0x75);
	sig.append(0x15);
	sig.append(0xd2);
	sig.append(0xc9);
	sig.append(0x93);
	let pk = PublicKey {
		 x: 54127162990280161652008669573496464432564280743256351242491030789262987945601, 
		 y: 95127810662936338459913340402727848092430276900607657936407402301995905888257
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_72(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x21);
	hash.append(0x86);
	hash.append(0xbd);
	hash.append(0xb2);
	hash.append(0x5d);
	hash.append(0x66);
	hash.append(0x7c);
	hash.append(0xf0);
	hash.append(0xd8);
	hash.append(0xc9);
	hash.append(0x23);
	hash.append(0x6a);
	hash.append(0xef);
	hash.append(0x87);
	hash.append(0x79);
	hash.append(0xb7);
	hash.append(0x71);
	hash.append(0xa9);
	hash.append(0x59);
	hash.append(0xe1);
	hash.append(0xa4);
	hash.append(0x64);
	hash.append(0xb6);
	hash.append(0x60);
	hash.append(0xb5);
	hash.append(0xc8);
	hash.append(0x1d);
	hash.append(0x28);
	hash.append(0x35);
	hash.append(0x61);
	hash.append(0xf0);
	hash.append(0xa1);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xed);
	auth_data.append(0x40);
	auth_data.append(0x44);
	auth_data.append(0x18);
	auth_data.append(0xff);
	auth_data.append(0xda);
	auth_data.append(0x7a);
	auth_data.append(0x56);
	auth_data.append(0x9);
	auth_data.append(0x63);
	auth_data.append(0x5e);
	auth_data.append(0xa8);
	auth_data.append(0x6a);
	auth_data.append(0x68);
	auth_data.append(0x12);
	auth_data.append(0xc);
	auth_data.append(0xc5);
	auth_data.append(0xe9);
	auth_data.append(0xbb);
	auth_data.append(0xd4);
	auth_data.append(0x8e);
	auth_data.append(0x64);
	auth_data.append(0xf6);
	auth_data.append(0x85);
	auth_data.append(0x19);
	auth_data.append(0xa0);
	auth_data.append(0xca);
	auth_data.append(0xa6);
	auth_data.append(0x25);
	auth_data.append(0xcd);
	auth_data.append(0xef);
	auth_data.append(0x31);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x6f);
	sig.append(0xc8);
	sig.append(0x11);
	sig.append(0x11);
	sig.append(0x62);
	sig.append(0x8d);
	sig.append(0x76);
	sig.append(0x4f);
	sig.append(0x8f);
	sig.append(0x1f);
	sig.append(0xca);
	sig.append(0xa7);
	sig.append(0x9);
	sig.append(0x76);
	sig.append(0x97);
	sig.append(0xa1);
	sig.append(0x17);
	sig.append(0x67);
	sig.append(0x8c);
	sig.append(0xf8);
	sig.append(0x4f);
	sig.append(0x5a);
	sig.append(0x38);
	sig.append(0x50);
	sig.append(0xfd);
	sig.append(0x85);
	sig.append(0xf0);
	sig.append(0xe0);
	sig.append(0xe4);
	sig.append(0xc4);
	sig.append(0x7f);
	sig.append(0x46);
	sig.append(0xf4);
	sig.append(0x99);
	sig.append(0xd1);
	sig.append(0xbb);
	sig.append(0xcd);
	sig.append(0x7f);
	sig.append(0x34);
	sig.append(0x31);
	sig.append(0x3a);
	sig.append(0x3b);
	sig.append(0x24);
	sig.append(0x92);
	sig.append(0x7e);
	sig.append(0x6c);
	sig.append(0x92);
	sig.append(0x73);
	sig.append(0x50);
	sig.append(0x74);
	sig.append(0x5c);
	sig.append(0x65);
	sig.append(0x9d);
	sig.append(0x38);
	sig.append(0xae);
	sig.append(0xf0);
	sig.append(0x36);
	sig.append(0x15);
	sig.append(0x5d);
	sig.append(0xfd);
	sig.append(0xda);
	sig.append(0xda);
	sig.append(0xe3);
	sig.append(0xc2);
	let pk = PublicKey {
		 x: 89486403448514490931234922137952907971446288278071502710757232478040746977646, 
		 y: 13493518373502931759802246096112377794238434539951447587538942348820111372522
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_73(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x4);
	hash.append(0x73);
	hash.append(0x84);
	hash.append(0x73);
	hash.append(0x69);
	hash.append(0x68);
	hash.append(0xe0);
	hash.append(0x3a);
	hash.append(0x80);
	hash.append(0x9e);
	hash.append(0xe7);
	hash.append(0xa);
	hash.append(0x99);
	hash.append(0x58);
	hash.append(0x79);
	hash.append(0xfc);
	hash.append(0x11);
	hash.append(0x82);
	hash.append(0x9b);
	hash.append(0xae);
	hash.append(0x47);
	hash.append(0xee);
	hash.append(0x85);
	hash.append(0x37);
	hash.append(0xdf);
	hash.append(0xd9);
	hash.append(0xe0);
	hash.append(0xc6);
	hash.append(0x29);
	hash.append(0xb5);
	hash.append(0x6f);
	hash.append(0xab);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x5e);
	auth_data.append(0xae);
	auth_data.append(0xfd);
	auth_data.append(0x57);
	auth_data.append(0xab);
	auth_data.append(0xb9);
	auth_data.append(0xcf);
	auth_data.append(0x6a);
	auth_data.append(0x89);
	auth_data.append(0x4f);
	auth_data.append(0x79);
	auth_data.append(0xf3);
	auth_data.append(0x50);
	auth_data.append(0x41);
	auth_data.append(0xaa);
	auth_data.append(0x64);
	auth_data.append(0xc);
	auth_data.append(0x13);
	auth_data.append(0xe7);
	auth_data.append(0x39);
	auth_data.append(0x13);
	auth_data.append(0x8);
	auth_data.append(0xd0);
	auth_data.append(0xe4);
	auth_data.append(0x6d);
	auth_data.append(0x26);
	auth_data.append(0x8c);
	auth_data.append(0x4c);
	auth_data.append(0x27);
	auth_data.append(0xbd);
	auth_data.append(0x55);
	auth_data.append(0x8f);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x10);
	sig.append(0x26);
	sig.append(0xe5);
	sig.append(0x87);
	sig.append(0xb0);
	sig.append(0xfe);
	sig.append(0x8e);
	sig.append(0x2f);
	sig.append(0x33);
	sig.append(0xc6);
	sig.append(0x51);
	sig.append(0x21);
	sig.append(0x72);
	sig.append(0xfb);
	sig.append(0xd8);
	sig.append(0x1);
	sig.append(0x97);
	sig.append(0xa9);
	sig.append(0x22);
	sig.append(0x7e);
	sig.append(0x6d);
	sig.append(0xf0);
	sig.append(0x8b);
	sig.append(0xa3);
	sig.append(0x59);
	sig.append(0x80);
	sig.append(0x95);
	sig.append(0xf8);
	sig.append(0xc1);
	sig.append(0x51);
	sig.append(0xab);
	sig.append(0x7f);
	sig.append(0xc6);
	sig.append(0x80);
	sig.append(0xef);
	sig.append(0x72);
	sig.append(0xd3);
	sig.append(0x8d);
	sig.append(0x4a);
	sig.append(0xc5);
	sig.append(0x3c);
	sig.append(0x5a);
	sig.append(0x7a);
	sig.append(0xa5);
	sig.append(0x6c);
	sig.append(0x69);
	sig.append(0x5);
	sig.append(0x5b);
	sig.append(0xc6);
	sig.append(0xae);
	sig.append(0xe9);
	sig.append(0xad);
	sig.append(0x76);
	sig.append(0x94);
	sig.append(0xaf);
	sig.append(0x24);
	sig.append(0xbf);
	sig.append(0x79);
	sig.append(0x98);
	sig.append(0x9d);
	sig.append(0x6);
	sig.append(0xd1);
	sig.append(0x2d);
	sig.append(0xb4);
	let pk = PublicKey {
		 x: 39605271358129425840364835472046726059033284067201023452226515444225823208304, 
		 y: 108819199601934196210646181232382276735299914975208613405492088464405378183151
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_74(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x7);
	hash.append(0xf4);
	hash.append(0x3a);
	hash.append(0xe7);
	hash.append(0x65);
	hash.append(0xeb);
	hash.append(0x8e);
	hash.append(0xa9);
	hash.append(0xa2);
	hash.append(0x60);
	hash.append(0x5c);
	hash.append(0x4c);
	hash.append(0xee);
	hash.append(0x66);
	hash.append(0xea);
	hash.append(0x80);
	hash.append(0xf3);
	hash.append(0xf0);
	hash.append(0xd5);
	hash.append(0x1f);
	hash.append(0xe7);
	hash.append(0x2f);
	hash.append(0x40);
	hash.append(0xf5);
	hash.append(0x94);
	hash.append(0xaa);
	hash.append(0xb3);
	hash.append(0xb9);
	hash.append(0x42);
	hash.append(0xdc);
	hash.append(0x93);
	hash.append(0x3d);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x94);
	auth_data.append(0x34);
	auth_data.append(0xbd);
	auth_data.append(0xfe);
	auth_data.append(0xd5);
	auth_data.append(0xc);
	auth_data.append(0xdf);
	auth_data.append(0xfa);
	auth_data.append(0xad);
	auth_data.append(0x4b);
	auth_data.append(0x89);
	auth_data.append(0x35);
	auth_data.append(0x88);
	auth_data.append(0x89);
	auth_data.append(0xfd);
	auth_data.append(0x87);
	auth_data.append(0xbb);
	auth_data.append(0xda);
	auth_data.append(0x66);
	auth_data.append(0x36);
	auth_data.append(0xc3);
	auth_data.append(0xba);
	auth_data.append(0x25);
	auth_data.append(0xcf);
	auth_data.append(0xab);
	auth_data.append(0xb5);
	auth_data.append(0xc7);
	auth_data.append(0x76);
	auth_data.append(0xe9);
	auth_data.append(0x63);
	auth_data.append(0xb9);
	auth_data.append(0x90);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x89);
	sig.append(0x1f);
	sig.append(0xf0);
	sig.append(0xf9);
	sig.append(0x26);
	sig.append(0x3d);
	sig.append(0x2e);
	sig.append(0x61);
	sig.append(0xd5);
	sig.append(0xba);
	sig.append(0xfa);
	sig.append(0xd0);
	sig.append(0x52);
	sig.append(0xd9);
	sig.append(0x96);
	sig.append(0x5a);
	sig.append(0xbb);
	sig.append(0xf2);
	sig.append(0x23);
	sig.append(0x2a);
	sig.append(0xbd);
	sig.append(0x7b);
	sig.append(0xa);
	sig.append(0x68);
	sig.append(0x11);
	sig.append(0x34);
	sig.append(0x3c);
	sig.append(0xee);
	sig.append(0x2f);
	sig.append(0xbb);
	sig.append(0xc);
	sig.append(0x74);
	sig.append(0x56);
	sig.append(0x82);
	sig.append(0x17);
	sig.append(0xb6);
	sig.append(0x4e);
	sig.append(0xb9);
	sig.append(0x2c);
	sig.append(0xf0);
	sig.append(0x5b);
	sig.append(0x8e);
	sig.append(0x3a);
	sig.append(0xc3);
	sig.append(0x38);
	sig.append(0x85);
	sig.append(0x0);
	sig.append(0x50);
	sig.append(0x45);
	sig.append(0x7d);
	sig.append(0xd3);
	sig.append(0xac);
	sig.append(0x3d);
	sig.append(0x18);
	sig.append(0x55);
	sig.append(0x17);
	sig.append(0xe5);
	sig.append(0xf6);
	sig.append(0xfd);
	sig.append(0xa3);
	sig.append(0xe2);
	sig.append(0x63);
	sig.append(0x70);
	sig.append(0x81);
	let pk = PublicKey {
		 x: 6402270580515051674779327437576375588320629837197296915171367765239522704623, 
		 y: 96673546165983105652300014335966843928185284291885739505734580838951297556503
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_75(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x49);
	hash.append(0xad);
	hash.append(0x89);
	hash.append(0xc1);
	hash.append(0x1a);
	hash.append(0x14);
	hash.append(0x75);
	hash.append(0x5);
	hash.append(0x33);
	hash.append(0xcd);
	hash.append(0x55);
	hash.append(0xa4);
	hash.append(0x5);
	hash.append(0x5d);
	hash.append(0x2f);
	hash.append(0x90);
	hash.append(0x4b);
	hash.append(0xe3);
	hash.append(0x8e);
	hash.append(0x82);
	hash.append(0x8f);
	hash.append(0x46);
	hash.append(0x5);
	hash.append(0xf9);
	hash.append(0x26);
	hash.append(0x1);
	hash.append(0x4d);
	hash.append(0x56);
	hash.append(0xce);
	hash.append(0x19);
	hash.append(0xa2);
	hash.append(0x1b);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xc8);
	auth_data.append(0xcd);
	auth_data.append(0xb9);
	auth_data.append(0x74);
	auth_data.append(0x90);
	auth_data.append(0xb6);
	auth_data.append(0x4);
	auth_data.append(0x98);
	auth_data.append(0x7b);
	auth_data.append(0x51);
	auth_data.append(0xf6);
	auth_data.append(0x4d);
	auth_data.append(0x89);
	auth_data.append(0xbf);
	auth_data.append(0xa5);
	auth_data.append(0xb9);
	auth_data.append(0x6d);
	auth_data.append(0xa8);
	auth_data.append(0x33);
	auth_data.append(0x22);
	auth_data.append(0xf6);
	auth_data.append(0x7f);
	auth_data.append(0xd2);
	auth_data.append(0x12);
	auth_data.append(0x5f);
	auth_data.append(0x34);
	auth_data.append(0x50);
	auth_data.append(0x6a);
	auth_data.append(0xa);
	auth_data.append(0xa);
	auth_data.append(0x1a);
	auth_data.append(0x3f);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x89);
	sig.append(0xfd);
	sig.append(0xe4);
	sig.append(0xfb);
	sig.append(0xbb);
	sig.append(0x1a);
	sig.append(0xd1);
	sig.append(0x9f);
	sig.append(0x92);
	sig.append(0xc0);
	sig.append(0xaf);
	sig.append(0x7d);
	sig.append(0xdf);
	sig.append(0x6f);
	sig.append(0x7);
	sig.append(0x86);
	sig.append(0xf3);
	sig.append(0xb8);
	sig.append(0x4a);
	sig.append(0xdd);
	sig.append(0xda);
	sig.append(0x91);
	sig.append(0xc);
	sig.append(0xd4);
	sig.append(0x14);
	sig.append(0xe6);
	sig.append(0x0);
	sig.append(0x87);
	sig.append(0xc2);
	sig.append(0x6c);
	sig.append(0xe3);
	sig.append(0x99);
	sig.append(0xe9);
	sig.append(0xa3);
	sig.append(0x7c);
	sig.append(0x82);
	sig.append(0x97);
	sig.append(0x8);
	sig.append(0x1);
	sig.append(0x54);
	sig.append(0x30);
	sig.append(0x74);
	sig.append(0x94);
	sig.append(0xb2);
	sig.append(0xb3);
	sig.append(0xa6);
	sig.append(0xc1);
	sig.append(0x85);
	sig.append(0xd4);
	sig.append(0xee);
	sig.append(0x5c);
	sig.append(0x1a);
	sig.append(0x68);
	sig.append(0xca);
	sig.append(0x2);
	sig.append(0xc1);
	sig.append(0x94);
	sig.append(0xf6);
	sig.append(0xa8);
	sig.append(0xf0);
	sig.append(0xc0);
	sig.append(0x7b);
	sig.append(0xfe);
	sig.append(0xc5);
	let pk = PublicKey {
		 x: 73958969578193693817690733176712688424124582078551422656106334338979097817412, 
		 y: 54288821653629186282600253042764807964755624380379875906387883841551862775906
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_76(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x17);
	hash.append(0x3e);
	hash.append(0x84);
	hash.append(0x2f);
	hash.append(0x19);
	hash.append(0x82);
	hash.append(0x46);
	hash.append(0x8b);
	hash.append(0x94);
	hash.append(0xcf);
	hash.append(0xa7);
	hash.append(0xc);
	hash.append(0xc0);
	hash.append(0xab);
	hash.append(0xb5);
	hash.append(0x5d);
	hash.append(0x15);
	hash.append(0x6);
	hash.append(0x2a);
	hash.append(0x2b);
	hash.append(0xc4);
	hash.append(0x37);
	hash.append(0x3a);
	hash.append(0x32);
	hash.append(0xd0);
	hash.append(0x62);
	hash.append(0x78);
	hash.append(0xb7);
	hash.append(0x27);
	hash.append(0xc9);
	hash.append(0xf6);
	hash.append(0xb4);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x2e);
	auth_data.append(0x1e);
	auth_data.append(0x21);
	auth_data.append(0xc5);
	auth_data.append(0x85);
	auth_data.append(0x42);
	auth_data.append(0xba);
	auth_data.append(0xa2);
	auth_data.append(0x50);
	auth_data.append(0x6d);
	auth_data.append(0xad);
	auth_data.append(0xdf);
	auth_data.append(0x53);
	auth_data.append(0x2a);
	auth_data.append(0xab);
	auth_data.append(0x51);
	auth_data.append(0x90);
	auth_data.append(0x2b);
	auth_data.append(0xe6);
	auth_data.append(0xdf);
	auth_data.append(0x45);
	auth_data.append(0x51);
	auth_data.append(0x3e);
	auth_data.append(0x29);
	auth_data.append(0xc1);
	auth_data.append(0x20);
	auth_data.append(0x84);
	auth_data.append(0xca);
	auth_data.append(0x47);
	auth_data.append(0x2b);
	auth_data.append(0xe);
	auth_data.append(0x2d);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x1d);
	sig.append(0x10);
	sig.append(0x0);
	sig.append(0xfb);
	sig.append(0xef);
	sig.append(0x51);
	sig.append(0xa7);
	sig.append(0xbf);
	sig.append(0xa8);
	sig.append(0xc3);
	sig.append(0x46);
	sig.append(0x9f);
	sig.append(0xeb);
	sig.append(0xc7);
	sig.append(0x4);
	sig.append(0xfb);
	sig.append(0x5b);
	sig.append(0xba);
	sig.append(0xb6);
	sig.append(0xc9);
	sig.append(0x5b);
	sig.append(0xa6);
	sig.append(0xe);
	sig.append(0xcb);
	sig.append(0xf9);
	sig.append(0xb1);
	sig.append(0xe3);
	sig.append(0xf5);
	sig.append(0xd);
	sig.append(0x1f);
	sig.append(0x15);
	sig.append(0x26);
	sig.append(0xed);
	sig.append(0x8f);
	sig.append(0xd3);
	sig.append(0x7);
	sig.append(0x7);
	sig.append(0xdd);
	sig.append(0x78);
	sig.append(0x42);
	sig.append(0xf3);
	sig.append(0x64);
	sig.append(0x54);
	sig.append(0x56);
	sig.append(0xcb);
	sig.append(0xc8);
	sig.append(0x76);
	sig.append(0xa9);
	sig.append(0x4a);
	sig.append(0x4a);
	sig.append(0x3c);
	sig.append(0x3e);
	sig.append(0xc2);
	sig.append(0xda);
	sig.append(0xfd);
	sig.append(0xa3);
	sig.append(0xcd);
	sig.append(0xb5);
	sig.append(0xf3);
	sig.append(0xec);
	sig.append(0xfc);
	sig.append(0x3f);
	sig.append(0xf4);
	sig.append(0xbc);
	let pk = PublicKey {
		 x: 13939151193545713049160698623732078120459326315210892818918052892153128641653, 
		 y: 6127514288979993264324121154994133371251771157108267172380952363603558515775
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_77(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xd4);
	hash.append(0xee);
	hash.append(0xf2);
	hash.append(0x1f);
	hash.append(0xab);
	hash.append(0x93);
	hash.append(0x11);
	hash.append(0x15);
	hash.append(0xa7);
	hash.append(0x52);
	hash.append(0x20);
	hash.append(0x99);
	hash.append(0x99);
	hash.append(0xf9);
	hash.append(0xad);
	hash.append(0xe9);
	hash.append(0x1);
	hash.append(0x78);
	hash.append(0xa);
	hash.append(0xbd);
	hash.append(0x27);
	hash.append(0xf4);
	hash.append(0x76);
	hash.append(0x2a);
	hash.append(0x12);
	hash.append(0xec);
	hash.append(0xe5);
	hash.append(0x63);
	hash.append(0xeb);
	hash.append(0x26);
	hash.append(0xc8);
	hash.append(0x39);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x15);
	auth_data.append(0xc7);
	auth_data.append(0x99);
	auth_data.append(0x3a);
	auth_data.append(0x9f);
	auth_data.append(0x7a);
	auth_data.append(0x19);
	auth_data.append(0x61);
	auth_data.append(0x16);
	auth_data.append(0xec);
	auth_data.append(0x8a);
	auth_data.append(0x79);
	auth_data.append(0xea);
	auth_data.append(0xef);
	auth_data.append(0x19);
	auth_data.append(0xf0);
	auth_data.append(0x49);
	auth_data.append(0x7b);
	auth_data.append(0xf5);
	auth_data.append(0x71);
	auth_data.append(0xb0);
	auth_data.append(0xd1);
	auth_data.append(0x1f);
	auth_data.append(0x95);
	auth_data.append(0x12);
	auth_data.append(0x24);
	auth_data.append(0x28);
	auth_data.append(0xed);
	auth_data.append(0x92);
	auth_data.append(0xe9);
	auth_data.append(0x8a);
	auth_data.append(0x96);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x2a);
	sig.append(0xaa);
	sig.append(0xf8);
	sig.append(0x29);
	sig.append(0x9b);
	sig.append(0x20);
	sig.append(0x47);
	sig.append(0x95);
	sig.append(0x3d);
	sig.append(0x90);
	sig.append(0x28);
	sig.append(0xe7);
	sig.append(0xa3);
	sig.append(0x88);
	sig.append(0xbc);
	sig.append(0x9a);
	sig.append(0xf7);
	sig.append(0x33);
	sig.append(0xb9);
	sig.append(0x6f);
	sig.append(0xdf);
	sig.append(0x91);
	sig.append(0xc6);
	sig.append(0x10);
	sig.append(0xc9);
	sig.append(0xbb);
	sig.append(0x2);
	sig.append(0x2);
	sig.append(0x7e);
	sig.append(0xb8);
	sig.append(0xda);
	sig.append(0xd7);
	sig.append(0x10);
	sig.append(0xdd);
	sig.append(0x7a);
	sig.append(0x76);
	sig.append(0x32);
	sig.append(0xb7);
	sig.append(0xc4);
	sig.append(0x90);
	sig.append(0x8b);
	sig.append(0x6f);
	sig.append(0x4f);
	sig.append(0xca);
	sig.append(0xc7);
	sig.append(0xc3);
	sig.append(0xf0);
	sig.append(0x8c);
	sig.append(0x65);
	sig.append(0x67);
	sig.append(0xdd);
	sig.append(0xd2);
	sig.append(0x69);
	sig.append(0x66);
	sig.append(0x0);
	sig.append(0x8f);
	sig.append(0x11);
	sig.append(0x7b);
	sig.append(0x4e);
	sig.append(0x50);
	sig.append(0xf);
	sig.append(0x3d);
	sig.append(0xad);
	sig.append(0xcd);
	let pk = PublicKey {
		 x: 115061221701581198823974235586218948817563897998563797157255680041745458445442, 
		 y: 32618687729242252399671160755377067217244385401971877116241860371530011320140
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_78(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x9b);
	hash.append(0xab);
	hash.append(0x6e);
	hash.append(0xf4);
	hash.append(0xd4);
	hash.append(0x13);
	hash.append(0xaa);
	hash.append(0x3c);
	hash.append(0x9d);
	hash.append(0xc0);
	hash.append(0xc1);
	hash.append(0xc9);
	hash.append(0x89);
	hash.append(0x5);
	hash.append(0x94);
	hash.append(0x84);
	hash.append(0xf0);
	hash.append(0x42);
	hash.append(0x36);
	hash.append(0xb4);
	hash.append(0x73);
	hash.append(0x96);
	hash.append(0x25);
	hash.append(0x73);
	hash.append(0x65);
	hash.append(0xa8);
	hash.append(0x98);
	hash.append(0x46);
	hash.append(0x2d);
	hash.append(0xa);
	hash.append(0x7);
	hash.append(0x9d);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x7d);
	auth_data.append(0x3a);
	auth_data.append(0xb0);
	auth_data.append(0x20);
	auth_data.append(0xda);
	auth_data.append(0xa6);
	auth_data.append(0x62);
	auth_data.append(0x7);
	auth_data.append(0xd2);
	auth_data.append(0x2f);
	auth_data.append(0x25);
	auth_data.append(0xc4);
	auth_data.append(0x2e);
	auth_data.append(0xf7);
	auth_data.append(0x30);
	auth_data.append(0x88);
	auth_data.append(0xc0);
	auth_data.append(0x76);
	auth_data.append(0x1c);
	auth_data.append(0xb4);
	auth_data.append(0x27);
	auth_data.append(0x5);
	auth_data.append(0x5d);
	auth_data.append(0x3c);
	auth_data.append(0xd1);
	auth_data.append(0xa4);
	auth_data.append(0x92);
	auth_data.append(0x4c);
	auth_data.append(0x2a);
	auth_data.append(0xec);
	auth_data.append(0x4e);
	auth_data.append(0x96);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x29);
	sig.append(0xfa);
	sig.append(0x85);
	sig.append(0x3a);
	sig.append(0x91);
	sig.append(0xb8);
	sig.append(0xef);
	sig.append(0xc4);
	sig.append(0x3c);
	sig.append(0xbc);
	sig.append(0x68);
	sig.append(0x35);
	sig.append(0x86);
	sig.append(0xdb);
	sig.append(0x5f);
	sig.append(0x94);
	sig.append(0xa0);
	sig.append(0xd5);
	sig.append(0xee);
	sig.append(0xdf);
	sig.append(0x37);
	sig.append(0xa2);
	sig.append(0x1);
	sig.append(0x74);
	sig.append(0x59);
	sig.append(0xfb);
	sig.append(0x3c);
	sig.append(0xde);
	sig.append(0xcc);
	sig.append(0xb9);
	sig.append(0x64);
	sig.append(0xcf);
	sig.append(0xf0);
	sig.append(0xda);
	sig.append(0x96);
	sig.append(0xde);
	sig.append(0xf7);
	sig.append(0x4f);
	sig.append(0x21);
	sig.append(0x8a);
	sig.append(0xb9);
	sig.append(0x42);
	sig.append(0xc8);
	sig.append(0x7a);
	sig.append(0x10);
	sig.append(0x6c);
	sig.append(0x53);
	sig.append(0x4f);
	sig.append(0x7a);
	sig.append(0xe9);
	sig.append(0x5);
	sig.append(0x61);
	sig.append(0x32);
	sig.append(0x27);
	sig.append(0xda);
	sig.append(0x1b);
	sig.append(0x9b);
	sig.append(0x39);
	sig.append(0x8e);
	sig.append(0xd8);
	sig.append(0xd9);
	sig.append(0xb1);
	sig.append(0xf0);
	sig.append(0xed);
	let pk = PublicKey {
		 x: 47004518265583761325001517485839771782260928593166531231080387728454286118448, 
		 y: 56575792196580156440368320112782266234959162690425516142415402151656452635178
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_79(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x53);
	hash.append(0xeb);
	hash.append(0x6c);
	hash.append(0xfd);
	hash.append(0x4);
	hash.append(0xc6);
	hash.append(0x3a);
	hash.append(0x11);
	hash.append(0xf8);
	hash.append(0xbe);
	hash.append(0x5f);
	hash.append(0x1e);
	hash.append(0xb5);
	hash.append(0xf2);
	hash.append(0xdd);
	hash.append(0x9c);
	hash.append(0xc6);
	hash.append(0x2a);
	hash.append(0xab);
	hash.append(0x30);
	hash.append(0x99);
	hash.append(0xc1);
	hash.append(0xf5);
	hash.append(0xed);
	hash.append(0xc0);
	hash.append(0x55);
	hash.append(0xc3);
	hash.append(0x73);
	hash.append(0x65);
	hash.append(0x3d);
	hash.append(0xf3);
	hash.append(0xec);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x3f);
	auth_data.append(0x11);
	auth_data.append(0x2b);
	auth_data.append(0xe0);
	auth_data.append(0x36);
	auth_data.append(0x54);
	auth_data.append(0x2c);
	auth_data.append(0xee);
	auth_data.append(0x62);
	auth_data.append(0x15);
	auth_data.append(0x11);
	auth_data.append(0xb7);
	auth_data.append(0x66);
	auth_data.append(0x87);
	auth_data.append(0xc4);
	auth_data.append(0xf8);
	auth_data.append(0xda);
	auth_data.append(0x42);
	auth_data.append(0x79);
	auth_data.append(0xc7);
	auth_data.append(0x8c);
	auth_data.append(0x4e);
	auth_data.append(0x45);
	auth_data.append(0xbf);
	auth_data.append(0x97);
	auth_data.append(0xaf);
	auth_data.append(0xfc);
	auth_data.append(0x12);
	auth_data.append(0xfc);
	auth_data.append(0x27);
	auth_data.append(0xe4);
	auth_data.append(0x44);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x73);
	sig.append(0xde);
	sig.append(0xac);
	sig.append(0xd1);
	sig.append(0x77);
	sig.append(0xb4);
	sig.append(0xc7);
	sig.append(0xe);
	sig.append(0x8);
	sig.append(0x68);
	sig.append(0x7b);
	sig.append(0x75);
	sig.append(0x7c);
	sig.append(0x12);
	sig.append(0x9d);
	sig.append(0xb7);
	sig.append(0x57);
	sig.append(0xff);
	sig.append(0xbe);
	sig.append(0x5a);
	sig.append(0x1a);
	sig.append(0xb1);
	sig.append(0xc2);
	sig.append(0xf4);
	sig.append(0x75);
	sig.append(0x3b);
	sig.append(0xd2);
	sig.append(0xd);
	sig.append(0x6b);
	sig.append(0x17);
	sig.append(0xf8);
	sig.append(0x67);
	sig.append(0x31);
	sig.append(0xe);
	sig.append(0x1c);
	sig.append(0x11);
	sig.append(0x29);
	sig.append(0x25);
	sig.append(0x32);
	sig.append(0x30);
	sig.append(0xe8);
	sig.append(0xfb);
	sig.append(0x42);
	sig.append(0xff);
	sig.append(0x8d);
	sig.append(0xe);
	sig.append(0xb6);
	sig.append(0x9c);
	sig.append(0x93);
	sig.append(0x9c);
	sig.append(0xe1);
	sig.append(0x8c);
	sig.append(0x9e);
	sig.append(0x58);
	sig.append(0x84);
	sig.append(0xaa);
	sig.append(0x84);
	sig.append(0xbe);
	sig.append(0x9b);
	sig.append(0x23);
	sig.append(0xb8);
	sig.append(0x9c);
	sig.append(0x7a);
	sig.append(0x7f);
	let pk = PublicKey {
		 x: 26247026747128555532595618575773474062120741206025083876431424802776736283474, 
		 y: 76775535201809110034022466112504810938734415979340147148789367713405829709073
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_80(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x59);
	hash.append(0x87);
	hash.append(0x1e);
	hash.append(0xc0);
	hash.append(0xe6);
	hash.append(0x16);
	hash.append(0xf6);
	hash.append(0x97);
	hash.append(0x8f);
	hash.append(0xc7);
	hash.append(0x91);
	hash.append(0x93);
	hash.append(0x7e);
	hash.append(0x4b);
	hash.append(0x6c);
	hash.append(0xc0);
	hash.append(0xd3);
	hash.append(0x72);
	hash.append(0x2f);
	hash.append(0x86);
	hash.append(0x2d);
	hash.append(0xef);
	hash.append(0xaf);
	hash.append(0xf4);
	hash.append(0x25);
	hash.append(0xbb);
	hash.append(0x6b);
	hash.append(0x9);
	hash.append(0x9d);
	hash.append(0x14);
	hash.append(0x52);
	hash.append(0x38);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xb7);
	auth_data.append(0xb);
	auth_data.append(0x45);
	auth_data.append(0x11);
	auth_data.append(0xdb);
	auth_data.append(0x35);
	auth_data.append(0xd7);
	auth_data.append(0x29);
	auth_data.append(0x69);
	auth_data.append(0x4a);
	auth_data.append(0x5e);
	auth_data.append(0x69);
	auth_data.append(0x13);
	auth_data.append(0x98);
	auth_data.append(0xd7);
	auth_data.append(0x17);
	auth_data.append(0xcb);
	auth_data.append(0xb7);
	auth_data.append(0x46);
	auth_data.append(0xd5);
	auth_data.append(0xf);
	auth_data.append(0xe8);
	auth_data.append(0xc8);
	auth_data.append(0xa5);
	auth_data.append(0xa);
	auth_data.append(0x8e);
	auth_data.append(0xfd);
	auth_data.append(0x57);
	auth_data.append(0xdb);
	auth_data.append(0x44);
	auth_data.append(0xe5);
	auth_data.append(0xf8);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x36);
	sig.append(0xe2);
	sig.append(0xf3);
	sig.append(0x9f);
	sig.append(0x0);
	sig.append(0x10);
	sig.append(0x9e);
	sig.append(0x3e);
	sig.append(0x9e);
	sig.append(0xe);
	sig.append(0x79);
	sig.append(0x74);
	sig.append(0xe1);
	sig.append(0x58);
	sig.append(0xc);
	sig.append(0xd3);
	sig.append(0x4a);
	sig.append(0x5d);
	sig.append(0x42);
	sig.append(0xe7);
	sig.append(0x74);
	sig.append(0xee);
	sig.append(0x6a);
	sig.append(0x21);
	sig.append(0xe5);
	sig.append(0x7c);
	sig.append(0x8f);
	sig.append(0xcb);
	sig.append(0x3f);
	sig.append(0x31);
	sig.append(0xb9);
	sig.append(0xf5);
	sig.append(0x4e);
	sig.append(0x3a);
	sig.append(0xfe);
	sig.append(0x6b);
	sig.append(0xea);
	sig.append(0xbf);
	sig.append(0x6c);
	sig.append(0xb);
	sig.append(0xeb);
	sig.append(0x79);
	sig.append(0x4d);
	sig.append(0x38);
	sig.append(0x3d);
	sig.append(0x3d);
	sig.append(0x6b);
	sig.append(0x4f);
	sig.append(0xdf);
	sig.append(0x8);
	sig.append(0xd9);
	sig.append(0x34);
	sig.append(0x2c);
	sig.append(0xca);
	sig.append(0xfd);
	sig.append(0x68);
	sig.append(0x7c);
	sig.append(0x1e);
	sig.append(0x33);
	sig.append(0x2);
	sig.append(0x2a);
	sig.append(0x4c);
	sig.append(0x76);
	sig.append(0xae);
	let pk = PublicKey {
		 x: 88778937897784021833124758334439945599321968627307668135765755589703705914904, 
		 y: 61909934806925277739829751085036149090291551327411263093713905799816523568528
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_81(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xbe);
	hash.append(0x38);
	hash.append(0x90);
	hash.append(0xec);
	hash.append(0xed);
	hash.append(0xd9);
	hash.append(0x24);
	hash.append(0x28);
	hash.append(0xb8);
	hash.append(0x9e);
	hash.append(0xa);
	hash.append(0x11);
	hash.append(0x2);
	hash.append(0xd5);
	hash.append(0x3e);
	hash.append(0x20);
	hash.append(0x8d);
	hash.append(0x37);
	hash.append(0x9a);
	hash.append(0x9f);
	hash.append(0x50);
	hash.append(0xab);
	hash.append(0x41);
	hash.append(0xdd);
	hash.append(0x78);
	hash.append(0x71);
	hash.append(0xf3);
	hash.append(0xa3);
	hash.append(0xf4);
	hash.append(0x1a);
	hash.append(0x7b);
	hash.append(0xe9);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x52);
	auth_data.append(0xca);
	auth_data.append(0x3);
	auth_data.append(0xbb);
	auth_data.append(0x93);
	auth_data.append(0xed);
	auth_data.append(0xfa);
	auth_data.append(0xcd);
	auth_data.append(0xb3);
	auth_data.append(0x3b);
	auth_data.append(0x1e);
	auth_data.append(0xcf);
	auth_data.append(0x33);
	auth_data.append(0xbd);
	auth_data.append(0xf2);
	auth_data.append(0x10);
	auth_data.append(0xe3);
	auth_data.append(0xa4);
	auth_data.append(0x74);
	auth_data.append(0x71);
	auth_data.append(0x78);
	auth_data.append(0x44);
	auth_data.append(0x96);
	auth_data.append(0x1e);
	auth_data.append(0xd6);
	auth_data.append(0x5e);
	auth_data.append(0xa5);
	auth_data.append(0xcb);
	auth_data.append(0xf1);
	auth_data.append(0xd);
	auth_data.append(0xa7);
	auth_data.append(0x5);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x79);
	sig.append(0x88);
	sig.append(0xd8);
	sig.append(0xd0);
	sig.append(0xd0);
	sig.append(0xc5);
	sig.append(0xa0);
	sig.append(0xae);
	sig.append(0xb3);
	sig.append(0x1a);
	sig.append(0x34);
	sig.append(0xe0);
	sig.append(0xe);
	sig.append(0x1a);
	sig.append(0xf3);
	sig.append(0x54);
	sig.append(0x14);
	sig.append(0xf0);
	sig.append(0xdc);
	sig.append(0xf0);
	sig.append(0xa9);
	sig.append(0xb);
	sig.append(0x22);
	sig.append(0x5c);
	sig.append(0xd5);
	sig.append(0x92);
	sig.append(0x51);
	sig.append(0xf5);
	sig.append(0xb7);
	sig.append(0x47);
	sig.append(0x4a);
	sig.append(0xd4);
	sig.append(0xe3);
	sig.append(0xf5);
	sig.append(0x4e);
	sig.append(0x2);
	sig.append(0x61);
	sig.append(0x98);
	sig.append(0xc1);
	sig.append(0xfc);
	sig.append(0xd2);
	sig.append(0x92);
	sig.append(0x39);
	sig.append(0x59);
	sig.append(0x42);
	sig.append(0xf6);
	sig.append(0xa8);
	sig.append(0x3a);
	sig.append(0x49);
	sig.append(0x97);
	sig.append(0xfe);
	sig.append(0x4f);
	sig.append(0x51);
	sig.append(0x7d);
	sig.append(0x51);
	sig.append(0x4);
	sig.append(0x7d);
	sig.append(0x5a);
	sig.append(0x7e);
	sig.append(0xec);
	sig.append(0x27);
	sig.append(0x1c);
	sig.append(0xf);
	sig.append(0xfb);
	let pk = PublicKey {
		 x: 69738473502052363624535066527481096470206768075691260635841302075743310431643, 
		 y: 84868338119663255725923429798492671521480330108363156250617681156094367956074
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_82(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xee);
	hash.append(0x4d);
	hash.append(0x14);
	hash.append(0x41);
	hash.append(0xd5);
	hash.append(0xb0);
	hash.append(0xb1);
	hash.append(0x4e);
	hash.append(0xa);
	hash.append(0xf);
	hash.append(0xbe);
	hash.append(0xc2);
	hash.append(0x2d);
	hash.append(0x37);
	hash.append(0x86);
	hash.append(0xed);
	hash.append(0x3a);
	hash.append(0x7);
	hash.append(0xb4);
	hash.append(0xcf);
	hash.append(0xfc);
	hash.append(0x61);
	hash.append(0x41);
	hash.append(0x5c);
	hash.append(0xde);
	hash.append(0x44);
	hash.append(0x3d);
	hash.append(0x4f);
	hash.append(0xcd);
	hash.append(0x52);
	hash.append(0xd8);
	hash.append(0x33);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x5b);
	auth_data.append(0x54);
	auth_data.append(0xc9);
	auth_data.append(0x6c);
	auth_data.append(0x11);
	auth_data.append(0x92);
	auth_data.append(0x89);
	auth_data.append(0xe);
	auth_data.append(0x79);
	auth_data.append(0xe0);
	auth_data.append(0x2);
	auth_data.append(0x47);
	auth_data.append(0x8c);
	auth_data.append(0x2f);
	auth_data.append(0x27);
	auth_data.append(0x64);
	auth_data.append(0xe6);
	auth_data.append(0xb6);
	auth_data.append(0x85);
	auth_data.append(0xa5);
	auth_data.append(0x1);
	auth_data.append(0xfb);
	auth_data.append(0x52);
	auth_data.append(0xc5);
	auth_data.append(0x85);
	auth_data.append(0xa8);
	auth_data.append(0xdf);
	auth_data.append(0x5b);
	auth_data.append(0xbe);
	auth_data.append(0x33);
	auth_data.append(0x16);
	auth_data.append(0x73);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xd6);
	sig.append(0x4a);
	sig.append(0x8e);
	sig.append(0x49);
	sig.append(0x2e);
	sig.append(0xdb);
	sig.append(0x91);
	sig.append(0x9c);
	sig.append(0x1f);
	sig.append(0x46);
	sig.append(0x34);
	sig.append(0xa1);
	sig.append(0x37);
	sig.append(0x7a);
	sig.append(0x39);
	sig.append(0xa3);
	sig.append(0xac);
	sig.append(0x5e);
	sig.append(0xb7);
	sig.append(0x5e);
	sig.append(0xc6);
	sig.append(0xeb);
	sig.append(0xae);
	sig.append(0x24);
	sig.append(0x7d);
	sig.append(0xdb);
	sig.append(0x41);
	sig.append(0xd7);
	sig.append(0x4b);
	sig.append(0x3c);
	sig.append(0xb1);
	sig.append(0x47);
	sig.append(0xe2);
	sig.append(0xce);
	sig.append(0xdb);
	sig.append(0xfc);
	sig.append(0xc8);
	sig.append(0x43);
	sig.append(0xc9);
	sig.append(0x80);
	sig.append(0x66);
	sig.append(0x8f);
	sig.append(0xfb);
	sig.append(0x2);
	sig.append(0x4d);
	sig.append(0x41);
	sig.append(0xd7);
	sig.append(0x3a);
	sig.append(0xaf);
	sig.append(0xe2);
	sig.append(0x60);
	sig.append(0x67);
	sig.append(0x39);
	sig.append(0xdf);
	sig.append(0x41);
	sig.append(0x2);
	sig.append(0x8d);
	sig.append(0x5a);
	sig.append(0x13);
	sig.append(0xbf);
	sig.append(0xce);
	sig.append(0xfb);
	sig.append(0x57);
	sig.append(0x4a);
	let pk = PublicKey {
		 x: 90452951784024982371306276351778149449280986156522190999124861581514431503492, 
		 y: 63236607690806210068867068850667859406885449167843841579091821262894046217264
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_83(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x74);
	hash.append(0xa4);
	hash.append(0xb5);
	hash.append(0xe4);
	hash.append(0x41);
	hash.append(0x7d);
	hash.append(0xe);
	hash.append(0x17);
	hash.append(0x38);
	hash.append(0xe7);
	hash.append(0x95);
	hash.append(0xff);
	hash.append(0xc9);
	hash.append(0xfe);
	hash.append(0xdb);
	hash.append(0x26);
	hash.append(0xce);
	hash.append(0xf3);
	hash.append(0xb2);
	hash.append(0xf5);
	hash.append(0x89);
	hash.append(0x38);
	hash.append(0x39);
	hash.append(0xd3);
	hash.append(0xe4);
	hash.append(0xac);
	hash.append(0x37);
	hash.append(0x32);
	hash.append(0xc5);
	hash.append(0xa);
	hash.append(0xa2);
	hash.append(0x6a);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xdf);
	auth_data.append(0x26);
	auth_data.append(0xec);
	auth_data.append(0x28);
	auth_data.append(0x6b);
	auth_data.append(0x75);
	auth_data.append(0xea);
	auth_data.append(0x8);
	auth_data.append(0x7d);
	auth_data.append(0xc7);
	auth_data.append(0x25);
	auth_data.append(0xa5);
	auth_data.append(0xf2);
	auth_data.append(0x30);
	auth_data.append(0x41);
	auth_data.append(0x7f);
	auth_data.append(0x81);
	auth_data.append(0x54);
	auth_data.append(0x9c);
	auth_data.append(0x1e);
	auth_data.append(0x9c);
	auth_data.append(0x5d);
	auth_data.append(0x92);
	auth_data.append(0x40);
	auth_data.append(0x37);
	auth_data.append(0x0);
	auth_data.append(0x76);
	auth_data.append(0xa1);
	auth_data.append(0x96);
	auth_data.append(0xc8);
	auth_data.append(0x55);
	auth_data.append(0x6e);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x52);
	sig.append(0x4e);
	sig.append(0xc9);
	sig.append(0x70);
	sig.append(0x85);
	sig.append(0x9);
	sig.append(0x51);
	sig.append(0x65);
	sig.append(0x15);
	sig.append(0xe8);
	sig.append(0xfb);
	sig.append(0xa);
	sig.append(0x71);
	sig.append(0x9e);
	sig.append(0xb);
	sig.append(0x35);
	sig.append(0x40);
	sig.append(0x77);
	sig.append(0xaa);
	sig.append(0x79);
	sig.append(0x29);
	sig.append(0xcf);
	sig.append(0x6a);
	sig.append(0xba);
	sig.append(0x40);
	sig.append(0xeb);
	sig.append(0x6d);
	sig.append(0x88);
	sig.append(0x6);
	sig.append(0xa1);
	sig.append(0x35);
	sig.append(0x69);
	sig.append(0x22);
	sig.append(0x2f);
	sig.append(0xdd);
	sig.append(0xc6);
	sig.append(0x92);
	sig.append(0x55);
	sig.append(0xd7);
	sig.append(0xfb);
	sig.append(0x35);
	sig.append(0xfd);
	sig.append(0x7b);
	sig.append(0xe9);
	sig.append(0x88);
	sig.append(0xfb);
	sig.append(0x4c);
	sig.append(0x95);
	sig.append(0xd6);
	sig.append(0xe3);
	sig.append(0x1a);
	sig.append(0x80);
	sig.append(0x10);
	sig.append(0x3);
	sig.append(0x11);
	sig.append(0x8c);
	sig.append(0xd2);
	sig.append(0xa7);
	sig.append(0xaf);
	sig.append(0x4e);
	sig.append(0x5e);
	sig.append(0x2e);
	sig.append(0xea);
	sig.append(0xc4);
	let pk = PublicKey {
		 x: 31335645587414188032589108041679075334219315420888803126303679103610061456128, 
		 y: 101327317459592487693159417334393791074343275682962758711932406180826551103903
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_84(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xc4);
	hash.append(0x28);
	hash.append(0xb);
	hash.append(0x7c);
	hash.append(0x45);
	hash.append(0xa3);
	hash.append(0xea);
	hash.append(0x6d);
	hash.append(0x28);
	hash.append(0xa0);
	hash.append(0x47);
	hash.append(0xc7);
	hash.append(0x4c);
	hash.append(0xc1);
	hash.append(0xfe);
	hash.append(0xda);
	hash.append(0x61);
	hash.append(0x6f);
	hash.append(0x41);
	hash.append(0xd2);
	hash.append(0x5c);
	hash.append(0x4a);
	hash.append(0xb5);
	hash.append(0xf);
	hash.append(0x8a);
	hash.append(0x7c);
	hash.append(0xb2);
	hash.append(0x70);
	hash.append(0xd3);
	hash.append(0x72);
	hash.append(0x5d);
	hash.append(0xdc);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xb2);
	auth_data.append(0x2);
	auth_data.append(0xd5);
	auth_data.append(0x5f);
	auth_data.append(0xf6);
	auth_data.append(0xcc);
	auth_data.append(0xfc);
	auth_data.append(0x82);
	auth_data.append(0xc8);
	auth_data.append(0xe8);
	auth_data.append(0x8);
	auth_data.append(0x16);
	auth_data.append(0x13);
	auth_data.append(0x5f);
	auth_data.append(0xf5);
	auth_data.append(0x2a);
	auth_data.append(0x47);
	auth_data.append(0x1e);
	auth_data.append(0xef);
	auth_data.append(0x99);
	auth_data.append(0xe);
	auth_data.append(0x3c);
	auth_data.append(0x84);
	auth_data.append(0x5b);
	auth_data.append(0x99);
	auth_data.append(0x32);
	auth_data.append(0x59);
	auth_data.append(0x1e);
	auth_data.append(0x6);
	auth_data.append(0x3c);
	auth_data.append(0xa1);
	auth_data.append(0x56);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x96);
	sig.append(0xe);
	sig.append(0x6f);
	sig.append(0xfe);
	sig.append(0x1c);
	sig.append(0x8f);
	sig.append(0x19);
	sig.append(0x43);
	sig.append(0x9d);
	sig.append(0x10);
	sig.append(0x81);
	sig.append(0xaf);
	sig.append(0xa9);
	sig.append(0x8b);
	sig.append(0xb0);
	sig.append(0xe7);
	sig.append(0x69);
	sig.append(0x47);
	sig.append(0xf0);
	sig.append(0x6c);
	sig.append(0x29);
	sig.append(0xd2);
	sig.append(0x3f);
	sig.append(0x73);
	sig.append(0x12);
	sig.append(0xf7);
	sig.append(0xef);
	sig.append(0x9);
	sig.append(0x77);
	sig.append(0x85);
	sig.append(0x90);
	sig.append(0x7c);
	sig.append(0xa2);
	sig.append(0x4a);
	sig.append(0xa3);
	sig.append(0xa9);
	sig.append(0x41);
	sig.append(0x4b);
	sig.append(0x25);
	sig.append(0x23);
	sig.append(0x62);
	sig.append(0x3);
	sig.append(0x85);
	sig.append(0x57);
	sig.append(0xa);
	sig.append(0x21);
	sig.append(0x78);
	sig.append(0xcd);
	sig.append(0x35);
	sig.append(0x5f);
	sig.append(0x3d);
	sig.append(0x98);
	sig.append(0x88);
	sig.append(0x43);
	sig.append(0x7b);
	sig.append(0x26);
	sig.append(0xf0);
	sig.append(0x81);
	sig.append(0x13);
	sig.append(0x89);
	sig.append(0xcb);
	sig.append(0x5f);
	sig.append(0xb7);
	sig.append(0xa4);
	let pk = PublicKey {
		 x: 84377620197464469713692931095456346018440702101786744053009565161743893933671, 
		 y: 24381816752745070132439709383963473409923365254699675212013024541073588331305
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_85(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x2b);
	hash.append(0xfd);
	hash.append(0x53);
	hash.append(0xe0);
	hash.append(0x12);
	hash.append(0x1e);
	hash.append(0x7f);
	hash.append(0x5d);
	hash.append(0x34);
	hash.append(0xfb);
	hash.append(0xd);
	hash.append(0xcd);
	hash.append(0x5e);
	hash.append(0xa6);
	hash.append(0x41);
	hash.append(0xa2);
	hash.append(0xf3);
	hash.append(0x12);
	hash.append(0xc8);
	hash.append(0xca);
	hash.append(0xc2);
	hash.append(0x1f);
	hash.append(0x43);
	hash.append(0x5d);
	hash.append(0x59);
	hash.append(0x22);
	hash.append(0x24);
	hash.append(0xd5);
	hash.append(0x7b);
	hash.append(0x19);
	hash.append(0xdc);
	hash.append(0x34);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xa3);
	auth_data.append(0xe8);
	auth_data.append(0x2f);
	auth_data.append(0x88);
	auth_data.append(0x34);
	auth_data.append(0xe8);
	auth_data.append(0xf7);
	auth_data.append(0x73);
	auth_data.append(0x91);
	auth_data.append(0x29);
	auth_data.append(0x4);
	auth_data.append(0x7a);
	auth_data.append(0xb3);
	auth_data.append(0x8);
	auth_data.append(0xf9);
	auth_data.append(0x2e);
	auth_data.append(0xd2);
	auth_data.append(0x51);
	auth_data.append(0x3);
	auth_data.append(0x66);
	auth_data.append(0x7);
	auth_data.append(0x2d);
	auth_data.append(0x42);
	auth_data.append(0x7);
	auth_data.append(0xb1);
	auth_data.append(0x2b);
	auth_data.append(0x58);
	auth_data.append(0x51);
	auth_data.append(0x94);
	auth_data.append(0xbe);
	auth_data.append(0xd4);
	auth_data.append(0x9b);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x5c);
	sig.append(0xd);
	sig.append(0xed);
	sig.append(0x9a);
	sig.append(0x3e);
	sig.append(0x6f);
	sig.append(0x73);
	sig.append(0xf3);
	sig.append(0x36);
	sig.append(0xbb);
	sig.append(0x83);
	sig.append(0x48);
	sig.append(0x74);
	sig.append(0x2e);
	sig.append(0x5);
	sig.append(0xf0);
	sig.append(0xd0);
	sig.append(0xa5);
	sig.append(0x61);
	sig.append(0x47);
	sig.append(0x58);
	sig.append(0x88);
	sig.append(0x36);
	sig.append(0x54);
	sig.append(0x9a);
	sig.append(0xdb);
	sig.append(0x4e);
	sig.append(0xdf);
	sig.append(0xc2);
	sig.append(0xc8);
	sig.append(0xe1);
	sig.append(0x46);
	sig.append(0x3);
	sig.append(0xaf);
	sig.append(0xa7);
	sig.append(0x7e);
	sig.append(0x4f);
	sig.append(0xd8);
	sig.append(0xe3);
	sig.append(0xcc);
	sig.append(0xf5);
	sig.append(0x1f);
	sig.append(0x32);
	sig.append(0x74);
	sig.append(0x87);
	sig.append(0x2a);
	sig.append(0xa4);
	sig.append(0xa3);
	sig.append(0x98);
	sig.append(0x8e);
	sig.append(0xea);
	sig.append(0x92);
	sig.append(0xed);
	sig.append(0xee);
	sig.append(0x56);
	sig.append(0x28);
	sig.append(0xba);
	sig.append(0x22);
	sig.append(0x1d);
	sig.append(0x38);
	sig.append(0x41);
	sig.append(0x7c);
	sig.append(0x9f);
	sig.append(0x7);
	let pk = PublicKey {
		 x: 9386935931792985949497786748638814418540896694777960799459770926038613416671, 
		 y: 38460298445602081555654689675569229706439437553061630725249525585755800825734
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_86(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x61);
	hash.append(0xcd);
	hash.append(0xb6);
	hash.append(0x4f);
	hash.append(0x48);
	hash.append(0x8b);
	hash.append(0xfe);
	hash.append(0x4d);
	hash.append(0xc7);
	hash.append(0x19);
	hash.append(0xb3);
	hash.append(0xe3);
	hash.append(0xab);
	hash.append(0x8f);
	hash.append(0x88);
	hash.append(0x64);
	hash.append(0x5d);
	hash.append(0xc7);
	hash.append(0x7);
	hash.append(0xb8);
	hash.append(0xaf);
	hash.append(0xe8);
	hash.append(0x8);
	hash.append(0x60);
	hash.append(0xaf);
	hash.append(0xe0);
	hash.append(0xee);
	hash.append(0x4b);
	hash.append(0x14);
	hash.append(0xc5);
	hash.append(0xe4);
	hash.append(0xba);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x2b);
	auth_data.append(0x85);
	auth_data.append(0x76);
	auth_data.append(0x4e);
	auth_data.append(0x15);
	auth_data.append(0x53);
	auth_data.append(0x3c);
	auth_data.append(0x35);
	auth_data.append(0x6d);
	auth_data.append(0x1c);
	auth_data.append(0x1);
	auth_data.append(0x74);
	auth_data.append(0xa1);
	auth_data.append(0xe9);
	auth_data.append(0xf3);
	auth_data.append(0x6e);
	auth_data.append(0xb2);
	auth_data.append(0x14);
	auth_data.append(0xc5);
	auth_data.append(0x8e);
	auth_data.append(0x61);
	auth_data.append(0x15);
	auth_data.append(0xb7);
	auth_data.append(0x6);
	auth_data.append(0x2c);
	auth_data.append(0x95);
	auth_data.append(0x4e);
	auth_data.append(0xa3);
	auth_data.append(0xe);
	auth_data.append(0x13);
	auth_data.append(0xcb);
	auth_data.append(0xe5);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x70);
	sig.append(0x79);
	sig.append(0x43);
	sig.append(0x88);
	sig.append(0x21);
	sig.append(0x5);
	sig.append(0xd1);
	sig.append(0xc8);
	sig.append(0x51);
	sig.append(0x2f);
	sig.append(0xb9);
	sig.append(0x94);
	sig.append(0x43);
	sig.append(0x25);
	sig.append(0xe5);
	sig.append(0xc4);
	sig.append(0xc5);
	sig.append(0x94);
	sig.append(0x3);
	sig.append(0xec);
	sig.append(0x11);
	sig.append(0xb3);
	sig.append(0xb2);
	sig.append(0x17);
	sig.append(0xa9);
	sig.append(0x2b);
	sig.append(0x76);
	sig.append(0x5b);
	sig.append(0xca);
	sig.append(0xeb);
	sig.append(0x3);
	sig.append(0x4b);
	sig.append(0x44);
	sig.append(0x52);
	sig.append(0x5d);
	sig.append(0x99);
	sig.append(0x9d);
	sig.append(0xc0);
	sig.append(0x59);
	sig.append(0xfd);
	sig.append(0xba);
	sig.append(0x74);
	sig.append(0xab);
	sig.append(0x55);
	sig.append(0xd8);
	sig.append(0x7b);
	sig.append(0xd0);
	sig.append(0x27);
	sig.append(0xc0);
	sig.append(0xaf);
	sig.append(0x9f);
	sig.append(0xa9);
	sig.append(0x23);
	sig.append(0x34);
	sig.append(0x25);
	sig.append(0x53);
	sig.append(0x23);
	sig.append(0x6);
	sig.append(0x30);
	sig.append(0xdf);
	sig.append(0xd7);
	sig.append(0xf3);
	sig.append(0x80);
	sig.append(0x8b);
	let pk = PublicKey {
		 x: 10850532812001447391583287959805569832489890175300610812499587352126620124237, 
		 y: 113567727173917476865025818969701006264178673841166156764674387814629661931812
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_87(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xa4);
	hash.append(0x40);
	hash.append(0x18);
	hash.append(0x95);
	hash.append(0xf8);
	hash.append(0xc);
	hash.append(0xb0);
	hash.append(0x78);
	hash.append(0x68);
	hash.append(0xcd);
	hash.append(0x7f);
	hash.append(0x6c);
	hash.append(0x66);
	hash.append(0x68);
	hash.append(0x48);
	hash.append(0x2);
	hash.append(0xf4);
	hash.append(0x9d);
	hash.append(0x1e);
	hash.append(0x72);
	hash.append(0xf2);
	hash.append(0x51);
	hash.append(0xa3);
	hash.append(0xf6);
	hash.append(0xac);
	hash.append(0x65);
	hash.append(0xb2);
	hash.append(0x53);
	hash.append(0xc7);
	hash.append(0xa3);
	hash.append(0x5f);
	hash.append(0x92);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xb6);
	auth_data.append(0xc6);
	auth_data.append(0x8a);
	auth_data.append(0xaa);
	auth_data.append(0x1d);
	auth_data.append(0xed);
	auth_data.append(0x1e);
	auth_data.append(0x79);
	auth_data.append(0x52);
	auth_data.append(0x19);
	auth_data.append(0x3);
	auth_data.append(0xc3);
	auth_data.append(0xbc);
	auth_data.append(0xbc);
	auth_data.append(0x36);
	auth_data.append(0xb3);
	auth_data.append(0x6f);
	auth_data.append(0xab);
	auth_data.append(0x99);
	auth_data.append(0xef);
	auth_data.append(0x63);
	auth_data.append(0xa9);
	auth_data.append(0xb4);
	auth_data.append(0xab);
	auth_data.append(0xe7);
	auth_data.append(0xb5);
	auth_data.append(0x5);
	auth_data.append(0x19);
	auth_data.append(0x43);
	auth_data.append(0xef);
	auth_data.append(0x41);
	auth_data.append(0x5e);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x7);
	sig.append(0x25);
	sig.append(0x10);
	sig.append(0x73);
	sig.append(0xda);
	sig.append(0x68);
	sig.append(0xbc);
	sig.append(0xc0);
	sig.append(0xfe);
	sig.append(0xe9);
	sig.append(0x51);
	sig.append(0x90);
	sig.append(0xcf);
	sig.append(0xf0);
	sig.append(0x49);
	sig.append(0x1d);
	sig.append(0x69);
	sig.append(0x9);
	sig.append(0x7c);
	sig.append(0x7f);
	sig.append(0xa6);
	sig.append(0x1e);
	sig.append(0x56);
	sig.append(0xc9);
	sig.append(0x60);
	sig.append(0x6f);
	sig.append(0x1e);
	sig.append(0xf1);
	sig.append(0x78);
	sig.append(0x29);
	sig.append(0x61);
	sig.append(0xda);
	sig.append(0xea);
	sig.append(0x20);
	sig.append(0x46);
	sig.append(0x4a);
	sig.append(0x53);
	sig.append(0x94);
	sig.append(0xe7);
	sig.append(0x49);
	sig.append(0xec);
	sig.append(0xd3);
	sig.append(0x6c);
	sig.append(0xa8);
	sig.append(0x1);
	sig.append(0x3a);
	sig.append(0xb3);
	sig.append(0x69);
	sig.append(0x8a);
	sig.append(0x1e);
	sig.append(0x9d);
	sig.append(0x60);
	sig.append(0x72);
	sig.append(0xf);
	sig.append(0xf9);
	sig.append(0xad);
	sig.append(0xc3);
	sig.append(0xc9);
	sig.append(0x80);
	sig.append(0xcb);
	sig.append(0xf6);
	sig.append(0x7);
	sig.append(0x1f);
	sig.append(0x41);
	let pk = PublicKey {
		 x: 66297830906498672271463283185541503575548798800698438213088540519477061733881, 
		 y: 61635789176893280804174056528122765032165699141905494266859828564349352913282
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_88(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xab);
	hash.append(0xfc);
	hash.append(0x8e);
	hash.append(0x70);
	hash.append(0xd5);
	hash.append(0xb8);
	hash.append(0x14);
	hash.append(0xd2);
	hash.append(0x42);
	hash.append(0x62);
	hash.append(0xb5);
	hash.append(0x56);
	hash.append(0x6a);
	hash.append(0x13);
	hash.append(0xa6);
	hash.append(0xac);
	hash.append(0xca);
	hash.append(0x3d);
	hash.append(0xc3);
	hash.append(0xff);
	hash.append(0x12);
	hash.append(0xb1);
	hash.append(0x9d);
	hash.append(0xe9);
	hash.append(0x49);
	hash.append(0xa4);
	hash.append(0xab);
	hash.append(0xb2);
	hash.append(0xf3);
	hash.append(0xb);
	hash.append(0x89);
	hash.append(0x33);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x52);
	auth_data.append(0x3a);
	auth_data.append(0x84);
	auth_data.append(0x4);
	auth_data.append(0xa9);
	auth_data.append(0xc6);
	auth_data.append(0xa8);
	auth_data.append(0x45);
	auth_data.append(0xad);
	auth_data.append(0x46);
	auth_data.append(0x97);
	auth_data.append(0x79);
	auth_data.append(0x1c);
	auth_data.append(0x91);
	auth_data.append(0xcf);
	auth_data.append(0x3d);
	auth_data.append(0xe8);
	auth_data.append(0xa4);
	auth_data.append(0xeb);
	auth_data.append(0x30);
	auth_data.append(0x8e);
	auth_data.append(0xe6);
	auth_data.append(0x6f);
	auth_data.append(0x45);
	auth_data.append(0x16);
	auth_data.append(0xc0);
	auth_data.append(0x51);
	auth_data.append(0xcc);
	auth_data.append(0xe);
	auth_data.append(0x70);
	auth_data.append(0x81);
	auth_data.append(0xb9);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x24);
	sig.append(0xa5);
	sig.append(0x7);
	sig.append(0x6a);
	sig.append(0x30);
	sig.append(0xb2);
	sig.append(0xab);
	sig.append(0x42);
	sig.append(0xee);
	sig.append(0x40);
	sig.append(0xe4);
	sig.append(0x95);
	sig.append(0xf4);
	sig.append(0x33);
	sig.append(0xa);
	sig.append(0x6d);
	sig.append(0x4a);
	sig.append(0x39);
	sig.append(0x3f);
	sig.append(0x3a);
	sig.append(0x4d);
	sig.append(0xd2);
	sig.append(0xc0);
	sig.append(0x90);
	sig.append(0x2f);
	sig.append(0xf0);
	sig.append(0x1a);
	sig.append(0xa8);
	sig.append(0x3b);
	sig.append(0xb6);
	sig.append(0xf2);
	sig.append(0xb0);
	sig.append(0x3d);
	sig.append(0x9f);
	sig.append(0xf2);
	sig.append(0xcc);
	sig.append(0x4f);
	sig.append(0xc7);
	sig.append(0x9e);
	sig.append(0xeb);
	sig.append(0x72);
	sig.append(0x16);
	sig.append(0x9e);
	sig.append(0xb8);
	sig.append(0x6a);
	sig.append(0x1c);
	sig.append(0xe0);
	sig.append(0x5c);
	sig.append(0xf1);
	sig.append(0x3a);
	sig.append(0x65);
	sig.append(0xd6);
	sig.append(0x70);
	sig.append(0x39);
	sig.append(0x50);
	sig.append(0xe5);
	sig.append(0xc7);
	sig.append(0x52);
	sig.append(0x91);
	sig.append(0x85);
	sig.append(0xd1);
	sig.append(0xda);
	sig.append(0x73);
	sig.append(0x9c);
	let pk = PublicKey {
		 x: 4042458404897417807486461033932679751719880901778574897829358048660757180471, 
		 y: 72318456169710404725867898997617220189656626567562960965733106194839545460775
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_89(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xb8);
	hash.append(0x0);
	hash.append(0x72);
	hash.append(0x38);
	hash.append(0x5c);
	hash.append(0x4a);
	hash.append(0xd3);
	hash.append(0x92);
	hash.append(0x3f);
	hash.append(0x48);
	hash.append(0x94);
	hash.append(0x72);
	hash.append(0x59);
	hash.append(0x30);
	hash.append(0x31);
	hash.append(0xcb);
	hash.append(0x8d);
	hash.append(0x19);
	hash.append(0xf1);
	hash.append(0x2c);
	hash.append(0x8b);
	hash.append(0xd9);
	hash.append(0x33);
	hash.append(0x64);
	hash.append(0xbf);
	hash.append(0x4a);
	hash.append(0x56);
	hash.append(0x47);
	hash.append(0x82);
	hash.append(0x47);
	hash.append(0x75);
	hash.append(0xac);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x5e);
	auth_data.append(0x68);
	auth_data.append(0x2f);
	auth_data.append(0xa);
	auth_data.append(0x79);
	auth_data.append(0xab);
	auth_data.append(0x80);
	auth_data.append(0x64);
	auth_data.append(0x9b);
	auth_data.append(0x97);
	auth_data.append(0xa9);
	auth_data.append(0x6c);
	auth_data.append(0xbf);
	auth_data.append(0x24);
	auth_data.append(0xde);
	auth_data.append(0xa);
	auth_data.append(0xad);
	auth_data.append(0x61);
	auth_data.append(0x5c);
	auth_data.append(0xd2);
	auth_data.append(0x2a);
	auth_data.append(0x34);
	auth_data.append(0x14);
	auth_data.append(0x76);
	auth_data.append(0x9f);
	auth_data.append(0xbf);
	auth_data.append(0x87);
	auth_data.append(0xec);
	auth_data.append(0x7c);
	auth_data.append(0x7c);
	auth_data.append(0xe0);
	auth_data.append(0x2e);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x28);
	sig.append(0xb7);
	sig.append(0xfd);
	sig.append(0x82);
	sig.append(0x90);
	sig.append(0x71);
	sig.append(0xbb);
	sig.append(0xe5);
	sig.append(0x9c);
	sig.append(0xdd);
	sig.append(0x58);
	sig.append(0x4a);
	sig.append(0x6e);
	sig.append(0x7c);
	sig.append(0xaa);
	sig.append(0x3);
	sig.append(0xcd);
	sig.append(0x94);
	sig.append(0x41);
	sig.append(0xbd);
	sig.append(0x7);
	sig.append(0x5f);
	sig.append(0x9f);
	sig.append(0x10);
	sig.append(0xbd);
	sig.append(0xec);
	sig.append(0x8c);
	sig.append(0xf);
	sig.append(0xf1);
	sig.append(0xbf);
	sig.append(0x56);
	sig.append(0xe7);
	sig.append(0x75);
	sig.append(0xdb);
	sig.append(0xdc);
	sig.append(0x5e);
	sig.append(0xcf);
	sig.append(0x62);
	sig.append(0x12);
	sig.append(0xcd);
	sig.append(0xe6);
	sig.append(0x5d);
	sig.append(0xd5);
	sig.append(0x54);
	sig.append(0xb5);
	sig.append(0x26);
	sig.append(0x81);
	sig.append(0x52);
	sig.append(0x62);
	sig.append(0x58);
	sig.append(0xac);
	sig.append(0xa1);
	sig.append(0x3b);
	sig.append(0xc6);
	sig.append(0xd0);
	sig.append(0x28);
	sig.append(0xce);
	sig.append(0x6f);
	sig.append(0x46);
	sig.append(0x28);
	sig.append(0x72);
	sig.append(0x62);
	sig.append(0xd9);
	sig.append(0x19);
	let pk = PublicKey {
		 x: 17640219952249314708758798203783421399625447990449859858672887645303892598386, 
		 y: 80427981001686339629785787741359464507658146026099786352277240388464240068331
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_90(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xd6);
	hash.append(0x4b);
	hash.append(0x4);
	hash.append(0xaf);
	hash.append(0x2e);
	hash.append(0x5b);
	hash.append(0xf5);
	hash.append(0x26);
	hash.append(0x72);
	hash.append(0xed);
	hash.append(0xf1);
	hash.append(0xfb);
	hash.append(0xe1);
	hash.append(0xec);
	hash.append(0x2e);
	hash.append(0x75);
	hash.append(0x1b);
	hash.append(0x69);
	hash.append(0xb4);
	hash.append(0x9c);
	hash.append(0x6b);
	hash.append(0xc6);
	hash.append(0x56);
	hash.append(0x57);
	hash.append(0x68);
	hash.append(0xe6);
	hash.append(0x54);
	hash.append(0x8e);
	hash.append(0x4d);
	hash.append(0x68);
	hash.append(0x1);
	hash.append(0xa8);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x92);
	auth_data.append(0x52);
	auth_data.append(0xc5);
	auth_data.append(0x19);
	auth_data.append(0x22);
	auth_data.append(0xb0);
	auth_data.append(0x22);
	auth_data.append(0xed);
	auth_data.append(0x1a);
	auth_data.append(0x5c);
	auth_data.append(0xa);
	auth_data.append(0x5d);
	auth_data.append(0xbf);
	auth_data.append(0x3c);
	auth_data.append(0xe7);
	auth_data.append(0x84);
	auth_data.append(0x5b);
	auth_data.append(0x1d);
	auth_data.append(0x6c);
	auth_data.append(0x3f);
	auth_data.append(0xbb);
	auth_data.append(0xde);
	auth_data.append(0x77);
	auth_data.append(0xa9);
	auth_data.append(0xe8);
	auth_data.append(0xed);
	auth_data.append(0x6f);
	auth_data.append(0x1d);
	auth_data.append(0x8d);
	auth_data.append(0x9f);
	auth_data.append(0xf8);
	auth_data.append(0xd4);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x85);
	sig.append(0xfd);
	sig.append(0xae);
	sig.append(0xff);
	sig.append(0x91);
	sig.append(0x59);
	sig.append(0x27);
	sig.append(0xfc);
	sig.append(0x3f);
	sig.append(0xed);
	sig.append(0x23);
	sig.append(0x52);
	sig.append(0x54);
	sig.append(0x2a);
	sig.append(0x87);
	sig.append(0xb5);
	sig.append(0x4a);
	sig.append(0x9);
	sig.append(0xcd);
	sig.append(0xd8);
	sig.append(0x23);
	sig.append(0x89);
	sig.append(0x66);
	sig.append(0x9b);
	sig.append(0xa6);
	sig.append(0xcc);
	sig.append(0x8b);
	sig.append(0x25);
	sig.append(0xba);
	sig.append(0xec);
	sig.append(0xac);
	sig.append(0x3d);
	sig.append(0x4f);
	sig.append(0x33);
	sig.append(0x5f);
	sig.append(0x2b);
	sig.append(0x1a);
	sig.append(0x54);
	sig.append(0xd7);
	sig.append(0xe0);
	sig.append(0xc8);
	sig.append(0x54);
	sig.append(0xe0);
	sig.append(0x1c);
	sig.append(0xe1);
	sig.append(0x6c);
	sig.append(0x5c);
	sig.append(0x57);
	sig.append(0x3a);
	sig.append(0x6e);
	sig.append(0xf1);
	sig.append(0x10);
	sig.append(0xec);
	sig.append(0xa);
	sig.append(0x5e);
	sig.append(0xf3);
	sig.append(0xde);
	sig.append(0x8c);
	sig.append(0xbd);
	sig.append(0xc2);
	sig.append(0xe0);
	sig.append(0xba);
	sig.append(0xbe);
	sig.append(0x20);
	let pk = PublicKey {
		 x: 60756970383119796315549750509554111073826446668129365376917080204014713785486, 
		 y: 114496204582356269059248270342199169392009036243503610218061358327655916306682
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_91(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xd1);
	hash.append(0x46);
	hash.append(0x52);
	hash.append(0x8);
	hash.append(0x86);
	hash.append(0x68);
	hash.append(0x9);
	hash.append(0xc7);
	hash.append(0x3f);
	hash.append(0xec);
	hash.append(0x9b);
	hash.append(0x4f);
	hash.append(0x7);
	hash.append(0x5c);
	hash.append(0x74);
	hash.append(0xb9);
	hash.append(0xb1);
	hash.append(0xd5);
	hash.append(0xc2);
	hash.append(0x41);
	hash.append(0xa5);
	hash.append(0xcf);
	hash.append(0xeb);
	hash.append(0x98);
	hash.append(0xdc);
	hash.append(0x6a);
	hash.append(0x8);
	hash.append(0xd8);
	hash.append(0x7a);
	hash.append(0x13);
	hash.append(0x5e);
	hash.append(0x2e);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x3b);
	auth_data.append(0xa3);
	auth_data.append(0xc8);
	auth_data.append(0xcf);
	auth_data.append(0xd5);
	auth_data.append(0x3);
	auth_data.append(0x57);
	auth_data.append(0xc7);
	auth_data.append(0xd9);
	auth_data.append(0x65);
	auth_data.append(0x78);
	auth_data.append(0x6b);
	auth_data.append(0xaf);
	auth_data.append(0xfc);
	auth_data.append(0x12);
	auth_data.append(0x81);
	auth_data.append(0xe6);
	auth_data.append(0xea);
	auth_data.append(0x80);
	auth_data.append(0xa9);
	auth_data.append(0xf5);
	auth_data.append(0x82);
	auth_data.append(0xf9);
	auth_data.append(0x12);
	auth_data.append(0x8e);
	auth_data.append(0x81);
	auth_data.append(0x25);
	auth_data.append(0x91);
	auth_data.append(0xb5);
	auth_data.append(0x48);
	auth_data.append(0x6c);
	auth_data.append(0xca);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x49);
	sig.append(0x8b);
	sig.append(0x5);
	sig.append(0x0);
	sig.append(0xd5);
	sig.append(0x58);
	sig.append(0xdb);
	sig.append(0xc4);
	sig.append(0xb7);
	sig.append(0x55);
	sig.append(0x6a);
	sig.append(0xdd);
	sig.append(0x3d);
	sig.append(0x55);
	sig.append(0xcc);
	sig.append(0xa2);
	sig.append(0x23);
	sig.append(0x98);
	sig.append(0x76);
	sig.append(0xcb);
	sig.append(0x71);
	sig.append(0x97);
	sig.append(0xe0);
	sig.append(0x3a);
	sig.append(0x2d);
	sig.append(0x43);
	sig.append(0xc7);
	sig.append(0x86);
	sig.append(0xac);
	sig.append(0xfd);
	sig.append(0xac);
	sig.append(0x71);
	sig.append(0x69);
	sig.append(0xad);
	sig.append(0x3b);
	sig.append(0x16);
	sig.append(0x98);
	sig.append(0x9);
	sig.append(0xa4);
	sig.append(0x6a);
	sig.append(0x61);
	sig.append(0xa);
	sig.append(0x43);
	sig.append(0x64);
	sig.append(0x27);
	sig.append(0x78);
	sig.append(0x86);
	sig.append(0xa1);
	sig.append(0xc7);
	sig.append(0x1b);
	sig.append(0xdf);
	sig.append(0x91);
	sig.append(0xec);
	sig.append(0x4d);
	sig.append(0xc3);
	sig.append(0x2d);
	sig.append(0x9c);
	sig.append(0xe1);
	sig.append(0xc);
	sig.append(0xb7);
	sig.append(0xed);
	sig.append(0x4c);
	sig.append(0x76);
	sig.append(0x23);
	let pk = PublicKey {
		 x: 9334860216956801845232985395755109176959103679321110127386222366006130464614, 
		 y: 37193032713435596038908400782812512409668800672675266391267435580112937761043
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_92(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xf0);
	hash.append(0x36);
	hash.append(0x8a);
	hash.append(0x8f);
	hash.append(0x50);
	hash.append(0xe5);
	hash.append(0x47);
	hash.append(0xb4);
	hash.append(0xe8);
	hash.append(0xf8);
	hash.append(0xcd);
	hash.append(0x2c);
	hash.append(0x63);
	hash.append(0xa6);
	hash.append(0x8f);
	hash.append(0xac);
	hash.append(0x81);
	hash.append(0x39);
	hash.append(0xb6);
	hash.append(0xc6);
	hash.append(0x2b);
	hash.append(0x23);
	hash.append(0x3);
	hash.append(0x7d);
	hash.append(0x87);
	hash.append(0xb5);
	hash.append(0xea);
	hash.append(0xcf);
	hash.append(0x8d);
	hash.append(0x83);
	hash.append(0x33);
	hash.append(0xee);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xc9);
	auth_data.append(0x6f);
	auth_data.append(0x47);
	auth_data.append(0x9);
	auth_data.append(0xfe);
	auth_data.append(0xd5);
	auth_data.append(0x84);
	auth_data.append(0x12);
	auth_data.append(0x2f);
	auth_data.append(0xe4);
	auth_data.append(0x10);
	auth_data.append(0xb4);
	auth_data.append(0xd1);
	auth_data.append(0x4c);
	auth_data.append(0x0);
	auth_data.append(0x17);
	auth_data.append(0x7c);
	auth_data.append(0xec);
	auth_data.append(0x0);
	auth_data.append(0xbf);
	auth_data.append(0x67);
	auth_data.append(0xb3);
	auth_data.append(0x4d);
	auth_data.append(0x53);
	auth_data.append(0x37);
	auth_data.append(0x2a);
	auth_data.append(0x25);
	auth_data.append(0xa7);
	auth_data.append(0x90);
	auth_data.append(0x56);
	auth_data.append(0x24);
	auth_data.append(0x79);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xa4);
	sig.append(0x90);
	sig.append(0xe1);
	sig.append(0xc5);
	sig.append(0x76);
	sig.append(0x80);
	sig.append(0xe);
	sig.append(0xec);
	sig.append(0xa7);
	sig.append(0x2a);
	sig.append(0x7f);
	sig.append(0xaa);
	sig.append(0x2f);
	sig.append(0x12);
	sig.append(0x39);
	sig.append(0xb9);
	sig.append(0xc5);
	sig.append(0x2f);
	sig.append(0xfb);
	sig.append(0xd3);
	sig.append(0x77);
	sig.append(0x49);
	sig.append(0x92);
	sig.append(0xc9);
	sig.append(0xb);
	sig.append(0x14);
	sig.append(0x5f);
	sig.append(0xbb);
	sig.append(0xfd);
	sig.append(0x46);
	sig.append(0x21);
	sig.append(0x31);
	sig.append(0x41);
	sig.append(0x3c);
	sig.append(0x45);
	sig.append(0x38);
	sig.append(0xb5);
	sig.append(0xbe);
	sig.append(0x35);
	sig.append(0x98);
	sig.append(0x2d);
	sig.append(0x17);
	sig.append(0xcb);
	sig.append(0x32);
	sig.append(0x39);
	sig.append(0xab);
	sig.append(0xb8);
	sig.append(0x2c);
	sig.append(0xa4);
	sig.append(0xe7);
	sig.append(0x37);
	sig.append(0xad);
	sig.append(0x77);
	sig.append(0x3e);
	sig.append(0x5b);
	sig.append(0x5d);
	sig.append(0x17);
	sig.append(0xc2);
	sig.append(0x36);
	sig.append(0x62);
	sig.append(0x87);
	sig.append(0x64);
	sig.append(0x97);
	sig.append(0xba);
	let pk = PublicKey {
		 x: 8338344132713675479772066294274609680495623089581842660899099414406688520801, 
		 y: 110419916260007557748407693881426894690605346701343492526570460342503791364198
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_93(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xb2);
	hash.append(0x9b);
	hash.append(0x68);
	hash.append(0xd8);
	hash.append(0xa6);
	hash.append(0x50);
	hash.append(0xa9);
	hash.append(0xfe);
	hash.append(0xa5);
	hash.append(0xd9);
	hash.append(0xdb);
	hash.append(0xaf);
	hash.append(0xc6);
	hash.append(0x58);
	hash.append(0x22);
	hash.append(0xf8);
	hash.append(0xb);
	hash.append(0x3d);
	hash.append(0xc3);
	hash.append(0x19);
	hash.append(0xe2);
	hash.append(0x3a);
	hash.append(0x1);
	hash.append(0x57);
	hash.append(0x47);
	hash.append(0x12);
	hash.append(0x8);
	hash.append(0xf3);
	hash.append(0xe1);
	hash.append(0xa7);
	hash.append(0x17);
	hash.append(0x51);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x1f);
	auth_data.append(0x2a);
	auth_data.append(0x12);
	auth_data.append(0xab);
	auth_data.append(0xd6);
	auth_data.append(0x9e);
	auth_data.append(0x6b);
	auth_data.append(0xac);
	auth_data.append(0xe4);
	auth_data.append(0xc9);
	auth_data.append(0x72);
	auth_data.append(0xc);
	auth_data.append(0x6c);
	auth_data.append(0x8a);
	auth_data.append(0x1e);
	auth_data.append(0xaa);
	auth_data.append(0x2f);
	auth_data.append(0x3b);
	auth_data.append(0xd7);
	auth_data.append(0x1e);
	auth_data.append(0x47);
	auth_data.append(0xb9);
	auth_data.append(0xde);
	auth_data.append(0x65);
	auth_data.append(0xcd);
	auth_data.append(0x2);
	auth_data.append(0xa9);
	auth_data.append(0x8c);
	auth_data.append(0x90);
	auth_data.append(0x9b);
	auth_data.append(0x71);
	auth_data.append(0xf6);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xfe);
	sig.append(0x48);
	sig.append(0x85);
	sig.append(0x11);
	sig.append(0x23);
	sig.append(0xb2);
	sig.append(0xc4);
	sig.append(0x77);
	sig.append(0x2a);
	sig.append(0x7a);
	sig.append(0x9d);
	sig.append(0x24);
	sig.append(0xd2);
	sig.append(0xbb);
	sig.append(0xf1);
	sig.append(0x82);
	sig.append(0x58);
	sig.append(0x8b);
	sig.append(0x83);
	sig.append(0x36);
	sig.append(0xbc);
	sig.append(0x64);
	sig.append(0xe6);
	sig.append(0x22);
	sig.append(0x52);
	sig.append(0xae);
	sig.append(0x18);
	sig.append(0x8a);
	sig.append(0x33);
	sig.append(0xa6);
	sig.append(0x91);
	sig.append(0xb6);
	sig.append(0x52);
	sig.append(0x86);
	sig.append(0x61);
	sig.append(0x51);
	sig.append(0xa0);
	sig.append(0x34);
	sig.append(0x46);
	sig.append(0x56);
	sig.append(0x1);
	sig.append(0xf6);
	sig.append(0x82);
	sig.append(0xc5);
	sig.append(0xb3);
	sig.append(0xc9);
	sig.append(0x7);
	sig.append(0x8a);
	sig.append(0xdf);
	sig.append(0x47);
	sig.append(0x9e);
	sig.append(0xd0);
	sig.append(0x4f);
	sig.append(0xc2);
	sig.append(0x9f);
	sig.append(0xa8);
	sig.append(0x7f);
	sig.append(0xd8);
	sig.append(0xf);
	sig.append(0x5a);
	sig.append(0x5b);
	sig.append(0xc2);
	sig.append(0xe0);
	sig.append(0xe6);
	let pk = PublicKey {
		 x: 101698107124975192324387062371495934909031397875760893747786011739110569472936, 
		 y: 68867867341930876374439085797211878743476376512879485097791018955985775324420
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_94(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x15);
	hash.append(0x1);
	hash.append(0x88);
	hash.append(0x40);
	hash.append(0xfe);
	hash.append(0x76);
	hash.append(0x65);
	hash.append(0x79);
	hash.append(0x8);
	hash.append(0x57);
	hash.append(0x34);
	hash.append(0xda);
	hash.append(0x59);
	hash.append(0x2d);
	hash.append(0x8d);
	hash.append(0x79);
	hash.append(0x55);
	hash.append(0x43);
	hash.append(0x5d);
	hash.append(0xea);
	hash.append(0xf3);
	hash.append(0x96);
	hash.append(0x3d);
	hash.append(0x99);
	hash.append(0x32);
	hash.append(0x7f);
	hash.append(0x73);
	hash.append(0xd7);
	hash.append(0x9b);
	hash.append(0xf0);
	hash.append(0x13);
	hash.append(0xee);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x4f);
	auth_data.append(0x61);
	auth_data.append(0xde);
	auth_data.append(0x57);
	auth_data.append(0xaf);
	auth_data.append(0x21);
	auth_data.append(0xc0);
	auth_data.append(0x87);
	auth_data.append(0xcf);
	auth_data.append(0xea);
	auth_data.append(0xb1);
	auth_data.append(0xc9);
	auth_data.append(0x95);
	auth_data.append(0xee);
	auth_data.append(0xd6);
	auth_data.append(0xaf);
	auth_data.append(0x60);
	auth_data.append(0xbe);
	auth_data.append(0x25);
	auth_data.append(0x9d);
	auth_data.append(0xc7);
	auth_data.append(0x41);
	auth_data.append(0xec);
	auth_data.append(0x74);
	auth_data.append(0x17);
	auth_data.append(0x8c);
	auth_data.append(0x0);
	auth_data.append(0xfd);
	auth_data.append(0xcc);
	auth_data.append(0xe1);
	auth_data.append(0x9f);
	auth_data.append(0xf);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x16);
	sig.append(0x49);
	sig.append(0x48);
	sig.append(0x59);
	sig.append(0xbf);
	sig.append(0x34);
	sig.append(0xbd);
	sig.append(0x6);
	sig.append(0xb4);
	sig.append(0x82);
	sig.append(0x76);
	sig.append(0x73);
	sig.append(0x21);
	sig.append(0xeb);
	sig.append(0x34);
	sig.append(0xd2);
	sig.append(0x73);
	sig.append(0xb1);
	sig.append(0xa3);
	sig.append(0xf4);
	sig.append(0xa5);
	sig.append(0x81);
	sig.append(0x6b);
	sig.append(0xd2);
	sig.append(0x41);
	sig.append(0xac);
	sig.append(0xab);
	sig.append(0x72);
	sig.append(0x9);
	sig.append(0xaf);
	sig.append(0x54);
	sig.append(0x85);
	sig.append(0xf3);
	sig.append(0x3d);
	sig.append(0x57);
	sig.append(0x99);
	sig.append(0xd2);
	sig.append(0x63);
	sig.append(0x38);
	sig.append(0x61);
	sig.append(0x21);
	sig.append(0x89);
	sig.append(0xec);
	sig.append(0x48);
	sig.append(0xd0);
	sig.append(0xc);
	sig.append(0x38);
	sig.append(0xef);
	sig.append(0x8a);
	sig.append(0x6b);
	sig.append(0x46);
	sig.append(0x0);
	sig.append(0x4d);
	sig.append(0xb2);
	sig.append(0xed);
	sig.append(0x22);
	sig.append(0x99);
	sig.append(0xdf);
	sig.append(0x24);
	sig.append(0xe6);
	sig.append(0x3f);
	sig.append(0xbf);
	sig.append(0x46);
	sig.append(0x8d);
	let pk = PublicKey {
		 x: 98062414315791320893511825276646289716532063758609726248955463984107502955980, 
		 y: 26905992380475702495099141213643722602083759844864030016765563805109256343756
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_95(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x39);
	hash.append(0xb);
	hash.append(0x37);
	hash.append(0xf9);
	hash.append(0x1);
	hash.append(0xd2);
	hash.append(0x8d);
	hash.append(0xf8);
	hash.append(0xd6);
	hash.append(0x18);
	hash.append(0xc2);
	hash.append(0xec);
	hash.append(0xca);
	hash.append(0x6f);
	hash.append(0xd0);
	hash.append(0xe4);
	hash.append(0x6d);
	hash.append(0xa4);
	hash.append(0x31);
	hash.append(0x29);
	hash.append(0x65);
	hash.append(0x27);
	hash.append(0xa1);
	hash.append(0x34);
	hash.append(0xf1);
	hash.append(0xc);
	hash.append(0x80);
	hash.append(0xf0);
	hash.append(0x64);
	hash.append(0xc7);
	hash.append(0x86);
	hash.append(0x76);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x7a);
	auth_data.append(0xe3);
	auth_data.append(0xb7);
	auth_data.append(0xa8);
	auth_data.append(0x84);
	auth_data.append(0xec);
	auth_data.append(0x1c);
	auth_data.append(0x7d);
	auth_data.append(0xbb);
	auth_data.append(0x68);
	auth_data.append(0x36);
	auth_data.append(0xf6);
	auth_data.append(0x9f);
	auth_data.append(0x20);
	auth_data.append(0xfd);
	auth_data.append(0x36);
	auth_data.append(0x9f);
	auth_data.append(0x4a);
	auth_data.append(0x3c);
	auth_data.append(0xf3);
	auth_data.append(0x1e);
	auth_data.append(0x66);
	auth_data.append(0x70);
	auth_data.append(0xb7);
	auth_data.append(0x87);
	auth_data.append(0x56);
	auth_data.append(0xda);
	auth_data.append(0x93);
	auth_data.append(0x97);
	auth_data.append(0x2b);
	auth_data.append(0x87);
	auth_data.append(0xf5);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x5e);
	sig.append(0xba);
	sig.append(0xe2);
	sig.append(0x4e);
	sig.append(0x8);
	sig.append(0xdf);
	sig.append(0x15);
	sig.append(0xf);
	sig.append(0x68);
	sig.append(0xda);
	sig.append(0x7e);
	sig.append(0xda);
	sig.append(0xed);
	sig.append(0x82);
	sig.append(0x16);
	sig.append(0xef);
	sig.append(0x11);
	sig.append(0x57);
	sig.append(0x2e);
	sig.append(0x6b);
	sig.append(0xf4);
	sig.append(0x7d);
	sig.append(0x51);
	sig.append(0xdb);
	sig.append(0xac);
	sig.append(0xe2);
	sig.append(0x9);
	sig.append(0xa4);
	sig.append(0xd2);
	sig.append(0x3a);
	sig.append(0x17);
	sig.append(0x5a);
	sig.append(0x4c);
	sig.append(0x5f);
	sig.append(0x8);
	sig.append(0x6);
	sig.append(0xa0);
	sig.append(0x8d);
	sig.append(0x7b);
	sig.append(0x59);
	sig.append(0x68);
	sig.append(0xcb);
	sig.append(0xc4);
	sig.append(0x6d);
	sig.append(0xeb);
	sig.append(0xa2);
	sig.append(0x21);
	sig.append(0x7a);
	sig.append(0x82);
	sig.append(0x28);
	sig.append(0x75);
	sig.append(0xd5);
	sig.append(0xa7);
	sig.append(0x21);
	sig.append(0x3);
	sig.append(0x86);
	sig.append(0xdd);
	sig.append(0xfb);
	sig.append(0xae);
	sig.append(0x73);
	sig.append(0x75);
	sig.append(0xa8);
	sig.append(0x16);
	sig.append(0x3b);
	let pk = PublicKey {
		 x: 55036966344818790155461564576762938888487884073906962649577868810168194497497, 
		 y: 81637835212483874611884518869578229681108524809500536142281702070421185765610
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_96(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0xa3);
	hash.append(0x65);
	hash.append(0x4);
	hash.append(0xe7);
	hash.append(0x16);
	hash.append(0xf3);
	hash.append(0xed);
	hash.append(0xb4);
	hash.append(0x2f);
	hash.append(0x35);
	hash.append(0xa8);
	hash.append(0xd1);
	hash.append(0x3);
	hash.append(0x7f);
	hash.append(0xbe);
	hash.append(0xcf);
	hash.append(0x2a);
	hash.append(0xec);
	hash.append(0xe2);
	hash.append(0x46);
	hash.append(0xa8);
	hash.append(0x50);
	hash.append(0xf6);
	hash.append(0xd0);
	hash.append(0xce);
	hash.append(0x1b);
	hash.append(0xe8);
	hash.append(0xbd);
	hash.append(0x4b);
	hash.append(0x4a);
	hash.append(0x11);
	hash.append(0xd2);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x6d);
	auth_data.append(0x8c);
	auth_data.append(0x69);
	auth_data.append(0x8c);
	auth_data.append(0xe7);
	auth_data.append(0xc2);
	auth_data.append(0x8c);
	auth_data.append(0xde);
	auth_data.append(0x55);
	auth_data.append(0x8e);
	auth_data.append(0xd5);
	auth_data.append(0x86);
	auth_data.append(0x2);
	auth_data.append(0x85);
	auth_data.append(0x53);
	auth_data.append(0x2f);
	auth_data.append(0x33);
	auth_data.append(0xfd);
	auth_data.append(0xa1);
	auth_data.append(0x52);
	auth_data.append(0xf2);
	auth_data.append(0xaf);
	auth_data.append(0xc8);
	auth_data.append(0xeb);
	auth_data.append(0xb7);
	auth_data.append(0x2f);
	auth_data.append(0x1c);
	auth_data.append(0x86);
	auth_data.append(0x4a);
	auth_data.append(0x89);
	auth_data.append(0xea);
	auth_data.append(0x6);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x28);
	sig.append(0xc2);
	sig.append(0x4d);
	sig.append(0x9b);
	sig.append(0xb1);
	sig.append(0xa1);
	sig.append(0x3f);
	sig.append(0xda);
	sig.append(0x8e);
	sig.append(0xab);
	sig.append(0xcf);
	sig.append(0xff);
	sig.append(0x3b);
	sig.append(0xa7);
	sig.append(0x90);
	sig.append(0x0);
	sig.append(0x1b);
	sig.append(0xd2);
	sig.append(0x5);
	sig.append(0x68);
	sig.append(0xeb);
	sig.append(0x7f);
	sig.append(0x33);
	sig.append(0x49);
	sig.append(0xf2);
	sig.append(0x45);
	sig.append(0x4c);
	sig.append(0x8a);
	sig.append(0x7b);
	sig.append(0x5c);
	sig.append(0x58);
	sig.append(0xfa);
	sig.append(0x58);
	sig.append(0xc7);
	sig.append(0x14);
	sig.append(0xb7);
	sig.append(0x3f);
	sig.append(0x3d);
	sig.append(0x93);
	sig.append(0x9e);
	sig.append(0xa7);
	sig.append(0xb2);
	sig.append(0x2e);
	sig.append(0x12);
	sig.append(0x26);
	sig.append(0x1c);
	sig.append(0x30);
	sig.append(0xbe);
	sig.append(0xb8);
	sig.append(0x6f);
	sig.append(0x3e);
	sig.append(0x63);
	sig.append(0x5d);
	sig.append(0x88);
	sig.append(0x4c);
	sig.append(0x7d);
	sig.append(0x50);
	sig.append(0x7c);
	sig.append(0xb7);
	sig.append(0x86);
	sig.append(0x70);
	sig.append(0xe1);
	sig.append(0xaa);
	sig.append(0x73);
	let pk = PublicKey {
		 x: 106094661625332335360372307170917260947437388321317065703857803597961983287056, 
		 y: 7075447972460355835695098430353832186532829319884049131079427334532014455821
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_97(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x49);
	hash.append(0x67);
	hash.append(0x33);
	hash.append(0xe8);
	hash.append(0xcf);
	hash.append(0xfc);
	hash.append(0xbb);
	hash.append(0xc2);
	hash.append(0x67);
	hash.append(0x88);
	hash.append(0x12);
	hash.append(0x17);
	hash.append(0xa6);
	hash.append(0x7e);
	hash.append(0xc8);
	hash.append(0xc2);
	hash.append(0x30);
	hash.append(0x10);
	hash.append(0x71);
	hash.append(0x77);
	hash.append(0x37);
	hash.append(0xc6);
	hash.append(0x41);
	hash.append(0xdd);
	hash.append(0xe7);
	hash.append(0xdd);
	hash.append(0xaf);
	hash.append(0x90);
	hash.append(0xfc);
	hash.append(0x9e);
	hash.append(0x43);
	hash.append(0x14);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0x92);
	auth_data.append(0x7f);
	auth_data.append(0x8a);
	auth_data.append(0x65);
	auth_data.append(0xba);
	auth_data.append(0x4);
	auth_data.append(0x19);
	auth_data.append(0x89);
	auth_data.append(0x8c);
	auth_data.append(0x99);
	auth_data.append(0xb4);
	auth_data.append(0xe1);
	auth_data.append(0xe0);
	auth_data.append(0xa1);
	auth_data.append(0x89);
	auth_data.append(0x8a);
	auth_data.append(0xb1);
	auth_data.append(0xc2);
	auth_data.append(0xa3);
	auth_data.append(0x7d);
	auth_data.append(0x6);
	auth_data.append(0x12);
	auth_data.append(0xe3);
	auth_data.append(0x57);
	auth_data.append(0x8b);
	auth_data.append(0x69);
	auth_data.append(0x27);
	auth_data.append(0x19);
	auth_data.append(0xab);
	auth_data.append(0x1f);
	auth_data.append(0xc);
	auth_data.append(0xa1);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xb0);
	sig.append(0xbf);
	sig.append(0x82);
	sig.append(0xc3);
	sig.append(0x32);
	sig.append(0x5e);
	sig.append(0x7f);
	sig.append(0x6);
	sig.append(0x69);
	sig.append(0xc);
	sig.append(0xcd);
	sig.append(0x84);
	sig.append(0x82);
	sig.append(0x5b);
	sig.append(0xd1);
	sig.append(0x57);
	sig.append(0x1f);
	sig.append(0xc1);
	sig.append(0x68);
	sig.append(0xa0);
	sig.append(0xe);
	sig.append(0x18);
	sig.append(0xb);
	sig.append(0x58);
	sig.append(0xc);
	sig.append(0x6f);
	sig.append(0x4);
	sig.append(0x48);
	sig.append(0x14);
	sig.append(0x22);
	sig.append(0x63);
	sig.append(0x3f);
	sig.append(0x4e);
	sig.append(0xa6);
	sig.append(0xee);
	sig.append(0xec);
	sig.append(0x3);
	sig.append(0xa2);
	sig.append(0x59);
	sig.append(0x20);
	sig.append(0xa4);
	sig.append(0x4d);
	sig.append(0x83);
	sig.append(0x15);
	sig.append(0xab);
	sig.append(0x11);
	sig.append(0xb3);
	sig.append(0xb9);
	sig.append(0xdb);
	sig.append(0x1d);
	sig.append(0x8d);
	sig.append(0x4b);
	sig.append(0x69);
	sig.append(0x51);
	sig.append(0xe2);
	sig.append(0x48);
	sig.append(0xbe);
	sig.append(0xd4);
	sig.append(0x28);
	sig.append(0xca);
	sig.append(0x83);
	sig.append(0x23);
	sig.append(0x5c);
	sig.append(0x2b);
	let pk = PublicKey {
		 x: 73650617241133209917464894584894556478449839376207132925189417718401295500509, 
		 y: 17432134942671546373842467931200765259428351554609609796876729760609488904847
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_98(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x4d);
	hash.append(0xf3);
	hash.append(0x18);
	hash.append(0x1c);
	hash.append(0xdb);
	hash.append(0xe7);
	hash.append(0x20);
	hash.append(0xc1);
	hash.append(0xf);
	hash.append(0x36);
	hash.append(0xbd);
	hash.append(0xe2);
	hash.append(0x3d);
	hash.append(0x9f);
	hash.append(0xa4);
	hash.append(0x44);
	hash.append(0x80);
	hash.append(0x97);
	hash.append(0x60);
	hash.append(0x51);
	hash.append(0x64);
	hash.append(0x29);
	hash.append(0x3d);
	hash.append(0x31);
	hash.append(0x56);
	hash.append(0x97);
	hash.append(0x18);
	hash.append(0x6b);
	hash.append(0x47);
	hash.append(0xa);
	hash.append(0x85);
	hash.append(0x44);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xe4);
	auth_data.append(0x77);
	auth_data.append(0x4a);
	auth_data.append(0xbb);
	auth_data.append(0x6a);
	auth_data.append(0x48);
	auth_data.append(0xb5);
	auth_data.append(0x5);
	auth_data.append(0xb5);
	auth_data.append(0x49);
	auth_data.append(0x16);
	auth_data.append(0x4);
	auth_data.append(0xfb);
	auth_data.append(0xf2);
	auth_data.append(0xdb);
	auth_data.append(0x6);
	auth_data.append(0xa6);
	auth_data.append(0x68);
	auth_data.append(0x42);
	auth_data.append(0xd9);
	auth_data.append(0x7a);
	auth_data.append(0x2e);
	auth_data.append(0xba);
	auth_data.append(0xf8);
	auth_data.append(0x65);
	auth_data.append(0x3b);
	auth_data.append(0x1a);
	auth_data.append(0xc0);
	auth_data.append(0xfb);
	auth_data.append(0xc6);
	auth_data.append(0x5a);
	auth_data.append(0x23);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0x1b);
	sig.append(0x4e);
	sig.append(0x18);
	sig.append(0xfe);
	sig.append(0xdd);
	sig.append(0x7e);
	sig.append(0x34);
	sig.append(0xa);
	sig.append(0xae);
	sig.append(0xc);
	sig.append(0x80);
	sig.append(0x5e);
	sig.append(0x9e);
	sig.append(0xdf);
	sig.append(0x3f);
	sig.append(0x3e);
	sig.append(0xaa);
	sig.append(0x9b);
	sig.append(0x97);
	sig.append(0x92);
	sig.append(0x1a);
	sig.append(0x9);
	sig.append(0xc0);
	sig.append(0x32);
	sig.append(0x27);
	sig.append(0xef);
	sig.append(0xb7);
	sig.append(0xf0);
	sig.append(0xc4);
	sig.append(0x15);
	sig.append(0xe0);
	sig.append(0x2f);
	sig.append(0xf4);
	sig.append(0x49);
	sig.append(0x6f);
	sig.append(0x7);
	sig.append(0xb5);
	sig.append(0x1b);
	sig.append(0x6d);
	sig.append(0xd);
	sig.append(0x62);
	sig.append(0x35);
	sig.append(0x33);
	sig.append(0xa9);
	sig.append(0x49);
	sig.append(0x23);
	sig.append(0xdf);
	sig.append(0xb6);
	sig.append(0xe5);
	sig.append(0x21);
	sig.append(0xf4);
	sig.append(0x9d);
	sig.append(0x2f);
	sig.append(0x20);
	sig.append(0x74);
	sig.append(0x30);
	sig.append(0xf3);
	sig.append(0x78);
	sig.append(0xe9);
	sig.append(0x71);
	sig.append(0x5f);
	sig.append(0x4e);
	sig.append(0xc8);
	sig.append(0xa4);
	let pk = PublicKey {
		 x: 33689032971565913562699123523506146540342500964952367672644843880447486820245, 
		 y: 99529180151227170458277747625795078080851563042736640659582622426592347148524
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

#[test]
#[available_gas(200000000000)]
fn test_verify_signature_99(){
	let mut hash: Array<u8> = ArrayTrait::new();
	hash.append(0x97);
	hash.append(0x36);
	hash.append(0x82);
	hash.append(0xf4);
	hash.append(0x3);
	hash.append(0x67);
	hash.append(0xab);
	hash.append(0x41);
	hash.append(0x9a);
	hash.append(0xbb);
	hash.append(0x33);
	hash.append(0xdd);
	hash.append(0xcc);
	hash.append(0xec);
	hash.append(0x78);
	hash.append(0x80);
	hash.append(0x16);
	hash.append(0x46);
	hash.append(0x26);
	hash.append(0xd4);
	hash.append(0x8);
	hash.append(0x52);
	hash.append(0xb1);
	hash.append(0xec);
	hash.append(0x54);
	hash.append(0x8f);
	hash.append(0xf7);
	hash.append(0x87);
	hash.append(0xa4);
	hash.append(0xe2);
	hash.append(0xf1);
	hash.append(0x97);
	let mut auth_data: Array<u8> = ArrayTrait::new();
	auth_data.append(0xa4);
	auth_data.append(0x56);
	auth_data.append(0x16);
	auth_data.append(0x37);
	auth_data.append(0x8b);
	auth_data.append(0x73);
	auth_data.append(0x4e);
	auth_data.append(0xcf);
	auth_data.append(0xed);
	auth_data.append(0xbb);
	auth_data.append(0xfe);
	auth_data.append(0x29);
	auth_data.append(0x80);
	auth_data.append(0x31);
	auth_data.append(0x59);
	auth_data.append(0xa);
	auth_data.append(0xe1);
	auth_data.append(0x94);
	auth_data.append(0x5f);
	auth_data.append(0xe4);
	auth_data.append(0x2e);
	auth_data.append(0x0);
	auth_data.append(0xb0);
	auth_data.append(0x99);
	auth_data.append(0x68);
	auth_data.append(0x56);
	auth_data.append(0x56);
	auth_data.append(0x8c);
	auth_data.append(0x15);
	auth_data.append(0x35);
	auth_data.append(0x60);
	auth_data.append(0x4b);
	auth_data.append(0xa0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x0);
	auth_data.append(0x1);
	let mut sig: Array<u8> = ArrayTrait::new();
	sig.append(0xa6);
	sig.append(0x1d);
	sig.append(0xc8);
	sig.append(0xc8);
	sig.append(0x81);
	sig.append(0x9b);
	sig.append(0x9a);
	sig.append(0x80);
	sig.append(0x37);
	sig.append(0xdf);
	sig.append(0xb5);
	sig.append(0x40);
	sig.append(0xcb);
	sig.append(0xcb);
	sig.append(0x15);
	sig.append(0x68);
	sig.append(0x73);
	sig.append(0x4e);
	sig.append(0xb);
	sig.append(0x36);
	sig.append(0xc7);
	sig.append(0xb4);
	sig.append(0x7a);
	sig.append(0xc3);
	sig.append(0x8b);
	sig.append(0xab);
	sig.append(0x15);
	sig.append(0x30);
	sig.append(0xb7);
	sig.append(0x98);
	sig.append(0xcc);
	sig.append(0x5b);
	sig.append(0x8b);
	sig.append(0x60);
	sig.append(0x20);
	sig.append(0x65);
	sig.append(0xb1);
	sig.append(0xd6);
	sig.append(0x82);
	sig.append(0xca);
	sig.append(0xc1);
	sig.append(0x3b);
	sig.append(0x60);
	sig.append(0xc5);
	sig.append(0x34);
	sig.append(0x63);
	sig.append(0x4);
	sig.append(0xbf);
	sig.append(0xbf);
	sig.append(0xa8);
	sig.append(0x7d);
	sig.append(0x17);
	sig.append(0x2d);
	sig.append(0xf3);
	sig.append(0x76);
	sig.append(0xfe);
	sig.append(0x78);
	sig.append(0x44);
	sig.append(0xbc);
	sig.append(0x51);
	sig.append(0x4d);
	sig.append(0xce);
	sig.append(0x53);
	sig.append(0xb8);
	let pk = PublicKey {
		 x: 74052518942168354248470611850266965230674282927489797289595976936196152962226, 
		 y: 64916312715834589186073354567612297715179573696326033241025694338246075590627
	};
	match verify_signature(
	    hash, auth_data, pk, sig            
	) {
	    Result::Ok => (),
	    Result::Err(e) => {
	        assert(false, AuthnErrorIntoFelt252::into(e))
	    }
	}
}

