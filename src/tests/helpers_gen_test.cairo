// This file is script-generated.
// Don't modify it manually!
// See test_gen_scripts/helpers_test.py for details
use core::traits::Into;
use core::option::OptionTrait;
use array::ArrayTrait;
use webauthn::helpers::extract_u256_from_u8_array;
use webauthn::helpers::extract_r_and_s_from_array;
use webauthn::helpers::arrays_equal;

#[test]
#[available_gas(200000000000)]
fn test_extract_0(){
	let mut byte_repr: Array<u8> = ArrayTrait::new();
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	assert(
	    extract_u256_from_u8_array(@byte_repr, 0_usize).unwrap()
	    == 0_u256, 
	    'Expected equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_extract_1(){
	let mut byte_repr: Array<u8> = ArrayTrait::new();
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	assert(
	    extract_u256_from_u8_array(@byte_repr, 100_usize).unwrap()
	    == 0_u256, 
	    'Expected equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_extract_2(){
	let mut byte_repr: Array<u8> = ArrayTrait::new();
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	assert(
	    extract_u256_from_u8_array(@byte_repr, 0_usize).unwrap()
	    == 115792089237316195423570985008687907853269984665640564039457584007913129639935_u256, 
	    'Expected equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_extract_3(){
	let mut byte_repr: Array<u8> = ArrayTrait::new();
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xfe);
	assert(
	    extract_u256_from_u8_array(@byte_repr, 100_usize).unwrap()
	    == 115792089237316195423570985008687907853269984665640564039457584007913129639934_u256, 
	    'Expected equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_extract_4(){
	let mut byte_repr: Array<u8> = ArrayTrait::new();
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x1);
	assert(
	    extract_u256_from_u8_array(@byte_repr, 32_usize).unwrap()
	    == 1_u256, 
	    'Expected equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_extract_r_s_0(){
	let mut byte_repr: Array<u8> = ArrayTrait::new();
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	let (r, s): (u256, u256) = extract_r_and_s_from_array(@byte_repr).unwrap();
	assert(r == 0, 'Expected r equal!');
	assert(s == 0, 'Expected s equal!');
}

#[test]
#[available_gas(200000000000)]
fn test_extract_r_s_1(){
	let mut byte_repr: Array<u8> = ArrayTrait::new();
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x64);
	let (r, s): (u256, u256) = extract_r_and_s_from_array(@byte_repr).unwrap();
	assert(r == 0, 'Expected r equal!');
	assert(s == 100, 'Expected s equal!');
}

#[test]
#[available_gas(200000000000)]
fn test_extract_r_s_2(){
	let mut byte_repr: Array<u8> = ArrayTrait::new();
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	let (r, s): (u256, u256) = extract_r_and_s_from_array(@byte_repr).unwrap();
	assert(r == 115792089237316195423570985008687907853269984665640564039457584007913129639935, 'Expected r equal!');
	assert(s == 115792089237316195423570985008687907853269984665640564039457584007913129639935, 'Expected s equal!');
}

#[test]
#[available_gas(200000000000)]
fn test_extract_r_s_3(){
	let mut byte_repr: Array<u8> = ArrayTrait::new();
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xfe);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	byte_repr.append(0xff);
	let (r, s): (u256, u256) = extract_r_and_s_from_array(@byte_repr).unwrap();
	assert(r == 115792089237316195423570985008687907853269984665640564039457584007913129639934, 'Expected r equal!');
	assert(s == 115792089237316195423570985008687907853269984665640564039457584007913129639935, 'Expected s equal!');
}

#[test]
#[available_gas(200000000000)]
fn test_extract_r_s_4(){
	let mut byte_repr: Array<u8> = ArrayTrait::new();
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x1);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x0);
	byte_repr.append(0x20);
	let (r, s): (u256, u256) = extract_r_and_s_from_array(@byte_repr).unwrap();
	assert(r == 1, 'Expected r equal!');
	assert(s == 32, 'Expected s equal!');
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_empty(){
	let a: Array<u8> = ArrayTrait::new();
	let b: Array<u8> = ArrayTrait::new();
	assert(arrays_equal(@a, @b), 'Should equal');
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_0(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	assert(arrays_equal(@a, @b) 
	    == true, 
	    'Should  equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_1(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x7f);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	assert(arrays_equal(@a, @b) 
	    == false, 
	    'Should not equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_2(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0xff);
	b.append(0xff);
	b.append(0x7f);
	b.append(0x60);
	assert(arrays_equal(@a, @b) 
	    == false, 
	    'Should not equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_3(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	assert(arrays_equal(@a, @b) 
	    == false, 
	    'Should not equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_4(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x7f);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	assert(arrays_equal(@a, @b) 
	    == false, 
	    'Should not equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_5(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x7f);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x7f);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	assert(arrays_equal(@a, @b) 
	    == true, 
	    'Should  equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_6(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x7f);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0xff);
	b.append(0xff);
	b.append(0x7f);
	b.append(0x60);
	assert(arrays_equal(@a, @b) 
	    == false, 
	    'Should not equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_7(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x7f);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	assert(arrays_equal(@a, @b) 
	    == false, 
	    'Should not equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_8(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0xff);
	a.append(0xff);
	a.append(0x7f);
	a.append(0x60);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	assert(arrays_equal(@a, @b) 
	    == false, 
	    'Should not equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_9(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0xff);
	a.append(0xff);
	a.append(0x7f);
	a.append(0x60);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x7f);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	assert(arrays_equal(@a, @b) 
	    == false, 
	    'Should not equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_10(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0xff);
	a.append(0xff);
	a.append(0x7f);
	a.append(0x60);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0xff);
	b.append(0xff);
	b.append(0x7f);
	b.append(0x60);
	assert(arrays_equal(@a, @b) 
	    == true, 
	    'Should  equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_11(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0xff);
	a.append(0xff);
	a.append(0x7f);
	a.append(0x60);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	assert(arrays_equal(@a, @b) 
	    == false, 
	    'Should not equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_12(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	assert(arrays_equal(@a, @b) 
	    == false, 
	    'Should not equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_13(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x7f);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	assert(arrays_equal(@a, @b) 
	    == false, 
	    'Should not equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_14(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0xff);
	b.append(0xff);
	b.append(0x7f);
	b.append(0x60);
	assert(arrays_equal(@a, @b) 
	    == false, 
	    'Should not equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_15(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	a.append(0xff);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	b.append(0xff);
	assert(arrays_equal(@a, @b) 
	    == true, 
	    'Should  equal!'
	);
}

#[test]
#[available_gas(200000000000)]
fn test_arrays_equal_different_length(){
	let mut a: Array<u8> = ArrayTrait::new();
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	a.append(0x0);
	let mut b: Array<u8> = ArrayTrait::new();
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	b.append(0x0);
	assert(arrays_equal(@a, @b) 
	    == false, 
	    'Should not equal!'
	);
}

